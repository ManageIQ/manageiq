require 'awesome_spawn'
require 'evm_rake_helper'

# TODO: move into DatabaseYml
# TODO: can we use EvmDatabseOps directly?
module EvmDba
  def self.database_configuration_file
    File.expand_path(File.join(Rails.root, 'config', 'database.yml'))
  end

  def self.load_config
    require 'yaml'
    YAML::load((IO.read(self.database_configuration_file)))
  end

  def self.local?
    config = self.load_config[Rails.env]
    return false unless config['adapter'] == 'postgresql'
    return %w( 127.0.0.1 localhost ).include?(config['host']) || config['host'].blank?
  end

  def self.start
    require File.expand_path(File.join(Rails.root, 'lib/evm_database_ops'))
    Dir.chdir(Rails.root)
    EvmDatabaseOps.start
  end

  def self.stop
    require File.expand_path(File.join(Rails.root, 'lib/evm_database_ops'))
    Dir.chdir(Rails.root)
    EvmDatabaseOps.stop
  end
end

namespace :evm do
  namespace :db do
    desc 'Start the local ManageIQ EVM Database (VMDB)'
    task :start do
      EvmDba.start
    end

    desc 'Stop the local ManageIQ EVM Database (VMDB)'
    task :stop do
      EvmDba.stop
    end

    # Start the EVM Database silently - not to be a visible rake task
    task :silent_start do
      begin
        EvmDba.start
      rescue AwesomeSpawn::CommandResultError
        # ignore issues (ala silent)
      end
    end

    # Stop the EVM Database silently - not to be a visible rake task
    task :silent_stop do
      begin
        EvmDba.stop
      rescue AwesomeSpawn::CommandResultError
        # ignore issues (ala silent)
      end
    end

    desc "Seed the ManageIQ EVM Database (VMDB) with defaults"
    task :seed do
      Rake::Task['db:seed'].invoke
    end

    desc "clean up database"
    task :gc do
      require 'trollop'
      opts = Trollop.options(EvmRakeHelper.extract_command_options) do
        opt :username,   "Username",         :type => :string
        opt :password,   "Password",         :type => :string
        opt :hostname,   "Hostname",         :type => :string
        opt :dbname,     "Database name",    :type => :string
        opt :aggressive, "Aggressive gc: vaccume with all options and reindexing"
        opt :vacuum,     "Vacuum database"
        opt :reindex,    "Reindex database (or table if --table specified)"
        opt :analyze,    "Vacuum with analyze"
        opt :full,       "Vacuum full"
        opt :verbose,    "Vacuum with verbose information printed"

        opt :table,      "Tablename to reindex (if only perorm on one)", :type => :string
      end

      opts = opts.delete_if { |_k, v| v.nil? || v == false }
      EvmDatabaseOps.gc(opts)

      exit # exit so that parameters to the first rake task are not run as rake tasks
    end

    desc "Destroys the ManageIQ EVM Database (VMDB) of all tables, views and indices"
    task :destroy do
      begin
        Rake::Task['environment'].invoke
      rescue => err
        # Allow "destroying" a database that doesn't exist
        raise unless err.message =~ /does not exist$/
      end

      Rake::Task['db:drop'].invoke
      Rake::Task['db:create'].invoke

      # db:create creates a temporary connection to the default database, but doesn't
      # remove the connection in the event of a failed create, so we drop the connection
      # and reestablish it to the environment's database.
      ActiveRecord::Base.remove_connection
      ActiveRecord::Base.establish_connection(ActiveRecord::Base.configurations[Rails.env])
    end

    desc "Resets the ManageIQ EVM Database (VMDB) of all tables, views and indices"
    task :reset => [:destroy, 'db:migrate']

    # Example usage:
    #   RAILS_ENV=production bin/rake evm:db:region -- --region 99

    desc 'Set the region of the current ManageIQ EVM Database (VMDB)'
    task :region do
      require 'trollop'
      opts = Trollop.options(EvmRakeHelper.extract_command_options) do
        opt :region, "Region number", :type => :integer, :required => true
      end

      Dir.chdir(Rails.root)
      begin
        #TODO: Raise an error if region is not valid
        region = opts[:region]

        region_file = Rails.root.join("REGION")
        puts "Writing region: #{region} in #{region_file}..."

        old_region = File.exist?(region_file) ? File.read(region_file) : 0
        File.write(region_file, region)

        puts "Resetting #{Rails.env} database..."
        ENV['VERBOSE'] = 'false' # Do not flood the output with migration details
        Rake::Task['evm:db:reset'].invoke

        puts "Initializing region and database..."
        # Create the region from our REGION file, initialize a new miq_database row for this region
        AwesomeSpawn.run!("bin/rails runner", :params => ["MiqDatabase.seed; MiqRegion.seed"])
      rescue => err
        message = err.kind_of?(AwesomeSpawn::CommandResultError) ? err.result.error : err.message
        STDERR.puts "Encountered issue setting up Database using region #{region}: #{message}\n"
        File.write(region_file, old_region) if old_region
        raise
      end

      exit # exit so that parameters to the first rake task are not run as rake tasks
    end

    desc 'Check the current schema against the schema.yml file for inconsistencies'
    task :check_schema => :environment do
      message = EvmDatabase.check_schema
      raise message if message
      puts "The local schema is consistent with schema.yml"
    end

    desc 'Write the current schema to the schema.yml file'
    task :write_schema => :environment do
      EvmDatabase.write_expected_schema
      puts "Wrote configured schema to schema.yml"
    end

    # Example usage:
    #   bin/rake evm:db:backup:local -- --local-file /tmp/db_backup_test --dbname vmdb_production
    #   bin/rake evm:db:backup:remote -- --uri smb://dev005.manageiq.com/share1 --uri-username samba_one --uri-password "abc" --remote-file-name region1
    #   bin/rake evm:db:restore:local -- --local-file /tmp/db_backup_test
    #   bin/rake evm:db:restore:remote -- --uri smb://dev005.manageiq.com/share1/db_backup/region1 --uri-username samba_one --uri-password "abc"

    namespace :backup do
      require File.expand_path(File.join(Rails.root, "lib", "evm_database_ops"))
      desc 'Backup the local ManageIQ EVM Database (VMDB) to a local file'
      task :local do
        require 'trollop'
        opts = Trollop.options(EvmRakeHelper.extract_command_options) do
          opt :local_file, "Destination file", :type => :string, :required => true
          opt :username,   "Username",         :type => :string
          opt :password,   "Password",         :type => :string
          opt :hostname,   "Hostname",         :type => :string
          opt :dbname,     "Database name",    :type => :string
        end

        opts.delete_if { |k,v| v.nil? }
        EvmDatabaseOps.backup(opts)

        exit # exit so that parameters to the first rake task are not run as rake tasks
      end

      desc 'Backup the local ManageIQ EVM Database (VMDB) to a remote file'
      task :remote do
        require 'trollop'
        opts = Trollop.options(EvmRakeHelper.extract_command_options) do
          opt :uri,              "Destination depot URI",       :type => :string, :required => true
          opt :uri_username,     "Destination depot username",  :type => :string
          opt :uri_password,     "Destination depot password",  :type => :string
          opt :remote_file_name, "Destination depot filename",  :type => :string
          opt :username,         "Username",                    :type => :string
          opt :password,         "Password",                    :type => :string
          opt :hostname,         "Hostname",                    :type => :string
          opt :dbname,           "Database name",               :type => :string
        end

        db_opts = {}
        [:dbname, :username, :password, :hostname].each { |k| db_opts[k] = opts[k] if opts[k] }

        connect_opts = {}
        [:uri, :uri_username, :uri_password, :remote_file_name].each { |k| connect_opts[k] = opts[k] if opts[k] }
        connect_opts[:username] = connect_opts.delete(:uri_username) if connect_opts[:uri_username]
        connect_opts[:password] = connect_opts.delete(:uri_password) if connect_opts[:uri_password]

        EvmDatabaseOps.backup(db_opts, connect_opts)

        exit # exit so that parameters to the first rake task are not run as rake tasks
      end
    end

    namespace :restore do
      desc 'Restore the local ManageIQ EVM Database (VMDB) from a local backup file'
      task :local do
        require 'trollop'
        opts = Trollop.options(EvmRakeHelper.extract_command_options) do
          opt :local_file, "Destination file", :type => :string, :required => true
          opt :username,   "Username",         :type => :string
          opt :password,   "Password",         :type => :string
          opt :hostname,   "Hostname",         :type => :string
          opt :dbname,     "Database name",    :type => :string
        end

        opts.delete_if { |k,v| v.nil? }

        # If running through runner, disconnect any local connections
        ActiveRecord::Base.clear_all_connections! if ActiveRecord && ActiveRecord::Base

        EvmDatabaseOps.restore(opts)

        exit # exit so that parameters to the first rake task are not run as rake tasks
      end

      desc 'Restore the local ManageIQ EVM Database (VMDB) from a remote backup file'
      task :remote do
        require 'trollop'
        opts = Trollop.options(EvmRakeHelper.extract_command_options) do
          opt :uri,              "Destination depot URI",       :type => :string, :required => true
          opt :uri_username,     "Destination depot username",  :type => :string
          opt :uri_password,     "Destination depot password",  :type => :string
          opt :username,         "Username",                    :type => :string
          opt :password,         "Password",                    :type => :string
          opt :hostname,         "Hostname",                    :type => :string
          opt :dbname,           "Database name",               :type => :string
        end

        db_opts = {}
        [:dbname, :username, :password, :hostname].each { |k| db_opts[k] = opts[k] if opts[k] }

        connect_opts = {}
        [:uri, :uri_username, :uri_password].each { |k| connect_opts[k] = opts[k] if opts[k] }
        connect_opts[:username] = connect_opts.delete(:uri_username) if connect_opts[:uri_username]
        connect_opts[:password] = connect_opts.delete(:uri_password) if connect_opts[:uri_password]

        # If running through runner, disconnect any local connections
        ActiveRecord::Base.clear_all_connections! if ActiveRecord && ActiveRecord::Base

        EvmDatabaseOps.restore(db_opts, connect_opts)

        exit # exit so that parameters to the first rake task are not run as rake tasks
      end
    end

    # loads the v1 key into the enviroment
    task :environmentlegacykey => :environment do
      MiqPassword.add_legacy_key('v0_key', :v0)
      MiqPassword.add_legacy_key('v1_key', :v1)
    end
  end
end

Rake::Task["db:migrate"].enhance(["evm:db:environmentlegacykey"])

Rake::Task["db:reset"].enhance do
  warn "Caution: You ran db:reset which resets the DB from schema.rb. You probably want to re-run all the migrations with the current ruby/rails versions, so run bin/rake evm:db:reset instead."
end
