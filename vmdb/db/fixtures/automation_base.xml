<?xml version="1.0" encoding="UTF-8"?>
<MiqAeDatastore version="1.0">
  <MiqAeClass name="Object" namespace="$">
    <MiqAeMethod name="log_object" language="ruby" scope="instance" location="builtin"><![CDATA[]]>    </MiqAeMethod>
    <MiqAeMethod name="log_workspace" language="ruby" scope="instance" location="builtin"><![CDATA[]]>    </MiqAeMethod>
    <MiqAeMethod name="oracle_stored_procedure" language="ruby" scope="instance" location="builtin"><![CDATA[]]>      <MiqAeField name="database" substitute="true" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="username" substitute="true" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="password" substitute="true" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="procedure_name" substitute="true" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="params" substitute="true" datatype="string" priority="5" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeMethod name="send_email" language="ruby" scope="instance" location="builtin"><![CDATA[]]>      <MiqAeField name="to" substitute="true" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="subject" substitute="true" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="body" substitute="true" datatype="string" priority="3" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeMethod name="service_now_eccq_insert" language="ruby" scope="instance" location="builtin"><![CDATA[]]>      <MiqAeField name="server" substitute="true" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="username" substitute="true" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="password" substitute="true" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="agent" substitute="true" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="queue" substitute="true" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="topic" substitute="true" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="name" substitute="true" datatype="string" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="source" substitute="true" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="payload" substitute="true" datatype="array" priority="9" message="create">
      </MiqAeField>
    </MiqAeMethod>
  </MiqAeClass>
  <MiqAeClass name="EmailNotifications" namespace="Alert" display_name="Email Notifications">
    <MiqAeMethod name="MiqHostProvisionRequest_Approved" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqHostProvisionRequest_Approved
#
# Notes: This method is used to email the provision requester that the
# Host provisioning request has been approved
#
# Events: request_approved
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    requester does not have a valid email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'MiqHostProvisionRequest_Approved'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get variables
  miq_request = $evm.root["miq_request"]

  # Override the default appliance IP Address below
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress

  ######################################
  #
  # Build email to requester with reason
  #
  ######################################
  $evm.log('info', "#{@method} - Requester email logic starting") if @debug

  # Get requester email
  requester = $evm.root['miq_request'].requester

  # Get to_email_address from requester.email then from model if nil
  to = nil
  to  = requester.email || $evm.object['to_email_address']

  # Get from_email_address from model unless specified below
  from = nil
  from ||= $evm.object['from_email_address']

  # Get signature from model unless specified below
  signature = nil
  signature ||= $evm.object['signature']

  # Build subject
  subject = "Request ID #{miq_request.id} - Your host provisioning request was Approved, pending Quota Validation"

  # Build email body
  body = "Hello, "
  body += "<br>Your host request was approved. If Quota validation is successful you will be notified via email when the host is available."
  body += "<br><br>To view this Request go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
  body += "<br><br> Thank you,"
  body += "<br> #{signature}"

  #
  # Send email
  #
  $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
  $evm.execute(:send_email, to, from, subject, body)


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="MiqHostProvision_Complete" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqHostProvision_Complete
#
# Notes: This method sends an e-mail when the following event is raised:
#
# Events: host_provisioned
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    host's owner does not have an  email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'MiqHostProvision_Complete'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get the provisioning object
  prov = $evm.root['miq_host_provision_request'] || $evm.root['miq_host_provision']
  host = prov.host
  raise "#{@method} - Host not found" if host.nil?

  hostname = prov.get_option(:hostname)
  hostid = prov.get_option(:src_host_ids)

  # Get provisioning server
  miq_server = $evm.root['miq_server']

  # Override the default appliance IP Address below
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress

  #
  $evm.log("info", "#{@method} - Inspecting Host Object: #{host.inspect}") if @debug

  #
  # Get Host Owner Email
  #
  owner = nil
  owner ||= prov.get_option(:owner_email)
  $evm.log("info", "#{@method} - Host Owner: #{owner.inspect}") if @debug


  # to_email_address from owner.email then from model if nil
  to = owner || $evm.object['to_email_address']

  # Get from_email_address from model unless specified below
  from = nil
  from ||= $evm.object['from_email_address']

  # Get signature from model unless specified below
  signature = nil
  signature ||= $evm.object['signature']

  # Set email Subject
  subject = "Your host provisioning request has Completed - Host: #{hostname}"


  # Set the opening body to Hello
  body = "Hello, "

  #
  # Host Provisioned Email Body
  #
  body += "<br><br>Your request to provision a host was approved and completed on #{Time.now.strftime('%A, %B %d, %Y at %I:%M%p')}. "
  body += "<br><br>Host: #{hostname}<b> will be available in approximately 15 minutes</b>. "
  body += "<br><br>If you are not already logged in, you can access and manage your host here <a href='https://#{appliance}/host/show/#{hostid}'>https://#{appliance}/host/show/#{hostid}</a>"
  body += "<br><br> If you have any issues with your new host please contact Support."
  body += "<br><br> Thank you,"
  body += "<br> #{signature}"


  #
  # Send email
  #
  $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
  $evm.execute('send_email', to, from, subject, body)


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="MiqProvisionRequest_Approved" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqProvisionRequest_Approved
#
# Notes: This method is used to email the provision requester that
# VM provisioning request has been approved
#
# Events: request_approved
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    requester does not have a valid email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'MiqProvisionRequest_Approved'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: emailrequester
  #
  # Send email to requester
  #
  ###################################
  def emailrequester(miq_request, appliance)
    $evm.log('info', "#{@method} - Requester email logic starting") if @debug

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # Get Owner Email else set to nil
    owner_email = miq_request.options[:owner_email] || nil
    $evm.log('info', "#{@method} - Requester email:<#{requester_email}> Owner Email:<#{owner_email}>") if @debug

    # if to is nil then use requester_email
    to = nil
    to ||= requester_email

    # If to is still nil use to_email_address from model
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build subject
    subject = "Request ID #{miq_request.id} - Your Virtual Machine configuration was Approved, pending Quota Validation"

    # Build email body
    body = "Hello, "
    body += "<br>Your Virtual Machine Request was approved. If Quota validation is successful you will be notified via email when the VM is available."
    body += "<br><br>Approvers notes: #{miq_request.reason}"
    body += "<br><br>To view this Request go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end

  ###################################
  #
  # Method: emailapprover
  #
  # Send email to Approver
  #
  ###################################
  def emailapprover(miq_request, appliance)
    $evm.log('info', "#{@method} - Requester email logic starting") if @debug

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # If to is still nil use to_email_address from model
    to = nil
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build subject
    subject = "Request ID #{miq_request.id} - Your Virtual Machine configuration was Approved, pending Quota Validation"

    # Build email body
    body = "Approver, "
    body += "<br>Virtual Machine request received from #{requester_email} was approved."
    body += "<br><br>Approvers reason: #{miq_request.reason}"
    body += "<br><br>To view this Request go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end

  # Get miq_request from root
  miq_request = $evm.root['miq_request']
  raise "miq_request missing" if miq_request.nil?
  $evm.log("info", "#{@method} - Detected Request:<#{miq_request.id}> with Approval State:<#{miq_request.approval_state}>") if @debug

  # Override the default appliance IP Address below
  appliance = nil
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress


  # Email Requester
  emailrequester(miq_request, appliance)

  # Email Requester
  #emailapprover(miq_request, appliance)

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="MiqProvisionRequest_Denied" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqProvisionRequest_Denied
#
# Notes: This method is used to email the provision requester and approver that
# the VM provision request has been denied
#
# Events: request_denied
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    requester does not have a valid email address.To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
# Method for logging
def log(level, message)
  @method = 'MiqProvisionRequest_Denied'
  @debug = true
  $evm.log(level, "#{@method} - #{message}") if @debug
end

begin
  log(:info, "EVM Automate Method Started")

  ###################################
  #
  # Method: emailrequester
  #
  # Build email to requester with reason
  #
  ###################################
  def emailrequester(miq_request, appliance, msg, provisionRequestApproval)

    log(:info, "Requester email logic starting")

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # Get Owner Email else set to nil
    owner_email = miq_request.options[:owner_email] || nil
    log(:info, "Requester email:<#{requester_email}> Owner Email:<#{owner_email}>")

    # if to is nil then use requester_email or owner_email
    to = nil
    to ||= requester_email || owner_email

    # If to is still nil use to_email_address from model
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Set email subject
    if provisionRequestApproval
      subject = "Request ID #{miq_request.id} - Your virtual machine request was not approved"
    else
      subject = "Request ID #{miq_request.id} - Virtual Machine request was denied due to quota limitations"
    end

    # Build email body
    body = "Hello, "
    body += "<br>#{msg}."
    body += "<br><br>Approvers notes: #{miq_request.reason}" if provisionRequestApproval
    body += "<br><br>For more information you can go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email to requester
    log(:info, "Sending email to <#{to}> from <#{from}> subject: <#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: emailapprover
  #
  # Build email to approver with reason
  #
  ###################################
  def emailapprover(miq_request, appliance, msg, provisionRequestApproval)
    log('info', "Approver email logic starting")

    # Override to requesters to_email_address below or get value from requester.email then from model
    requester_email = miq_request.requester.email
    if requester_email.to_s.empty?
      requester_email ||= miq_request.requester.email
    else
      requester_email ||= $evm.object['to_email_address']
    end

    # Override to email address below or get to_email_address from from model
    to = nil
    to  ||= $evm.object['to_email_address']

    # Override from_email_address below or get from_email_address from model
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Set email subject
    if provisionRequestApproval
      subject = "Request ID #{miq_request.id} - Virtual machine request was not approved"
    else
      subject = "Request ID #{miq_request.id} - Virtual Machine request was denied due to quota limitations"
    end

    # Build email body
    body = "Approver, "
    body += "<br>A request received from #{requester_email} was denied."
    body += "<br><br>#{msg}."
    body += "<br><br>Approvers notes: #{miq_request.reason}" if provisionRequestApproval
    body += "<br><br>For more information you can go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email to approver
    log(:info, "Sending email to <#{to}> from <#{from}> subject: <#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end

  # Get miq_request from root
  miq_request = $evm.root['miq_request']
  raise "miq_request missing" if miq_request.nil?
  log(:info, "Detected Request:<#{miq_request.id}> with Approval State:<#{miq_request.approval_state}>")

  # Override the default appliance IP Address below
  appliance = nil
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress

  # Get incoming message or set it to default if nil
  msg = miq_request.resource.message || "Request denied"

  # Check to see which state machine called this method
  if msg.downcase.include?('quota')
    provisionRequestApproval = false
  else
    provisionRequestApproval = true
  end

  # Email Requester
  emailrequester(miq_request, appliance, msg, provisionRequestApproval)

  # Email Approver
  emailapprover(miq_request, appliance, msg, provisionRequestApproval)


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="MiqProvisionRequest_Pending" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqProvisionRequest_Pending
#
# Notes: This method is launched from the not_approved method which raises the requst_pending event
# when the provisioning request is NOT auto-approved
#
# Events: request_pending
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    requester does not have a valid email address.To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
# Method for logging
def log(level, message)
  @method = 'MiqProvisionRequest_Pending'
  @debug = true
  $evm.log(level, "#{@method} - #{message}") if @debug
end

begin
  log(:info, "EVM Automate Method Started")


  ###################################
  #
  # Method: emailrequester
  #
  # Build email to requester with reason
  #
  ###################################
  def emailrequester(miq_request, appliance, msg, provisionRequestApproval)
    log(:info, "Requester email logic starting")

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # Get Owner Email else set to nil
    owner_email = miq_request.options[:owner_email] || nil
    log(:info, "Requester email:<#{requester_email}> Owner Email:<#{owner_email}>")

    # if to is nil then use requester_email or owner_email
    to = nil
    to ||= requester_email # || owner_email

    # If to is still nil use to_email_address from model
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Set email subject
    subject = "Request ID #{miq_request.id} - Your Request for a new VM(s) was not Auto-Approved"

    # Build email body
    body = "Hello, "
    body += "<br>#{msg}."
    body += "<br><br>Please review your Request and update or wait for approval from an Administrator."
    body += "<br><br>To view this Request go to: "
    body += "<a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email to requester
    log(:info, "Sending email to <#{to}> from <#{from}> subject: <#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: emailapprover
  #
  # Build email to approver with reason
  #
  ###################################
  def emailapprover(miq_request, appliance, msg, provisionRequestApproval)
    log(:info, "#{@method} - Approver email logic starting")

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # Get Owner Email else set to nil
    owner_email = miq_request.options[:owner_email] || nil
    log(:info, "#{@method} - Requester email:<#{requester_email}> Owner Email:<#{owner_email}>")

    # Override to email address below or get to_email_address from from model
    to = nil
    to  ||= $evm.object['to_email_address']

    # Override from_email_address below or get from_email_address from model
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Set email subject
    if provisionRequestApproval
      subject = "#{@method} - Request ID #{miq_request.id} - Virtual machine request was not approved"
    else
      subject = "#{@method} - Request ID #{miq_request.id} - Virtual Machine request was denied due to quota limitations"
    end

    # Build email body
    body = "Approver, "
    body += "<br>A request received from #{requester_email} is pending."
    body += "<br><br>#{msg}."
    body += "<br><br>Approvers notes: #{miq_request.reason}" if provisionRequestApproval
    body += "<br><br>For more information you can go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email to approver
    log(:info, "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  # Get miq_request from root
  miq_request = $evm.root['miq_request']
  raise "miq_request missing" if miq_request.nil?
  log(:info, "#{@method} - Detected Request:<#{miq_request.id}> with Approval State:<#{miq_request.approval_state}>")

  # Override the default appliance IP Address below
  appliance = nil
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress

  # Get incoming message or set it to default if nil
  msg = miq_request.resource.message || "Request pending"

  # Check to see which state machine called this method
  if msg.downcase.include?('quota')
    provisionRequestApproval = false
  else
    provisionRequestApproval = true
  end

  # Email Requester
  emailrequester(miq_request, appliance, msg, provisionRequestApproval)

  # Email Approver
  emailapprover(miq_request, appliance, msg, provisionRequestApproval)


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="MiqProvision_Complete" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqProvision_Complete
#
# Notes: This method sends an e-mail when the following event is raised:
#
# Events: vm_provisioned
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    vm's owner does not have an  email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'MiqProvision_Complete'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get vm from miq_provision object
  prov = $evm.root['miq_provision']
  vm = prov.vm
  raise "#{@method} - VM not found" if vm.nil?


  # Override the default appliance IP Address below
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress

  #
  # Get VM Owner Name and Email
  #
  evm_owner_id = vm.attributes['evm_owner_id']
  owner = nil
  owner = $evm.vmdb('user', evm_owner_id) unless evm_owner_id.nil?
  $evm.log("info", "#{@method} - VM Owner: #{owner.inspect}") if @debug

  to = nil
  to = owner.email unless owner.nil?  
  to ||= $evm.object['to_email_address']
  if to.nil? 
    $evm.log("info", "#{@method} Email not sent because no recipient specified.")
    exit MIQ_OK
  end  

  # Assign original to_email_Address to orig_to for later use
  orig_to = to

  # Get from_email_address from model unless specified below
  from = nil
  from ||= $evm.object['from_email_address']

  # Get signature from model unless specified below
  signature = nil
  signature ||= $evm.object['signature']

  # Set email Subject
  subject = "Your virtual machine request has Completed - VM: #{vm['name']}"


  # Set the opening body to Hello
  body = "Hello, "

  # Override email to VM owner and send email to a different email address
  # if the template provisioned contains 'xx'
  #
  if prov.vm_template.name.downcase.include?('_xx_')
    $evm.log("info", "#{@method} - Setup of special email for DBMS VM") if @debug


    # Specify special email address below
    to      = 'evmadmin@company.com'

    body += "This email was sent by EVM to inform you of the provisioning of a new DBMS VM.<br>"
    body += "This new VM requires changes to DNS and DHCP to function correctly.<br>"
    body += "Please set the IP Address to static.<br>"
    body += "Once that has been completed, use this message to inform the "
    body += "requester that their new VM is ready.<br><br>"
    body += "-------------------------------- <br>"
    body += "Forward the message below to <br>"
    body += "#{orig_to}<br>"
    body += "-------------------------------- <br><br>"
    body += "<br>"
  end

  # VM Provisioned Email Body
  body += "<br><br>Your request to provision a virtual machine was approved and completed on #{Time.now.strftime('%A, %B %d, %Y at %I:%M%p')}. "
  body += "<br><br>Virtual machine #{vm['name']}<b> will be available in approximately 15 minutes</b>. "
  body += "<br><br>For Windows VM access is available via RDP and for Linux VM access is available via putty/ssh, etc. Or you can use the Console Access feature found in the detail view of your VM. "
  body += "<br><br>This VM will automatically be retired on #{vm['retires_on'].strftime('%A, %B %d, %Y')}, unless you request an extension. " if vm['retires_on'].respond_to?('strftime')
  body += " You will receive a warning #{vm['reserved'][:retirement][:warn]} days before #{vm['name']} set retirement date." if vm['reserved'] && vm['reserved'][:retirement] && vm['reserved'][:retirement][:warn]
  body += " As the designated owner you will receive expiration warnings at this email address: #{orig_to}"
  body += "<br><br>If you are not already logged in, you can access and manage your virtual machine here <a href='https://#{appliance}/vm_or_template/show/#{vm['id']}'>https://#{appliance}/vm_or_template/show/#{vm['id']}'</a>"
  body += "<br><br> If you have any issues with your new virtual machine please contact Support."
  body += "<br><br> Thank you,"
  body += "<br> #{signature}"


  #
  # Send email
  #
  $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
  $evm.execute('send_email', to, from, subject, body)


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ServiceProvision_Complete" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ServiceProvision_Complete
#
# Notes: Place holder for Service Provision Complete email #
###################################
begin
  @method = 'ServiceProvision_Complete'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  
  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ServiceTemplateProvisionRequest_Approved" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ServiceTemplateProvisionRequest_Approved
#
# Notes: This method is used to email the provision requester that
# the Service provisioning request has been approved
#
# Events: request_approved
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    requester does not have a valid email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'ServiceTemplateProvisionRequest_Approved'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: emailrequester
  #
  # Send email to requester
  #
  ###################################
  def emailrequester(miq_request, appliance)
    $evm.log('info', "#{@method} - Requester email logic starting") if @debug

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # Get Owner Email else set to nil
    owner_email = miq_request.options[:owner_email] || nil
    $evm.log('info', "#{@method} - Requester email:<#{requester_email}> Owner Email:<#{owner_email}>") if @debug

    # if to is nil then use requester_email
    to = nil
    to ||= requester_email

    # If to is still nil use to_email_address from model
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build subject
    subject = "Request ID #{miq_request.id} - Your Service provision request was Approved"

    # Build email body
    body = "Hello, "
    body += "<br>Your Service provision request was approved. If Service provisioning is successful you will be notified via email when the Service is available."
    body += "<br><br>Approvers notes: #{miq_request.reason}"
    body += "<br><br>To view this Request go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end

  ###################################
  #
  # Method: emailapprover
  #
  # Send email to Approver
  #
  ###################################
  def emailapprover(miq_request, appliance)
    $evm.log('info', "#{@method} - Requester email logic starting") if @debug

    # Get requester object
    requester = miq_request.requester

    # Get requester email else set to nil
    requester_email = requester.email || nil

    # If to is still nil use to_email_address from model
    to = nil
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build subject
    subject = "Request ID #{miq_request.id} - Your Service provision request was Approved"

    # Build email body
    body = "Approver, "
    body += "<br>Service provision request received from #{requester_email} was approved."
    body += "<br><br>Approvers reason: #{miq_request.reason}"
    body += "<br><br>To view this Request go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    # Send email
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end

  # Get miq_request from root
  miq_request = $evm.root['miq_request']
  raise "miq_request missing" if miq_request.nil?
  $evm.log("info", "#{@method} - Detected Request:<#{miq_request.id}> with Approval State:<#{miq_request.approval_state}>") if @debug

  # Override the default appliance IP Address below
  appliance = nil
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress


  # Email Requester
  emailrequester(miq_request, appliance)

  # Email Requester
  #emailapprover(miq_request, appliance)

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VmMigrateRequest_Approved" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VmMigrateRequest_Approved
#
# Notes: This method is used to email the provision requester that
# VM provisioning request has been approved
#
# Events: request_approved
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    requester does not have a valid email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'VmMigrateRequest_Approved'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Get miq_request object
  miq_request = $evm.root["miq_request"]


  # Override the default appliance IP Address below
  #appliance ||= 'evmserver.company.com'
  appliance ||= $evm.root['miq_server'].ipaddress

  ######################################
  #
  # Build email to requester with reason
  #
  ######################################
  $evm.log('info', "#{@method} - Requester email logic starting") if @debug

  # Get requester email
  requester = $evm.root['miq_request'].requester

  # Get to_email_address from requester.email then from model if nil
  to = nil
  to  = requester.email || $evm.object['to_email_address']

  # Get from_email_address from model unless specified below
  from = nil
  from ||= $evm.object['from_email_address']

  # Get signature from model unless specified below
  signature = nil
  signature ||= $evm.object['signature']

  # Build subject
  subject = "Request ID #{miq_request.id} - Your request to migrate Virtual Machine was Approved"

  # Build email body
  body = "Hello, "
  body += "<br>Your Virtual Machine migration request was approved. You will be notified via email when the VM(s) have been migrated."
  body += "<br><br>To view this Request go to: <a href='https://#{appliance}/miq_request/show/#{miq_request.id}'>https://#{appliance}/miq_request/show/#{miq_request.id}</a>"
  body += "<br><br> Thank you,"
  body += "<br> #{signature}"

  #
  # Send email
  #
  $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
  $evm.execute(:send_email, to, from, subject, body)


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VmMigrateTask_Complete" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VmMigrateTask_Complete
#
# Notes: This method sends an e-mail when the following event is raised:
#
# Events: VmMigrateTask_Complete
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    vm's owner does not have an  email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'VmMigrateTask_Complete'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  # Look in the Root Object for the request
  miq_task = $evm.root['vm_migrate_task']
  miq_server = $evm.root['miq_server']

  $evm.log("info", "Inspecting miq_task: #{miq_task.inspect}") if @debug

  exit MIQ_OK

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end


  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end


  if vm.nil?
    vm = miq_task.vm unless miq_task.nil?
  end

  #
  # No VM Found, exit
  #
  raise "VM not found" if vm.nil?



  #
  # Get VM Owner Name and Email
  #
  evm_owner_id = vm.attributes['evm_owner_id']
  owner = nil
  owner = $evm.vmdb('user', evm_owner_id) unless evm_owner_id.nil?
  $evm.log("info", "VM Owner: #{owner.inspect}") if @debug


  # to_email_address from owner.email then from model if nil
  to = owner.email || $evm.object['to_email_address']

  # Get from_email_address from model unless specified below
  from = nil
  from ||= $evm.object['from_email_address']

  # Get signature from model unless specified below
  signature = nil
  signature ||= $evm.object['signature']

  # Set email Subject
  subject = "Your virtual machine request has Completed - VM: #{vm['name']}"

  # Set the opening body to Hello
  body = "Hello, "

  #
  # VM Migration Email Body
  #
  body += "<br><br>Your request to migrate virtual machine #{vm.name} was approved and completed on #{Time.now.strftime('%A, %B %d, %Y at %I:%M%p')}. "
  body += "<br><br>If you are not already logged in, you can access and manage your virtual machine here <a href='https://#{miq_server.ipaddress}/vm/show/#{vm['id']}'>https://#{miq_server.ipaddress}/vm/show/#{vm['id']}</a>"
  body += "<br><br> Thank you,"
  body += "<br> #{signature}"


  #
  # Send email
  #
  $evm.log("info", "Sending email to <#{to}> from <#{from}> subject: <#{subject}>")
  $evm.execute('send_email', to, from, subject, body)


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_retire_extend" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_retire_extend
#
# Notes: This method is used to add 14 days to retirement date when target
# VM has a retires_on value and is not already retired
#
###################################
begin
  @method = 'vm_retire_extend'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Number of days to automatically extend retirement
  vm_retire_extend_days = nil
  vm_retire_extend_days ||= $evm.object['vm_retire_extend_days']
  raise "#{@method} - ERROR - vm_retire_extend_days not found!" if vm_retire_extend_days.nil?

  $evm.log("info","#{@method} - Number of days to extend: <#{vm_retire_extend_days}>") if @debug


  obj = $evm.object("process")

  vm = obj["vm"] || $evm.root["vm"]
  vm_name = vm.name

  # Bail out if VM does not have retirement date
  if vm.retires_on.nil? | vm.retires_on == ""
    $evm.log("info","#{@method} - VM '#{vm_name}' has no retirement date - extension bypassed") if @debug
    exit MIQ_OK
  end

  # If VM is already retired to do not continue
  if vm.retired then
    $evm.log("info", "#{@method} - VM '#{vm_name}' is already marked as retired. vm.retires_on date value is  #{vm.retires_on}. No Action taken") if @debug
    #exit MIQ_OK
  end

  $evm.log("info", "#{@method} - VM: <#{vm_name}> current retirement date is #{vm.retires_on}") if @debug


  unless vm.retires_on.nil?
    $evm.log("info", "#{@method} - Extending retirement <#{vm_retire_extend_days}> days for VM: <#{vm_name}>") if @debug

    # Set new retirement date here
    vm.retires_on += vm_retire_extend_days.to_i

    $evm.log("info", "#{@method} - VM: <#{vm_name}> new retirement date is #{vm.retires_on}") if @debug

    # Resetting last warning
    #vm.retirement[:last_warn] = nil

    $evm.log("info","#{@method} - Inspecting retirement: <#{vm.retirement.inspect}>") if @debug

    ######################################
    #
    # VM Retirement Exended Email
    #
    ######################################

    # Get VM Owner Name and Email
    evm_owner_id = vm.attributes['evm_owner_id']
    owner = nil
    owner = $evm.vmdb('user', evm_owner_id) unless evm_owner_id.nil?
    $evm.log("info", "#{@method} - Inspecting VM Owner: #{owner.inspect}") if @debug

    # to_email_address from owner.email then from model if nil
    unless owner.nil?
      to = owner.email
    else
      to = $evm.object['to_email_address']
    end

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # email subject
    subject = "VM Retirement Extended for #{vm_name}"

    # Build email body
    body = "Hello, "
    body += "<br><br>The retirement date for your virtual machine: [#{vm_name}] has been extended to: [#{vm.retires_on}]."
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"

    #
    # Send email
    #
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute('send_email', to, from, subject, body)
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_retirement_emails" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_retirement_emails
#
# Notes: This method sends out retirement emails when the following events are raised:
#
# Events: vm_retire_warn, vm_retired, vm_entered_retirement
#
# Model Notes:
# 1. to_email_address - used to specify an email address in the case where the
#    vm's owner does not have an  email address. To specify more than one email
#    address separate email address with commas. (I.e. admin@company.com,user@company.com)
# 2. from_email_address - used to specify an email address in the event the
#    requester replies to the email
# 3. signature - used to stamp the email with a custom signature
#
###################################
begin
  @method = 'vm_retirement_emails'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end


  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end


  #
  # Look in the Root Object for a Provision/Request
  #
  prov = $evm.root['miq_provision_request'] || $evm.root['miq_provision']
  if vm.nil?
    vm = prov.vm unless prov.nil?
  end

  #
  # No VM Found, exit
  #
  raise "#{@method} - User not specified" if vm.nil?


  # Get VM Name
  vm_name = vm['name']


  # Look at the Event Type in the Current Object or in the Root Object
  event_type = $evm.object['event'] || $evm.root['event_type']

  # Get provisioning server
  miq_server = $evm.root['miq_server']

  # Get VM Owner Name and Email
  evm_owner_id = vm.attributes['evm_owner_id']
  owner = nil
  owner = $evm.vmdb('user', evm_owner_id) unless evm_owner_id.nil?

  # to_email_address from owner.email then from model if nil
  unless owner.nil?
    to = owner.email
  else
    to = $evm.object['to_email_address']
  end


  ######################################
  #
  # VM Retirement Warning Email
  #
  ######################################
  if event_type == "vm_retire_warn"

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # email subject
    subject = "VM Retirement Warning for #{vm_name}"

    # Build email body
    body = "Hello, "
    body += "<br><br>Your virtual machine: [#{vm_name}] will be retired on [#{vm['retires_on']}]."
    body += "<br><br>If you need to use this virtual machine past this date please request an extension by contacting Support."
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"
  end


  ######################################
  #
  # VM Retirement Exended Email
  #
  ######################################
  if event_type == "vm_retire_extend"

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # email subject
    subject = "VM Retirement Extended for #{vm_name}"

    # Build email body
    body = "Hello, "
    body += "<br><br>Your virtual machine: [#{vm_name}] will now be retired on [#{vm['retires_on']}]."
    body += "<br><br>If you need to use this virtual machine past this date please request an extension by contacting Support."
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"
  end

  ######################################
  #
  # VM has entered Retirement Email
  #
  ######################################
  if event_type == "vm_entered_retirement"

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # email subject
    subject = "VM #{vm_name} has entered retirement"

    # Build email body
    body = "Hello, "
    body += "<br><br>Your virtual machine named [#{vm_name}] has been retired."
    body += "<br><br>You will have up to 3 days to un-retire this VM. Afterwhich time the VM will be deleted."
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"
  end

  ######################################
  #
  #  VM Retirement Email
  #
  ######################################
  if event_type == "vm_retired"

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # email subject
    subject = "VM Retirement Alert for #{vm_name}"

    # Build email body
    body = "Hello, "
    body += "<br><br>Your virtual machine named [#{vm_name}] has been retired."
    body += "<br><br> Thank you,"
    body += "<br> #{signature}"
  end

  #
  # Send email
  #
  $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
  $evm.execute('send_email', to, from, subject, body)


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="to_email_address" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="from_email_address" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="signature" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
Virtualization Infrastructure Team      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="method1" substitute="true" aetype="method" datatype="string" priority="5" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="MiqHostProvisionRequest_Approved">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
MiqHostProvisionRequest_Approved      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqHostProvision_Complete">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
MiqHostProvision_Complete      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvisionRequest_Approved">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
MiqProvisionRequest_Approved      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvisionRequest_Denied">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
MiqProvisionRequest_Denied      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvisionRequest_Pending">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
MiqProvisionRequest_Pending      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvision_Complete">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
MiqProvision_Complete      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ServiceProvision_Complete" description="ServiceProvision_Complete">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
ServiceProvision_Complete      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ServiceTemplateProvisionRequest_Approved">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
ServiceTemplateProvisionRequest_Approved      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VmMigrateRequest_Approved">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
VmMigrateRequest_Approved      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VmMigrateTask_Complete">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
VmMigrateTask_Complete      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_retire_extend">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
14      </MiqAeField>
      <MiqAeField name="method1">
vm_retire_extend      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_retirement_emails">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_retire_extend_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
vm_retirement_emails      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Email_Alerts" namespace="Alert" display_name="General Email Alerts">
    <MiqAeMethod name="EMS_Cluster_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: EMS_Cluster_Alert
#
# This method is used to send Email Alerts based on Cluster
#
###################################
begin
  @method = 'EMS_Cluster_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(ems_cluster)

    # Build options Hash
    options = {}

    options[:object] = "Cluster - #{ems_cluster.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | Cluster: [#{ems_cluster.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>Cluster <b>#{ems_cluster.name}</b> Properties:"
    body += "<br>Cluster URL: <a href='https://#{appliance}/ems_cluster/show/#{ems_cluster.id}'>https://#{appliance}/ems_cluster/show/#{ems_cluster.id}</a>"    
    body += "<br>Total Host CPU Resources: #{ems_cluster.aggregate_cpu_speed}"
    body += "<br>Total Host Memory: #{ems_cluster.aggregate_memory}"
    body += "<br>Total Host CPUs: #{ems_cluster.aggregate_physical_cpus}"
    body += "<br>Total Host CPU Cores: #{ems_cluster.aggregate_logical_cpus}"
    body += "<br>Total Configured VM Memory: #{ems_cluster.aggregate_vm_memory}"
    body += "<br>Total Configured VM CPUs: #{ems_cluster.aggregate_vm_cpus}"
    body += "<br><br>"


    body += "<br>Configuration:"
    body += "<br>HA Enabled: #{ems_cluster.ha_enabled}"
    body += "<br>HA Admit Control: #{ems_cluster.ha_admit_control}"
    body += "<br>DRS Enabled: #{ems_cluster.drs_enabled}"
    body += "<br>DRS Automation Level: #{ems_cluster.drs_automation_level}"
    body += "<br>DRS Migration Threshold: #{ems_cluster.drs_migration_threshold}"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Datacenter: #{ems_cluster.v_parent_datacenter}"
    body += "<br>Hosts: #{ems_cluster.total_hosts}"
    body += "<br>VM(s): #{ems_cluster.total_vms}"
    body += "<br><br>"

    body += "<br>Cluster Tags:"
    body += "<br>#{ems_cluster.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  ems_cluster = $evm.root['ems_cluster']
  #$evm.log("info","#{@method} - Inspecting Cluster:<#{ems_cluster.name}> Properties:<#{ems_cluster.inspect}>") if @debug

  #$evm.log("info","#{@method} - Inspecting Cluster:<#{ems_cluster.name}> Virtual Columns:<#{ems_cluster.virtual_columns_inspect}>") if @debug
  unless ems_cluster.nil?
    $evm.log("info", "#{@method} - Detected Cluster:<#{ems_cluster.name}>")

    # If email is set to true in the model
    options = buildDetails(ems_cluster)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Ext_Management_System_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Ext_Management_System_Alert
#
# This method is used to send Email Alerts based on Management System
#
###################################
begin
  @method = 'Ext_Management_System_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(ext_management_system)

    # Build options Hash
    options = {}

    options[:object] = "vCenter - #{ext_management_system.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | vCenter: [#{ext_management_system.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>vCenter <b>#{ext_management_system.name}</b> Properties:"
    body += "<br>Hostname: #{ext_management_system.hostname}"
    body += "<br>IP Address(es): #{ext_management_system.ipaddress}"
    body += "<br>Host Information:"
    body += "<br>Aggregate Host CPU Speed: #{ext_management_system.aggregate_cpu_speed.to_i / 1000} Ghz"
    body += "<br>Aggregate Host CPU Cores: #{ext_management_system.aggregate_logical_cpus}"
    body += "<br>Aggregate Host CPUs: #{ext_management_system.hardware.aggregate_physical_cpus}"
    body += "<br>Aggregate Host Memory: #{ext_management_system.aggregate_memory}"
    body += "<br>SSH Permit Root: #{ext_management_system.aggregate_vm_cpus}"
    body += "<br><br>"


    body += "<br>VM Information:"
    body += "<br>Aggregate VM Memory: #{ext_management_system.aggregate_vm_memory} bytes"
    body += "<br>Aggregate VM CPUs: #{ext_management_system.aggregate_vm_cpus} bytes"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Hosts: #{ext_management_system.total_hosts}"
    body += "<br>Datastores: #{ext_management_system.total_storages}"
    body += "<br>VM(s): #{ext_management_system.total_vms}"
    body += "<br><br>"

    body += "<br>Host Tags:"
    body += "<br>#{ext_management_system.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


 
  ext_management_system = $evm.root['ext_management_system']
  #$evm.log("info","#{@method} - Inspecting VC:<#{ext_management_system.name}> Properties:<#{ext_management_system.inspect}>") if @debug

  #$evm.log("info","#{@method} - Inspecting VC:<#{ext_management_system.name}> Virtual Columns:<#{ext_management_system.virtual_columns_inspect}>") if @debug
  unless ext_management_system.nil?
    $evm.log("info", "#{@method} - Detected Host:<#{host.name}>")

    # If email is set to true in the model
    options = buildDetails(ext_management_system)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Host_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Host_Alert
#
# This method is used to send Email Alerts based on Host
#
###################################
begin
  @method = 'Host_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(host)

    # Build options Hash
    options = {}

    options[:object] = "Host - #{host.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | Host: [#{host.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>Host <b>#{host.name}</b> Properties:"
    body += "<br>Host URL: <a href='https://#{appliance}/host/show/#{host.id}'>https://#{appliance}/host/show/#{host.id}</a>"
    body += "<br>Hostname: #{host.hostname}"
    body += "<br>IP Address(es): #{host.ipaddress}"
    body += "<br>CPU Type: #{host.hardware.cpu_type}"
    body += "<br>Cores per Socket: #{host.hardware.logical_cpus}"
    body += "<br>vRAM: #{host.hardware.memory_cpu.to_i / 1024} GB"
    body += "<br>Operating System: #{host.vmm_product} #{host.vmm_version} Build #{host.vmm_buildnumber}"
    body += "<br>SSH Permit Root: #{host.ssh_permit_root_login}"
    body += "<br><br>"


    body += "<br>Power Maangement:"
    body += "<br>Power State: #{host.power_state}"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Datacenter: #{host.v_owning_datacenter}"
    body += "<br>Cluster: #{host.v_owning_cluster}"
    body += "<br>Datastores: #{host.v_total_storages}"
    body += "<br>VM(s): #{host.v_total_vms}"
    body += "<br><br>"

    body += "<br>Host Tags:"
    body += "<br>#{host.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  host = $evm.root['host']
  #$evm.log("info","#{@method} - Inspecting Host:<#{host.name}> Properties:<#{host.inspect}>") if @debug

  #$evm.log("info","#{@method} - Inspecting Host:<#{host.name}> Virtual Columns:<#{host.virtual_columns_inspect}>") if @debug
  unless host.nil?
    $evm.log("info", "#{@method} - Detected Host:<#{host.name}>")

    # If email is set to true in the model
    options = buildDetails(host)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="MIQ_Server_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MIQ_Server_Alert
#
# This method is used to send Email Alerts based on EVM Server
#
###################################
begin
  @method = 'MIQ_Server_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(miq_server)

    # Build options Hash
    options = {}

    options[:object] = "EVM Server - #{miq_server.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | EVM Server: [#{miq_server.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>EVM Server <b>#{miq_server.name}</b> Properties:"
    body += "<br>EVM Server URL: <a href='https://#{miq_server.ipaddress}'>https://#{miq_server.ipaddress}</a>"
    body += "<br>Hostname: #{miq_server.hostname}"
    body += "<br>IP Address: #{miq_server.ipaddress}"
    body += "<br>MAC Address: #{miq_server.mac_address}"
    body += "<br>Last Heartbeat: #{miq_server.last_heartbeat}"
    body += "<br>Master: #{miq_server.is_master}"
    body += "<br>Status: #{miq_server.status}"
    body += "<br>Started On: #{miq_server.started_on}"
    body += "<br>Stopped On: #{miq_server.stopped_on}"
    body += "<br>Version: #{miq_server.version}"
    body += "<br>Zone: #{miq_server.zone}"
    body += "<br>Id: #{miq_server.id}"
    body += "<br><br>"

    body += "<br>Details:"
    body += "<br>Memory Percentage: #{miq_server.percent_memory}"
    body += "<br>Memory Usage: #{miq_server.memory_usage}"
    body += "<br>Memory Size: #{miq_server.memory_size}"
    body += "<br>CPU Percent: #{miq_server.percent_cpu}"
    body += "<br>CPU Time: #{miq_server.cpu_time}"
    body += "<br>Capabilities: #{miq_server.capabilities.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  miq_server = $evm.root['miq_server']
  #$evm.log("info","#{@method} - Inspecting miq_server:<#{miq_server.name}> Properties:<#{miq_server.inspect}>") if @debug

  #$evm.log("info","#{@method} - Inspecting EVM Server:<#{miq_server.name}> Virtual Columns:<#{miq_server.virtual_columns_inspect}>") if @debug
  unless miq_server.nil?
    $evm.log("info", "#{@method} - Detected EVM Server:<#{miq_server.name}>")

    # If email is set to true in the model
    options = buildDetails(miq_server)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Parse_Alerts" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Parse_Alerts
#
# Notes: This method is used to parse incoming Email Alerts
#
###################################
begin
  @method = 'Parse_Alerts'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Dump in-storage objects to the log
  def dumpObjects()
    return unless @debug
    # List all of the objects in the root object
    $evm.log("info", "#{@method} ===========================================")
    $evm.log("info", "#{@method} In-storage ROOT Objects:")
    $evm.root.attributes.sort.each { |k, v|
      $evm.log("info", "#{@method} -- \t#{k}: #{v}")

      #$evm.log("info", "#{@method} Inspecting #{v}: #{v.inspect}")
    }
    $evm.log("info", "#{@method} ===========================================")

  end

  dumpObjects()

  # List the types of object we will try to detect
  obj_types = { 'vm'=>'vm', 'host'=>'host}', 'storage'=>'storage', 'ems_cluster'=>'ems_cluster', 'ext_management_system'=>'ext_management_system' }
  obj_type = $evm.root.attributes.detect { |k,v| k == obj_types[k] }

  # If obj_type is NOT nil else assume miq_server
  unless obj_type.nil?
    rootobj = obj_type.first
  else
    rootobj = 'miq_server'
  end

  $evm.log("info", "#{@method} - Root Object:<#{rootobj}> Detected")

  $evm.root['object_type'] = rootobj

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Storage_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Storage_Alert
#
# This method is used to send Email Alerts based on Datastore
#
###################################
begin
  @method = 'Storage_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body
  # 
  # Returns: options Hash
  #
  ###################################
  def buildDetails(storage)

    # Build options Hash
    options = {}

    options[:object] = "Datastore - #{storage.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | Datastore: [#{storage.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention, "
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>Storage <b>#{storage.name}</b> Properties:"
    body += "<br>Storage URL: <a href='https://#{appliance}/Storage/show/#{storage.id}'>https://#{appliance}/Storage/show/#{storage.id}</a>"
    body += "<br>Type: #{storage.store_type}"
    body += "<br>Free Space: #{storage.free_space.to_i / (1024**3)} GB (#{storage.v_free_space_percent_of_total}%)"
    body += "<br>Used Space: #{storage.v_used_space.to_i / (1024**3)} GB (#{storage.v_used_space_percent_of_total}%)"
    body += "<br>Total Space: #{storage.total_space.to_i / (1024**3)} GB"
    body += "<br><br>"

    body += "<br>Information for Registered VMs:"
    body += "<br>Used + Uncommitted Space: #{storage.v_total_provisioned.to_i / (1024**3)} GB (#{storage.v_provisioned_percent_of_total}%)"
    body += "<br><br>"

    body += "<br>Content:"
    body += "<br>VM Provisioned Disk Files: #{storage.disk_size.to_i / (1024**3)} GB (#{storage.v_disk_percent_of_used}%)"
    body += "<br>VM Snapshot Files: #{storage.snapshot_size.to_i / (1024**3)} GB (#{storage.v_snapshot_percent_of_used}%)"
    body += "<br>VM Memory Files: #{storage.v_total_memory_size.to_i / (1024**3)} GB (#{storage.v_memory_percent_of_used}%)"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Number of Hosts attached: #{storage.v_total_hosts}"
    body += "<br>Total Number of VMs: #{storage.v_total_vms}"
    body += "<br><br>"

    body += "<br>Datastore Tags:"
    body += "<br>#{storage.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  storage = $evm.root['storage']
  #$evm.log("info","#{@method} - Inspecting Storage:<#{storage.name}> Properties:<#{storage.inspect}>")

  #$evm.log("info","#{@method} - Inspecting Storage:<#{storage.name}> Virtual Columns:<#{storage.virtual_columns_inspect}>")
  unless storage.nil?
    # If email is set to true in the model
    options = buildDetails(storage)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VM_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VM_Alert
#
# This method is used to send Email Alerts based on VM
#
###################################
begin
  @method = 'VM_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(vm)

    # Build options Hash
    options = {}

    options[:object] = "VM - #{vm.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | VM: [#{vm.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>VM <b>#{vm.name}</b> Properties:"
    body += "<br>VM URL: <a href='https://#{appliance}/VM/show/#{vm.id}'>https://#{appliance}/VM/show/#{vm.id}</a>"
    body += "<br>Hostname: #{vm.hostnames.inspect}"
    body += "<br>IP Address(es): #{vm.ipaddresses.inspect}"
    body += "<br>vCPU: #{vm.num_cpu}"
    body += "<br>vRAM: #{vm.mem_cpu.to_i} MB"
    body += "<br>Tools Status: #{vm.tools_status}"
    body += "<br>Operating System: #{vm.operating_system['product_name']}"
    body += "<br>Disk Alignment: #{vm.disks_aligned}"
    body += "<br><br>"


    body += "<br>Power Maangement:"
    body += "<br>Power State: #{vm.power_state}"
    body += "<br>Last Boot: #{vm.boot_time}"
    body += "<br><br>"

    body += "<br>Snapshot Information:"
    body += "<br>Total Snapshots: #{vm.v_total_snapshots}"
    body += "<br>Total Snapshots: #{vm.v_total_snapshots}"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Datacenter: #{vm.v_owning_datacenter}"
    body += "<br>Cluster: #{vm.ems_cluster_name}"
    body += "<br>Host: #{vm.host_name}"
    body += "<br>Datastore Path: #{vm.v_datastore_path}"
    body += "<br>Resource Pool: #{vm.v_owning_resource_pool}"
    body += "<br><br>"

    body += "<br>VM Tags:"
    body += "<br>#{vm.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>")
    $evm.execute(:send_email, to, from, subject, body)
  end


  vm = $evm.root['vm']
  #$evm.log("info","#{@method} - Inspecting VM:<#{vm.name}> Properties:<#{vm.inspect}>") if @debug

  #$evm.log("info","#{@method} - Inspecting VM:<#{vm.name}> Virtual Columns:<#{vm.virtual_columns_inspect}>") if @debug
  unless vm.nil?
    $evm.log("info", "#{@method} - Detected VM:<#{vm.name}>")

    # If email is set to true in the model
    options = buildDetails(vm)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="appliance" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="to_email_address" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="from_email_address" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="signature" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
EVM Operations Team      </MiqAeField>
      <MiqAeField name="email" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
false      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="6" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="EMS_Cluster_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
true      </MiqAeField>
      <MiqAeField name="execute">
EMS_Cluster_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Ext_Management_System_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
true      </MiqAeField>
      <MiqAeField name="execute">
Ext_Management_System_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Host_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
true      </MiqAeField>
      <MiqAeField name="execute">
Host_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MIQ_Server_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
true      </MiqAeField>
      <MiqAeField name="execute">
MIQ_Server_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Parse_Alerts">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
Parse_Alerts      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Storage_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
true      </MiqAeField>
      <MiqAeField name="execute">
Storage_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VM_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
true      </MiqAeField>
      <MiqAeField name="execute">
VM_Alert      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Cluster" namespace="Automation" display_name="Cluster Management">
    <MiqAeSchema>
      <MiqAeField name="method1" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
  </MiqAeClass>
  <MiqAeClass name="HostLifecycle" namespace="Automation" display_name="Host Lifecycle Management">
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship1" substitute="true" aetype="relationship" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="Method1" substitute="true" aetype="method" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship2" substitute="true" aetype="relationship" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="Method2" substitute="true" aetype="method" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship3" substitute="true" aetype="relationship" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="Method3" substitute="true" aetype="method" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship4" substitute="true" aetype="relationship" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="Method4" substitute="true" aetype="method" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship5" substitute="true" aetype="relationship" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="Method5" substitute="true" aetype="method" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship6" substitute="true" aetype="relationship" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="Method6" substitute="true" aetype="method" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship7" substitute="true" aetype="relationship" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="Method7" substitute="true" aetype="method" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship8" substitute="true" aetype="relationship" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="Method8" substitute="true" aetype="method" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship9" substitute="true" aetype="relationship" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="Method9" substitute="true" aetype="method" priority="20" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship10" substitute="true" aetype="relationship" priority="21" message="create">
      </MiqAeField>
      <MiqAeField name="Method10" substitute="true" aetype="method" priority="22" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship11" substitute="true" aetype="relationship" priority="23" message="create">
      </MiqAeField>
      <MiqAeField name="Method11" substitute="true" aetype="method" priority="24" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship12" substitute="true" aetype="relationship" priority="25" message="create">
      </MiqAeField>
      <MiqAeField name="Method12" substitute="true" aetype="method" priority="26" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship13" substitute="true" aetype="relationship" priority="27" message="create">
      </MiqAeField>
      <MiqAeField name="Method13" substitute="true" aetype="method" priority="28" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship14" substitute="true" aetype="relationship" priority="29" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="30" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Discovery" display_name="Host Discovery">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship14">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Provisioning" display_name="Host Provisioning">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship5">
/EVMApplications/Provisioning/Profile/Host/${/#user.normalized_ldap_group}#get_state_machine      </MiqAeField>
      <MiqAeField name="Method5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship6">
/Factory/StateMachines/${/#state_machine}/${/#miq_host_provision.provision_type}      </MiqAeField>
      <MiqAeField name="Method6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship14">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Retirement" display_name="Host Retirement">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship14">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ServiceLifecycle" namespace="Automation" display_name="Service Lifecycle Management">
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="relationship1" substitute="true" aetype="relationship" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="method1" substitute="true" aetype="method" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="relationship2" substitute="true" aetype="relationship" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="method2" substitute="true" aetype="method" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="relationship3" substitute="true" aetype="relationship" datatype="string" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="method3" substitute="true" aetype="method" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="relationship4" substitute="true" aetype="relationship" datatype="string" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="method5" substitute="true" aetype="method" datatype="string" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" datatype="string" priority="11" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="retirement" display_name="Retirement">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="relationship1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="relationship2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="relationship3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="relationship4">
/Factory/StateMachines/ServiceRetirement/Default      </MiqAeField>
      <MiqAeField name="method5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VMLifecycle" namespace="Automation" display_name="VM Lifecycle Management">
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship1" substitute="true" aetype="relationship" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="Method1" substitute="true" aetype="method" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship2" substitute="true" aetype="relationship" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="Method2" substitute="true" aetype="method" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship3" substitute="true" aetype="relationship" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="Method3" substitute="true" aetype="method" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship4" substitute="true" aetype="relationship" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="Method4" substitute="true" aetype="method" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship5" substitute="true" aetype="relationship" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="Method5" substitute="true" aetype="method" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship6" substitute="true" aetype="relationship" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="Method6" substitute="true" aetype="method" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship7" substitute="true" aetype="relationship" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="Method7" substitute="true" aetype="method" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship8" substitute="true" aetype="relationship" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="Method8" substitute="true" aetype="method" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship9" substitute="true" aetype="relationship" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="Method9" substitute="true" aetype="method" priority="20" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship10" substitute="true" aetype="relationship" priority="21" message="create">
      </MiqAeField>
      <MiqAeField name="Method10" substitute="true" aetype="method" priority="22" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship11" substitute="true" aetype="relationship" priority="23" message="create">
      </MiqAeField>
      <MiqAeField name="Method11" substitute="true" aetype="method" priority="24" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship12" substitute="true" aetype="relationship" priority="25" message="create">
      </MiqAeField>
      <MiqAeField name="Method12" substitute="true" aetype="method" priority="26" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship13" substitute="true" aetype="relationship" priority="27" message="create">
      </MiqAeField>
      <MiqAeField name="Method13" substitute="true" aetype="method" priority="28" message="create">
      </MiqAeField>
      <MiqAeField name="Relationship14" substitute="true" aetype="relationship" priority="29" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="30" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Discovery" display_name="VM Discovery">
      <MiqAeField name="Relationship1">
/Factory/Method/vm_allowed?vm_id=${process#vm_id}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Migrate" display_name="VM Migrate">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship5">
/EVMApplications/Operations/Profile/VMMigrate/${/#user.normalized_ldap_group}#get_state_machine      </MiqAeField>
      <MiqAeField name="Method5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship6">
/Factory/StateMachines/${/#state_machine}/default      </MiqAeField>
      <MiqAeField name="Method6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship14">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Provisioning" display_name="VM Provisioning">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship5">
/EVMApplications/Provisioning/Profile/VM/${/#user.normalized_ldap_group}#get_state_machine      </MiqAeField>
      <MiqAeField name="Method5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship6">
/Factory/StateMachines/${/#state_machine}/${/#miq_provision.provision_type}      </MiqAeField>
      <MiqAeField name="Method6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method10">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method11">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method12">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Method13">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Relationship14">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Retirement" display_name="VM Retirement">
      <MiqAeField name="Relationship4">
/Factory/StateMachines/VMRetirement/Default      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="vm" namespace="Automation" description="VM Management" display_name="VM Management">
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="logical_event" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" datatype="string" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" datatype="string" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" datatype="string" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" datatype="string" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="vm" substitute="true" aetype="attribute" datatype="vm" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" datatype="string" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" datatype="string" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" datatype="string" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" datatype="string" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" datatype="string" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" datatype="string" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" datatype="string" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" datatype="string" priority="20" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" datatype="string" priority="21" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" datatype="string" priority="22" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing">
      <MiqAeField name="guard">
false      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Intelligent_Workload_Management" namespace="EVMApplications/Operations" display_name="Intelligent Workload Management">
    <MiqAeMethod name="Cluster_Workload_Management" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Cluster_Workload_Management
#
# Notes: This method will find a VM that is running hot in a given cluster and 
# vMotion the VM to a more desirable host within that cluster
#
###################################
begin
  @method = 'Cluster_Workload_Management'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  def emailresults(vm_culprit, host_culprit, host_culprit_type, host_culprit_percent, target_host)
    # Get to_email_address from model unless specified below
    to = nil
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    subject = "Cluster Workload Manager Services"


    body  = "Hello, "
    body += "<br>"
    body += "EVM has detected high "
    if host_culprit_type == :mem
      body += "memory utilization"
    else
      body += "CPU utilization"
    end
    body += " of (#{host_culprit_percent}%) on host #{host_culprit}."
    body += "<br>"
    body += "<br>"

    body += "Moving VM <b>#{vm_culprit}</b> to target host #{target_host}"
    body += "<br><br>"
    body += "Thank You,"
    body += "<br><br>"
    body += "#{signature}"
    body += "<br>"

    #
    # Send email
    #
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute('send_email', to, from, subject, body)

  end

  def loghost_object(h)
    # Log Host CPU average usage I.e. Host CPU Usage: <1751.69884833285>
    $evm.log("info","#{@method} - Host: <#{h.name}> Average CPU Usage: <#{h.cpu_usagemhz_rate_average_avg_over_time_period}>") if @debug

    # Log Host Memory average usage I.e. Host Memory Usage: <9341.15865541251>
    $evm.log("info","#{@method} - Host: <#{h.name}> Average Memory Usage: <#{h.derived_memory_used_avg_over_time_period}>") if @debug

    # Log Host CPU Speed I.e. cpu_speed: 2493
    $evm.log("info","#{@method} - Host: <#{h.name}> CPU Speed: <#{h.hardware.cpu_speed}>") if @debug

    # Log Host Memory  I.e. memory_cpu: 8190
    $evm.log("info","#{@method} - Host: <#{h.name}> Memory: <#{h.hardware.memory_cpu}>") if @debug

    # Log Current Host CPU usage I.e. cpu_usage: 366
    $evm.log("info","#{@method} - Host: <#{h.name}> Current CPU Usage: <#{h.hardware.cpu_usage}>") if @debug

    # Log Current Host Memory usage I.e. memory_usage: 4690
    $evm.log("info","#{@method} - Host: <#{h.name}> Memory Usage: <#{h.hardware.memory_usage}>") if @debug
  end

  #
  # Initialize variables
  #

  # Set host thresholds
  host_cpu_threshold = 0.6
  host_mem_threshold = 0.6


  # Get Cluster
  ems_cluster = $evm.root['ems_cluster']
  #$evm.log("info","Inspecting ems_cluster: <#{ems_cluster.inspect}>")   if @debug
  raise "#{@method} - EMS Cluster not found" if ems_cluster.nil?

  # Log Cluster CPU usage I.e. Cluster CPU Usage: <3381.90824648164>
  $evm.log("info","#{@method} - Cluster: <#{ems_cluster.name}> CPU Usage: <#{ems_cluster.cpu_usagemhz_rate_average_avg_over_time_period}>") if @debug
  # Log Cluster Memory usage I.e. Cluster Memory Usage: <21410.959239421>
  $evm.log("info","#{@method} - Cluster: <#{ems_cluster.name}> Memory Usage: <#{ems_cluster.derived_memory_used_avg_over_time_period}>") if @debug

  # Get hosts attached to the cluster
  hosts = ems_cluster.hosts
  raise "#{@method} - No Hosts found on Cluster:<#{ems_cluster.name}> not found" if hosts.nil?

  # Loop through all hosts
  host_suspects = hosts.find_all { |h| h.power_state == 'on'}

  host_exceeded = []
  host_all = []

  host_suspects.each do |h|
    loghost_object(h) if @debug

    # Get Host CPU Capacity
    host_cpu_capacity = h.hardware.cpu_speed * h.hardware.logical_cpus
    host_cpu_percent = (h.cpu_usagemhz_rate_average_avg_over_time_period / host_cpu_capacity)
    $evm.log("info","#{@method} - Host:<#{h.name}> CPU Capacity: <#{host_cpu_capacity}> CPU Percent: <#{host_cpu_percent}>") if @debug

    host_all << {:id => h.id, :percent => host_cpu_percent, :type => :cpu}
    if host_cpu_percent >= host_cpu_threshold
      $evm.log("info","#{@method} - Host: <#{h.name}> CPU Percent: <#{host_cpu_percent}> has exceeded CPU threshold: <#{host_cpu_threshold}>") if @debug
      host_exceeded << {:id => h.id, :percent => host_cpu_percent, :type => :cpu}
    else
      $evm.log("info","#{@method} - Host: <#{h.name}> CPU Percent: <#{host_cpu_percent}> is within CPU threshold: <#{host_cpu_threshold}>") if @debug
    end

    host_mem_percent = (h.derived_memory_used_avg_over_time_period / h.hardware.memory_cpu)
    $evm.log("info","#{@method} - Host:<#{h.name}> Memory Capacity: <#{h.hardware.memory_cpu}> CPU Percent: <#{host_mem_percent}>") if @debug

    host_all << {:id => h.id, :percent => host_mem_percent, :type => :mem}
    if host_mem_percent >= host_mem_threshold
      $evm.log("info","#{@method} - Host: <#{h.name}> Memory percent: <#{host_mem_percent}> has exceeded Memory threshold: <#{host_mem_threshold}>") if @debug
      host_exceeded << {:id => h.id, :percent => host_mem_percent, :type => :mem}
    else
      $evm.log("info","#{@method} - Host: <#{h.name}> Memory percent: <#{host_mem_percent}> is within Memory threshold: <#{host_mem_threshold}>") if @debug
    end
  end

  unless host_exceeded.blank?
    host_all.sort! {|a,b| a[:percent] <=> b[:percent]}
    host_exceeded.sort! {|a,b| a[:percent] <=> b[:percent]}
    host_culprit_stats = host_exceeded.pop
    host_culprit = host_suspects.detect {|h| h.id == host_culprit_stats[:id]}

    # Only include VM's that are powered on
    vm_suspects = host_culprit.vms.find_all { |v| v.power_state == 'on'}

    if host_culprit_stats[:type] == :mem
      vm_suspects.sort! {|a,b| a.derived_memory_used_avg_over_time_period <=> b.derived_memory_used_avg_over_time_period}
    else
      vm_suspects.sort! {|a,b| a.cpu_usagemhz_rate_average_avg_over_time_period <=> b.cpu_usagemhz_rate_average_avg_over_time_period}
    end

    vm_culprit = vm_suspects.pop
    target_host_stats = host_all.detect {|h| h[:type] == host_culprit_stats[:type]}
    target_host = host_suspects.detect {|h| h.id == target_host_stats[:id]}

    # Log VM Memory  I.e. mem_cpu: <4096>
    $evm.log("info","#{@method} - VM: <#{vm_culprit.name}> Memory: <#{vm_culprit.mem_cpu}>") if @debug

    # Log VM CPU Count I.e. CPU Count: <2>
    $evm.log("info","#{@method} - VM: <#{vm_culprit.name}> CPU Count: <#{vm_culprit.num_cpu}>") if @debug

    # Log VM CPU average usage I.e. Average CPU Usage: <405.791768303411>
    $evm.log("info","#{@method} - VM: <#{vm_culprit.name}> Average CPU Usage: <#{vm_culprit.cpu_usagemhz_rate_average_avg_over_time_period}>") if @debug

    # Log VM Memory average usage I.e. Average Memory Usage: <863.462927057142>
    $evm.log("info","#{@method} - VM: <#{vm_culprit.name}> Average Memory Usage: <#{vm_culprit.derived_memory_used_avg_over_time_period}>") if @debug

    # Email the results
    host_culprit_percent = (host_culprit_stats[:percent] * 100).to_i
    emailresults(vm_culprit.name.downcase, host_culprit.name, host_culprit_stats[:type], host_culprit_percent, target_host.name)

    # Log the culprit VM
    $evm.log("info","#{@method} - Migrating VM: <#{vm_culprit.name}> from Source Host: <#{host_culprit.name}> to Target Host: <#{target_host.name}>") if @debug

    # VMotion culprit VM to Target_host
    vm_culprit.migrate(target_host)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Host_Evacuation" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Host_Evacuation
#
# Notes: When a VM encounters high CPU % Ready, VMotion VM to a more
# suitable host.
#
###################################
begin
  @method = 'Host_Evacuation'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Method: emailresults
  #
  def emailresults(vmname, current_host, target_host)
    # Get to_email_address from model unless specified below
    to = nil
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']
    subject = "Alert! EVM will be VMotioning VM: #{vmname}"

    body  = "Hello, "
    body += "<br>"
    body += "EVM will VMotion VM: <b>#{vmname}</b> from current Host: <b>#{current_host}</b> to target Host: <b>#{target_host}</b>."
    body += "<br><br>"
    body += "Thank You,"
    body += "<br><br>"
    body += "#{signature}"
    body += "<br>"

    #
    # Send email
    #
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute('send_email', to, from, subject, body)
  end

  #
  # Initialize variables
  #
  host = $evm.root['host']
  raise "#{@method} - Host object not found" if host.nil?
  $evm.log("info","#{@method} - Inspecting host object: <#{host.inspect}>") if @debug

  esxhost_scope = nil
  esxhost_scope ||= $evm.object['esxhost_scope']

  # Get the VC
  if esxhost_scope && esxhost_scope.downcase == "cluster"
    ems = host.ems_cluster
    $evm.log("info","#{@method} - ESX Scope will limited to hosts in Cluster") if @debug
  else
    ems = host.ext_management_system
    $evm.log("info","#{@method} - ESX Scope will limited to hosts in Virtual Center") if @debug
  end

  curr_host_cpu_percent = host.get_realtime_metric(:v_pct_cpu_ready_delta_summation, [15.minutes.ago.utc,5.minutes.ago.utc], :avg)

  # Get hosts attached to the VC
  hosts = ems.hosts

  # Loop through all hosts
  host_suspects = hosts.find_all { |h| h.power_state == 'on' && h.name != host.name}

  host_all = []

  host_suspects.each do |h|
    host_cpu_percent = h.get_realtime_metric(:v_pct_cpu_ready_delta_summation, [15.minutes.ago.utc,5.minutes.ago.utc], :avg)
    host_all << {:id => h.id, :percent => host_cpu_percent, :type => :cpu}
    $evm.log("info","#{@method} - ESX Host: <#{h.name}> CPU Ready Delta Summation: <#{host_cpu_percent}>") if @debug
  end

  host_all.sort! {|a,b| a[:percent] <=> b[:percent]}

  target_host = host_suspects.detect {|h| h.id == host_all.first[:id] }

  # Get a list of all VM's on the current host
  vms = host.vms.find_all

  vms.each do |v|

    # Email Results
    emailresults(v.name, target_host.name, host.name)

    $evm.log("info","#{@method} - VM: <#{v.name}> on Host: <#{host.name}> will be moved to target ESX Host: <#{target_host.name}>") if @debug
    # VMotion VM to Target_host
    v.migrate(target_host)
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VM_Placement_Optimization" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VM_Placement_Optimization
#
# Notes: When a VM encounters high CPU % Ready, VMotion VM to a more
# suitable host.
#
###################################
begin
  @method = 'VM_Placement_Optimization'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  def emailresults(vmname, target_host, vm_host, vmotion, event_type)
    # Get to_email_address from model unless specified below
    to = nil
    to ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']
    subject = "Alert! EVM has detected event [#{event_type}] on VM #{vmname}"

    body  = "Hello, "
    body += "<br>"
    body += "EVM has detected event: #{event_type} on VM: <b>#{vmname}</b> running on Host: <b>#{vm_host}</b>."
    body += "<br><br>"

    if vmotion
      body += "VM: <b>#{vmname}</b> will be moved to Host: <b>#{target_host}</b>"
    else
      body += "Host: <b>#{vm_host}</b> is already the lowest CPU % Ready Host. <br><br>"
      body += "VM: <b>#{vmname}</b> will NOT be moved."
    end

    body += "<br><br>"
    body += "Thank You,"
    body += "<br><br>"
    body += "#{signature}"
    body += "<br>"

    #
    # Send email
    #
    $evm.log("info", "#{@method} - Sending email to <#{to}> from <#{from}> subject: <#{subject}>") if @debug
    $evm.execute('send_email', to, from, subject, body)
  end


  #
  # Initialize variables
  #
  vm = $evm.root['vm']
  raise "#{@method} - VM object not found" if vm.nil?
  #$evm.log("info","Inspecting vm object: <#{vm.inspect}>")

  vm_host = vm.host
  curr_host_cpu_percent = vm_host.get_realtime_metric(:v_pct_cpu_ready_delta_summation, [15.minutes.ago.utc,5.minutes.ago.utc], :avg)

  process = $evm.object('process')
  event_type = process.attributes['event_type']
  event_type ||= 'High CPU Percent Ready Time'

  # Get the ESX Host scope from VC or Cluster
  # Default is to get ESX Hosts from the Cluster source VM resides
  host_scope = nil
  host_scope ||= $evm.object['host_scope']

  if host_scope && host_scope.downcase == "vc"
    ems = vm.ext_management_system
  else
    ems = vm.ems_cluster
  end
  $evm.log("info","#{@method} - Detected Host Scope: <#{host_scope}>") if @debug
  $evm.log("info","#{@method} - VM: <#{vm.name}> currently residing on Host: <#{vm_host.name}> with CPU % Ready: <#{curr_host_cpu_percent}>") if @debug


  # Get hosts attached to the VC
  hosts = ems.hosts

  # Loop through all hosts
  host_suspects = hosts.find_all { |h| h.power_state == 'on' && h.name != vm_host.name}

  host_all = []

  host_suspects.each do |h|
    host_cpu_percent = h.get_realtime_metric(:v_pct_cpu_ready_delta_summation, [15.minutes.ago.utc,5.minutes.ago.utc], :avg)

    host_all << {:id => h.id, :percent => host_cpu_percent, :type => :cpu}
    $evm.log("info","#{@method} - ESX Host: <#{h.name}> CPU Ready Delta Summation: <#{host_cpu_percent}>") if @debug
  end

  host_all.sort! {|a,b| a[:percent] <=> b[:percent]}

  target_host = host_suspects.detect {|h| h.id == host_all.first[:id] }
  vmotion = true
  if curr_host_cpu_percent <= host_all.first[:percent]
    $evm.log("info","#{@method} - ESX Host: >#{target_host}> is the lowest CPU Ready Host. VM: <#{vm.name}> will NOT be moved.") if @debug
    vmotion = true
  else
    $evm.log("info","#{@method} - VM: <#{vm.name}> will be moved to ESX Host: <#{target_host.name}> with CPU % Ready: <#{host_all.first[:percent]}>") if @debug
  end

  # Email Results
  emailresults(vm.name, target_host.name, vm_host, vmotion, event_type)

  # VMotion VM to Target_host
  if vmotion
    vm.migrate(target_host)
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="to_email_address" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="from_email_address" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="signature" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
Enterprise Virtualization Team      </MiqAeField>
      <MiqAeField name="host_scope" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
cluster      </MiqAeField>
      <MiqAeField name="method1" substitute="true" aetype="method" datatype="string" priority="5" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Cluster_Workload_Management">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host_scope">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
Cluster_Workload_Management      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Host_Evacuation">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host_scope">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
Host_Evacuation      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VM_Placement_Optimization" display_name="VM_Placement_Optimization">
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host_scope">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="method1">
VM_Placement_Optimization      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VmMigrate" namespace="EVMApplications/Operations/Profile" display_name="Vm Migrate Group">
    <MiqAeMethod name="get_deploy_dialog" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: get_deploy_dialog
#
# Notes: Dynamically choose dialog based on Category:environment chosen in pre-dialog
#
#
###################################
begin
  @method = 'get_deploy_dialog'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  # Set to true to dynamically choose dialog name based on environment tag
  run_env_dialog = false


  if run_env_dialog
    # Get incoming environment tags from pre-dialog
    dialog_input_vm_tags = $evm.root['dialog_input_vm_tags']

    # Use a regular expression to grab the environment from the incoming tag category
    # I.e. environment/dev for Category:environment Tag:dev
    regex = /(.*)(\/)(\w*)/i

    # If the regular express matches dynamically choose the next dialog
    if regex =~ dialog_input_vm_tags
      cat = $1
      tag = $3
      $evm.log("info","Category: #<{cat}> Tag: <#{tag}>")
      dialog_name = 'vm_migrate_dialogs-deploy-#{tag}'
    end
    ## Set dialog name in the root object to be picked up by dialogs
    $evm.root['dialog_name'] = dialog_name
    $evm.log("info", "Launching <#{dialog_name}>")

  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="pre_dialog_name" substitute="true" aetype="attribute" datatype="string" priority="1" message="get_pre_dialog_name" collect="/dialog_name = pre_dialog_name">
      </MiqAeField>
      <MiqAeField name="get_dialog_name" substitute="true" aetype="method" datatype="string" priority="2" message="get_state_machine">
      </MiqAeField>
      <MiqAeField name="dialog_name" substitute="true" aetype="attribute" datatype="string" priority="3" message="get_dialog_name" collect="/dialog_name = dialog_name">
vm_migrate_dialogs      </MiqAeField>
      <MiqAeField name="state_machine" substitute="true" aetype="attribute" datatype="string" priority="4" message="get_state_machine" collect="/state_machine = state_machine">
VMMigrate      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing">
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="EvmGroup-super_administrator">
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="EvmGroup-user_self_service">
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="DHCP_Server" namespace="EVMApplications/Provisioning" display_name="DHCP Server">
    <MiqAeSchema>
      <MiqAeField name="name" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="ip" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="domain" substitute="true" aetype="relationship" datatype="string" priority="3" message="create" collect="domain">
      </MiqAeField>
      <MiqAeField name="dhcp_server" substitute="true" aetype="attribute" datatype="string" priority="4" message="create" collect="{:ip =&gt; ip, :name =&gt; name, :domain =&gt; domain}">
      </MiqAeField>
    </MiqAeSchema>
  </MiqAeClass>
  <MiqAeClass name="Domain" namespace="EVMApplications/Provisioning" display_name="ActiveDirectory Domain" inherits="$/Object">
    <MiqAeSchema>
      <MiqAeField name="name" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="base_dn" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="bind_dn" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="bind_password" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="ldap_host" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="ldap_port" substitute="true" aetype="attribute" datatype="integer" priority="6" message="create">
389      </MiqAeField>
      <MiqAeField name="user_type" substitute="true" aetype="attribute" datatype="string" priority="7" message="create" description="One of: userprincipalname | upn | mail | dn">
userprincipalname      </MiqAeField>
      <MiqAeField name="domain" substitute="true" aetype="attribute" datatype="string" priority="8" message="create" collect="{:name =&gt; name, :base_dn =&gt; base_dn, :bind_dn =&gt; bind_dn, :bind_password =&gt; bind_password, :ldap_host =&gt; ldap_host, :ldap_port =&gt; ldap_port, :user_type =&gt; user_type}">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="ManageIQ">
      <MiqAeField name="name">
ManageIQ      </MiqAeField>
      <MiqAeField name="base_dn">
dc=manageiq,dc=com      </MiqAeField>
      <MiqAeField name="bind_dn">
manageiq\\evm_demo      </MiqAeField>
      <MiqAeField name="bind_password">
smartvm      </MiqAeField>
      <MiqAeField name="ldap_host">
192.168.252.19      </MiqAeField>
      <MiqAeField name="ldap_port">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="user_type">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="domain">
ManageIQ      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Naming" namespace="EVMApplications/Provisioning" description="VM Naming Profiles" display_name="VM Naming Profiles">
    <MiqAeMethod name="vmname" language="ruby" scope="instance" location="inline" display_name="default"><![CDATA[###################################
#
# EVM Automate Method: vmname
#
# Notes: This is the default vmnaming method
# 1. If VM Name was not chosen during dialog processing then use vm_prefix
#    from dialog else use model and [:environment] tag to generate name
# 2. Else use VM name chosen in dialog
# 3. Then add 3 digit suffix to vm_name
# 4. Added support for dynamic service naming
#
###################################
begin
  @method = 'vmname'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #$evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Root:<$evm.root> Attributes - #{k}: #{v}")}

  $evm.log("info","#{@method} - Detected vmdb_object_type:<#{$evm.root['vmdb_object_type']}>") if @debug

  prov = $evm.root['miq_provision_request'] || $evm.root['miq_provision'] || $evm.root['miq_provision_request_template']
  #$evm.log("info", "#{@method} - Inspecting prov:<#{prov.inspect}>") if @debug

  vm_name = prov.get_option(:vm_name).to_s.strip
  number_of_vms_being_provisioned = prov.get_option(:number_of_vms)
  diamethod = prov.get_option(:vm_prefix).to_s.strip


  # If no VM name was chosen during dialog
  if vm_name.blank? || vm_name == 'changeme'
    vm_prefix = nil
    vm_prefix ||= $evm.object['vm_prefix']
    $evm.log("info","#{@method} - vm_name from dialog:<#{vm_name.inspect}> vm_prefix from dialog:<#{diamethod.inspect}> vm_prefix from model:<#{vm_prefix.inspect}>") if @debug

    # Get Provisioning Tags for VM Name
    tags = prov.get_tags
    $evm.log("info","#{@method} - Provisioning Object Tags: #{tags.inspect}") if @debug
    
    # Set a Prefix for VM Naming
    if diamethod.blank?
      vm_name = vm_prefix
    else
      vm_name = diamethod
    end
    $evm.log("info","#{@method} - VM Naming Prefix: <#{vm_name}>") if @debug

    # Check :environment tag
    env = tags[:environment]

    # If environment tag is not nil
    unless env.nil?
      $evm.log("info","#{@method} - Environment Tag: <#{env}> detected") if @debug
      # Get the first 3 characters of the :environment tag
      env_first = env[0,3]

      vm_name =  "#{vm_name}#{env_first}"
      $evm.log("info","#{@method} - Updating VM Name: <#{vm_name}>") if @debug
    end
    derived_name = "#{vm_name}$n{3}"
  else
    if number_of_vms_being_provisioned == 1
      derived_name = "#{vm_name}"
    else
      derived_name = "#{vm_name}$n{3}"
    end
  end


  $evm.object['vmname'] = derived_name
  $evm.log("info", "#{@method} - VM Name: <#{derived_name}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="vm_prefix" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
cfme      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" datatype="string" priority="6" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="default">
      <MiqAeField name="vm_prefix">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
vmname      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Network" namespace="EVMApplications/Provisioning" display_name="vLANs in Virtual Center">
    <MiqAeSchema>
      <MiqAeField name="vlan" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="scope" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="vc_id" substitute="true" aetype="attribute" datatype="integer" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="dhcp_servers" substitute="true" aetype="relationship" priority="4" message="create" collect="dhcp_servers = [dhcp_server]">
/EVMApplications/Provisioning/DHCP_SERVER/*      </MiqAeField>
      <MiqAeField name="network" substitute="true" aetype="attribute" datatype="integer" priority="5" message="create" collect="{:vc_id =&gt; vc_id, :vlan =&gt; vlan, :scope =&gt; scope, :dhcp_servers =&gt; dhcp_servers}">
      </MiqAeField>
    </MiqAeSchema>
  </MiqAeClass>
  <MiqAeClass name="Host" namespace="EVMApplications/Provisioning/Profile" display_name="Host Provisioning Group">
    <MiqAeMethod name="get_deploy_dialog" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: get_deploy_dialog
#
# Notes: Dynamically choose dialog based on Category:environment chosen in pre-dialog
#
#
###################################
begin
  @method = 'get_deploy_dialog'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  # Set to true to dynamically choose dialog name based on environment tag
  run_env_dialog = false


  if run_env_dialog
    # Get incoming environment tags from pre-dialog
    dialog_input_vm_tags = $evm.root['dialog_input_vm_tags']

    # Use a regular expression to grab the environment from the incoming tag category
    # I.e. environment/dev for Category:environment Tag:dev
    regex = /(.*)(\/)(\w*)/i

    # If the regular express matches dynamically choose the next dialog
    if regex =~ dialog_input_vm_tags
      cat = $1
      tag = $3
      $evm.log("info","Category: #<{cat}> Tag: <#{tag}>")
      dialog_name = 'miq_provision_dialogs-deploy-#{tag}'
    end
    ## Set dialog name in the root object to be picked up by dialogs
    $evm.root['dialog_name'] = dialog_name
    $evm.log("info", "Launching <#{dialog_name}>")

  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="pre_dialog_name" substitute="true" aetype="attribute" datatype="string" priority="1" message="get_pre_dialog_name" collect="/dialog_name = pre_dialog_name">
      </MiqAeField>
      <MiqAeField name="get_dialog_name" substitute="true" aetype="method" datatype="string" priority="2" message="get_state_machine">
      </MiqAeField>
      <MiqAeField name="dialog_name" substitute="true" aetype="attribute" datatype="string" priority="3" message="get_dialog_name" collect="/dialog_name = dialog_name">
miq_host_provision_dialogs      </MiqAeField>
      <MiqAeField name="state_machine" substitute="true" aetype="attribute" datatype="string" priority="4" message="get_state_machine" collect="/state_machine = state_machine">
HostProvision      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing">
    </MiqAeInstance>
    <MiqAeInstance name="EvmGroup-super_administrator">
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VM" namespace="EVMApplications/Provisioning/Profile" description="VM Provisioning Group" display_name="VM Provisioning Group">
    <MiqAeMethod name="get_deploy_dialog" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: get_deploy_dialog
#
# Notes: Dynamically choose dialog based on Category:environment chosen in pre-dialog
#
#
###################################
begin
  @method = 'get_deploy_dialog'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  # Set to true to dynamically choose dialog name based on environment tag
  run_env_dialog = false

  if run_env_dialog
    # Get incoming environment tags from pre-dialog
    dialog_input_vm_tags = $evm.root['dialog_input_vm_tags']

    # Use a regular expression to grab the environment from the incoming tag category
    # I.e. environment/dev for Category:environment Tag:dev
    regex = /(.*)(\/)(\w*)/i

    # If the regular express matches dynamically choose the next dialog
    if regex =~ dialog_input_vm_tags
      cat = $1
      tag = $3
      $evm.log("info","#{@method} - Category: #<{cat}> Tag: <#{tag}>") if @debug
      dialog_name = 'miq_provision_dialogs-deploy-#{tag}'
    end
    ## Set dialog name in the root object to be picked up by dialogs
    $evm.root['dialog_name'] = dialog_name
    $evm.log("info", "#{@method} - Launching <#{dialog_name}>") if @debug

  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_dialog_name_prefix" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_dialog_name_prefix
#
# Notes: This is the default method to determine the dialog prefix name to use
#
###################################
begin
  @method = 'vm_dialog_name_prefix'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  platform  = $evm.root['platform']
  $evm.log("info", "#{@method} - Detected Platform:<#{platform}>")

  if platform.nil?
    source_id = $evm.root['dialog_input_src_vm_id']
    source    = $evm.vmdb('vm_or_template', source_id) unless source_id.nil?
    if source
      platform = source.model_suffix.downcase
    else
      platform = "vmware"
    end
  end

  dialog_name_prefix = "miq_provision_#{platform}_dialogs"
  dialog_name_prefix = "miq_provision_dialogs" if platform == "vmware"  # For Backward Compatibility

  $evm.object['dialog_name_prefix'] = dialog_name_prefix
  $evm.log("info", "#{@method} - Platform:<#{platform}> dialog_name_prefix:<#{dialog_name_prefix}>")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="placement" substitute="true" aetype="relationship" datatype="string" priority="1" message="get_placement" collect="/host = host; /storage = storage; /cluster = cluster">
/EVMApplications/Provisioning/Where/best_placement_with_scope#create      </MiqAeField>
      <MiqAeField name="where" substitute="true" aetype="relationship" datatype="string" priority="2" message="get_host_and_storage" collect="/host = host; /storage = storage">
/EVMApplications/Provisioning/Where/best_fit_with_scope#create      </MiqAeField>
      <MiqAeField name="where_availability_zone" substitute="true" aetype="relationship" datatype="string" priority="3" message="get_availability_zone" collect="/availability_zone = availability_zone">
/EVMApplications/Provisioning/Where/best_fit_availability_zone#create      </MiqAeField>
      <MiqAeField name="where_cluster" substitute="true" aetype="relationship" datatype="string" priority="3" message="get_cluster" collect="/cluster = cluster">
/EVMApplications/Provisioning/Where/best_fit_cluster#create      </MiqAeField>
      <MiqAeField name="domains" substitute="true" aetype="relationship" datatype="string" priority="4" message="get_domains" collect="/domains = domain">
/EVMApplications/Provisioning/Domain/*#create      </MiqAeField>
      <MiqAeField name="networks" substitute="true" aetype="relationship" datatype="string" priority="5" message="get_networks" collect="/networks = network">
/EVMApplications/Provisioning/Network/*#create      </MiqAeField>
      <MiqAeField name="vmname" substitute="true" aetype="relationship" datatype="string" priority="6" message="get_vmname" collect="/vmname = vmname">
/EVMApplications/Provisioning/Naming/Default#create      </MiqAeField>
      <MiqAeField name="pre_dialog_name" substitute="true" aetype="attribute" datatype="string" priority="7" message="get_pre_dialog_name" collect="/dialog_name = pre_dialog_name">
      </MiqAeField>
      <MiqAeField name="get_dialog_name" substitute="true" aetype="method" datatype="string" priority="8" message="get_state_machine">
      </MiqAeField>
      <MiqAeField name="vm_dialog_name_prefix" substitute="true" aetype="method" datatype="string" priority="9" message="get_dialog_name">
vm_dialog_name_prefix      </MiqAeField>
      <MiqAeField name="dialog_name" substitute="true" aetype="attribute" datatype="string" priority="10" message="get_dialog_name" collect="/dialog_name = dialog_name">
${#dialog_name_prefix}_${/#dialog_input_request_type}      </MiqAeField>
      <MiqAeField name="auto_approval_state_machine" substitute="true" aetype="attribute" datatype="string" priority="11" message="get_auto_approval_state_machine" collect="/state_machine = auto_approval_state_machine">
ProvisionRequestApproval      </MiqAeField>
      <MiqAeField name="quota_state_machine" substitute="true" aetype="attribute" datatype="string" priority="12" message="get_quota_state_machine" collect="/state_machine = quota_state_machine">
ProvisionRequestQuotaVerification      </MiqAeField>
      <MiqAeField name="state_machine" substitute="true" aetype="attribute" datatype="string" priority="13" message="get_state_machine" collect="/state_machine = state_machine">
VMProvision_${/#miq_provision.target_type}      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing">
      <MiqAeField name="placement">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="where">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="where_cluster">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="domains">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="networks">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vmname">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_dialog_name_prefix">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="auto_approval_state_machine">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="quota_state_machine">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="EvmGroup-super_administrator">
      <MiqAeField name="placement">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="where">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="where_cluster">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="domains">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="networks">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vmname">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vm_dialog_name_prefix">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="auto_approval_state_machine">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="quota_state_machine">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="EvmGroup-user_self_service">
      <MiqAeField name="where">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="domains">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="networks">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="vmname">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_dialog_name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="dialog_name">
${#dialog_name_prefix}-user      </MiqAeField>
      <MiqAeField name="auto_approval_state_machine">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="quota_state_machine">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="service" namespace="EVMApplications/Provisioning/Profile" display_name="Service Provision Group">
    <MiqAeSchema>
      <MiqAeField name="auto_approval_state_machine" substitute="true" aetype="attribute" datatype="string" priority="1" message="get_auto_approval_state_machine" collect="/state_machine = auto_approval_state_machine">
ServiceProvisionRequestApproval      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing">
      <MiqAeField name="auto_approval_state_machine">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Where" namespace="EVMApplications/Provisioning" description="Host and Storage to Provision To" display_name="VM Placement Profiles">
    <MiqAeMethod name="best_fit_cluster" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: best_fit_cluster
#
###################################
begin
  @method = 'best_fit_cluster'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = false

  #
  # Get variables
  #
  prov = $evm.root["miq_provision"]
  vm = prov.vm_template
  raise "VM not specified" if vm.nil?
  user = prov.miq_request.requester
  raise "User not specified" if user.nil?
  ems  = vm.ext_management_system
  raise "EMS not found for VM [#{vm.name}" if ems.nil?

  # Log all provisioning options
  #$evm.log("info", "Inspecting provisioning object: #{prov.options.inspect}") if @debug
  $evm.log("info", "Inline Method: <#{@method}> -- vm=[#{vm.name}]")

  cluster = vm.ems_cluster
  current_obj = $evm.current
  $evm.log("info", "Inline Method: #{@method} -- Selected Cluster: [#{cluster.nil? ? "nil" : cluster.name}]")

  # Set cluster
  current_obj["cluster"] = cluster unless cluster.nil?
  $evm.log("info", "Inline Method: <#{@method}> -- vm=[#{vm.name}] cluster=[#{cluster}]")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="best_fit_availability_zone" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# CFME Automate Method: best_fit_availability_zone
#
###################################
begin
  @method = 'best_fit_cluster'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Get variables
  prov     = $evm.root["miq_provision"]
  template = prov.vm_template
  raise "Template not specified" if template.nil?
  provider = template.ext_management_system
  raise "Provider not found for template [#{template.name}" if provider.nil?

  availability_zones = provider.availability_zones
  current_obj = $evm.current
  current_obj["availability_zone"] = availability_zones.first

  $evm.log("info", "Inline Method: <#{@method}> -- Template=[#{template.name}]   AvailabilityZone=[#{current_obj["availability_zone"]}]")

rescue => err
  # Rescue Errors
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT

else
  # Exit method OK
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK
end]]>    </MiqAeMethod>
    <MiqAeMethod name="best_fit_with_scope" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: best_fit_with_scope
#
# Notes: This method is used to find all hosts, datastores that have the tag category
# prov_scope = 'all' &&|| prov_scope = <group-name>
#
###################################
begin
  @method = 'best_fit_with_scope'
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get variables
  #
  prov = $evm.root["miq_provision"]
  vm = prov.vm_template
  raise "#{@method} - VM not specified" if vm.nil?
  user = prov.miq_request.requester
  raise "#{@method} - User not specified" if user.nil?
  ems  = vm.ext_management_system
  raise "#{@method} - EMS not found for VM:<#{vm.name}>" if ems.nil?

  # Log all provisioning options and space required
  #$evm.log("info", "Inspecting provisioning object: #{prov.options.inspect}") if @debug
  #$evm.log("info", "VM=<#{vm.name}>, Space Required=<#{vm.provisioned_storage}>")

  attrs = $evm.object.attributes
  tags  = {}
  #############################
  # Get Tags that are in scope
  # Default is to look for Hosts and Datastores tagged with prov_scope = All or match to Group
  #############################
  tags["prov_scope"] = ["all",user.normalized_ldap_group]

  $evm.log("info", "#{@method} - VM=<#{vm.name}>, Space Required=<#{vm.provisioned_storage}>, group=<#{user.normalized_ldap_group}>") if @debug

  #############################
  # STORAGE LIMITATIONS
  #############################
  STORAGE_MAX_VMS      = 0
  storage_max_vms      = $evm.object['storage_max_vms']
  storage_max_vms      = storage_max_vms.strip.to_i if storage_max_vms.kind_of?(String) && !storage_max_vms.strip.empty?
  storage_max_vms      = STORAGE_MAX_VMS unless storage_max_vms.kind_of?(Numeric)
  STORAGE_MAX_PCT_USED = 100
  storage_max_pct_used = $evm.object['storage_max_pct_used']
  storage_max_pct_used = storage_max_pct_used.strip.to_i if storage_max_pct_used.kind_of?(String) && !storage_max_pct_used.strip.empty?
  storage_max_pct_used = STORAGE_MAX_PCT_USED unless storage_max_pct_used.kind_of?(Numeric)
  $evm.log("info","#{@method} - storage_max_vms:<#{storage_max_vms}> storage_max_pct_used:<#{storage_max_pct_used}>") if @debug

  #############################
  # Set host sort order here
  # options: :active_provioning_memory, :active_provioning_cpu, :current_memory_usage,
  #          :current_memory_headroom, :current_cpu_usage, :random
  #############################
  HOST_SORT_ORDER = [:active_provioning_memory, :current_memory_headroom, :random]

  #############################
  # Sort hosts
  #############################
  active_prov_data = prov.check_quota(:active_provisions)
  sort_data = []
  ems.hosts.each do |h|
    sort_data << sd = [[], h.name, h]
    host_id = h.attributes['id'].to_i
    HOST_SORT_ORDER.each do |type|
      sd[0] << case type
        # Multiply values by (-1) to cause larger values to sort first
      when :active_provioning_memory
        active_prov_data[:active][:memory_by_host_id][host_id]
      when :active_provioning_cpu
        active_prov_data[:active][:cpu_by_host_id][host_id]
      when :current_memory_headroom
        h.current_memory_headroom * -1
      when :current_memory_usage
        h.current_memory_usage
      when :current_cpu_usage
        h.current_cpu_usage
      when :random
        rand(1000)
      else 0
      end
      ##### End sort options
    end
  end

  sort_data.sort! {|a,b| a[0] <=> b[0]}
  hosts = sort_data.collect {|sd| sd.pop}
  $evm.log("info", "#{@method} - Sorted host Order:<#{HOST_SORT_ORDER.inspect}> Results:<#{sort_data.inspect}>") if @debug

  #############################
  # Set storage sort order here
  # options: :active_provisioning_vms, :free_space, :free_space_percentage, :random
  #############################
  STORAGE_SORT_ORDER = [:active_provisioning_vms, :random]

  host = storage = nil
  min_registered_vms = nil
  hosts.each do |h|
    next unless h.power_state == "on"

    #############################
    # Only consider hosts that have the required tags
    #############################
    next unless tags.all? do |key, value|
      if value.kind_of?(Array)
        value.any? { |v| h.tagged_with?(key, v) }
      else
        h.tagged_with?(key, value)
      end
    end

    nvms = h.vms.length

    #############################
    # Only consider storages that have the tag category group=all
    #############################
    storages = h.storages.find_all do |s|
      tags.all? do |key, value|
        if value.kind_of?(Array)
          value.any? { |v| s.tagged_with?(key, v) }
        else
          s.tagged_with?(key, value)
        end
      end
    end

    $evm.log("info", "#{@method} - Evaluating storages:<#{storages.collect {|s| s.name}.join(", ")}>") if @debug

    #############################
    # Filter out storages that do not have enough free space for the VM
    #############################
    active_prov_data = prov.check_quota(:active_provisions)
    storages = storages.find_all { |s|
      storage_id = s.attributes['id'].to_i
      actively_provisioned_space = active_prov_data[:active][:storage_by_id][storage_id]
      if s.free_space > vm.provisioned_storage + actively_provisioned_space
        #        $evm.log("info", "Active Provision Data inspect: [#{active_prov_data.inspect}]")
        #        $evm.log("info", "Active provision space requirement: [#{actively_provisioned_space}]")
        #        $evm.log("info", "Valid Datastore: [#{s.name}], enough free space for VM -- Available: [#{s.free_space}], Needs: [#{vm.provisioned_storage}]")
        true
      else
        $evm.log("info", "#{@method} - Skipping Datastore:<#{s.name}>, not enough free space for VM:<#{vm.name}>. Available:<#{s.free_space}>, Needs:<#{vm.provisioned_storage}>") if @debug
        false
      end
    }

    #############################
    # Filter out storages number of VMs is greater than the max number of VMs allowed per Datastore
    #############################
    storages = storages.find_all { |s|
      storage_id = s.attributes['id'].to_i
      active_num_vms_for_storage = active_prov_data[:active][:vms_by_storage_id][storage_id].length
      if (storage_max_vms == 0) || ((s.vms.size + active_num_vms_for_storage) < storage_max_vms)
        true
      else
        $evm.log("info", "#{@method} - Skipping Datastore:<#{s.name}>, max number of VMs:<#{s.vms.size + active_num_vms_for_storage}> exceeded") if @debug
        false
      end
    }

    #############################
    # Filter out storages where percent used will be greater than the max % allowed per Datastore
    #############################
    storages = storages.find_all { |s|
      storage_id = s.attributes['id'].to_i
      active_pct_of_storage  = ((active_prov_data[:active][:storage_by_id][storage_id]) / s.total_space.to_f) * 100
      request_pct_of_storage = (vm.provisioned_storage / s.total_space.to_f) * 100

      #      $evm.log("info", "Active Provision Data inspect: [#{s.name}]:[#{storage_id}] -- [#{active_prov_data.inspect}]")
      #      $evm.log("info", "Datastore Percent: [#{s.name}]:[#{storage_id}] -- Storage:[#{s.v_used_space_percent_of_total}]  Active:[#{active_pct_of_storage}]  Request:[#{request_pct_of_storage}]")

      if (storage_max_pct_used == 100) || ((s.v_used_space_percent_of_total + active_pct_of_storage + request_pct_of_storage) < storage_max_pct_used)
        #        $evm.log("info", "Current PCT of active provision: [#{active_pct_of_storage}]")
        #        $evm.log("info", "Valid Datastore: [#{s.name}], enough free space for VM -- Total Datastore Size: [#{s.total_space}], Available: [#{s.free_space}], Needs: [#{vm.provisioned_storage}]")
        true
      else
        $evm.log("info", "#{@method} - Skipping Datastore:<#{s.name}> percent of used space #{s.v_used_space_percent_of_total + active_pct_of_storage + request_pct_of_storage} exceeded") if @debug
        #        $evm.log("info", "Total Datastore Size: [#{s.total_space}], Total Percentage Required: ([#{s.v_used_space_percent_of_total}] + [#{active_pct_of_storage}])")
        false
      end
    }


    if min_registered_vms.nil? || nvms < min_registered_vms
      #############################
      # Sort storage to determine target datastore
      #############################
      sort_data = []
      storages.each_with_index do |s, idx|
        sort_data << sd = [[], s.name, idx]
        storage_id = s.attributes['id'].to_i
        STORAGE_SORT_ORDER.each do |type|
          sd[0] << case type
          when :free_space
            # Multiply values by (-1) to cause larger values to sort first
            (s.free_space - active_prov_data[:active][:storage_by_id][storage_id]) * -1
          when :free_space_percentage
            active_pct_of_storage  = ((active_prov_data[:active][:storage_by_id][storage_id]) / s.total_space.to_f) * 100
            s.v_used_space_percent_of_total + active_pct_of_storage
          when :active_provioning_vms
            active_prov_data[:active][:vms_by_storage_id][storage_id].length
          when :random
            rand(1000)
          else 0
          end
          ##### End sort options
        end
      end

      sort_data.sort! {|a,b| a[0] <=> b[0]}
      $evm.log("info", "#{@method} - Sorted storage Order:<#{STORAGE_SORT_ORDER.inspect}>  Results:<#{sort_data.inspect}>") if @debug
      selected_storage = sort_data.first
      unless selected_storage.nil?
        selected_idx = selected_storage.last
        storage = storages[selected_idx]
        host    = h
      end

      #$evm.log("info", "Found Host:<#{h.name}> with Tags:<#{h.tags.inspect}>") if @debug

      # Stop checking if we have found both host and storage
      break if host && storage
    end

  end # END - hosts.each

  obj = $evm.object
  $evm.log("info", "#{@method} - Selected Host:<#{host.nil? ? "nil" : host.name}>") if @debug
  obj["host"] = host unless host.nil?

  $evm.log("info", "#{@method} - Selected Datastore:<#{storage.nil? ? "nil" : storage.name}>") if @debug
  obj["storage"] = storage unless storage.nil?


  # Set host and storage
  $evm.log("info", "#{@method} - vm=<#{vm.name}> host=<#{host}> storage=<#{storage}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="best_fit_with_tags" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: best_fit_with_tags
#
# Notes: This method is used to find all hosts, datastores that match the required tag
#
###################################
begin
  @method = 'best_fit_with_tags'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get variables
  #
  prov = $evm.root["miq_provision"]
  vm = prov.vm_template
  raise "VM not specified" if vm.nil?
  ems  = vm.ext_management_system
  raise "EMS not found for VM [#{vm.name}" if ems.nil?
  tags = prov.get_tags

  # Log all provisioning options and space required
  $evm.log("info", "options: #{prov.options.inspect}") if @debug
  $evm.log("info", "Inline Method: <#{@method}> -- vm=[#{vm.name}], space required=[#{vm.provisioned_storage}]")

  # STORAGE LIMITATIONS
  STORAGE_MAX_VMS      = 0
  storage_max_vms      = $evm.object['storage_max_vms']
  storage_max_vms      = storage_max_vms.strip.to_i if storage_max_vms.kind_of?(String) && !storage_max_vms.strip.empty?
  storage_max_vms      = STORAGE_MAX_VMS unless storage_max_vms.kind_of?(Numeric)

  STORAGE_MAX_PCT_USED = 100
  storage_max_pct_used = $evm.object['storage_max_pct_used']
  storage_max_pct_used = storage_max_pct_used.strip.to_i if storage_max_pct_used.kind_of?(String) && !storage_max_pct_used.strip.empty?
  storage_max_pct_used = STORAGE_MAX_PCT_USED unless storage_max_pct_used.kind_of?(Numeric)

  host = storage = nil
  min_registered_vms = nil
  prov.eligible_hosts.each { |h|
    next unless h.power_state == "on"
    
    # Only consider hosts that have the required tags
    next unless tags.all? do |key, value|
      if value.kind_of?(Array)
        value.any? { |v| h.tagged_with?(key, v) }
      else
        h.tagged_with?(key, value)
      end
    end

    nvms = h.vms.length

    # Only consider storages that have the required tags
    storages = h.storages.find_all do |s|
      tags.all? do |key, value|
        if value.kind_of?(Array)
          value.any? { |v| s.tagged_with?(key, v) }
        else
          s.tagged_with?(key, value)
        end
      end
    end

    # Filter out storages that do not have enough free space for the Vm
    storages = storages.find_all { |s|
      if s.free_space > vm.provisioned_storage
        true
      else
        $evm.log("info", "Skipping Datastore: [#{s.name}], not enough free space for VM. Available: [#{s.free_space}], Needs: [#{vm.provisioned_storage}]")
        false
      end
    }
    # Filter out storages number of VMs is greater than the max number of VMs
    storages = storages.find_all { |s|
      if (storage_max_vms == 0) || (s.vms.size < storage_max_vms)
        true
      else
        $evm.log("info", "Skipping Datastore: [#{s.name}], max number of VMs exceeded")
        false
      end
    }
    # Filter out storages where percent used is greater than the max.
    storages = storages.find_all { |s|
      if (storage_max_pct_used == 100) || (s.v_used_space_percent_of_total < storage_max_pct_used)
        true
      else
        $evm.log("info", "Skipping Datastore: [#{s.name}], percent of used space is exceeded")
        false
      end
    }
    # if minimum registered vms is nil or number of vms on a host is greater than nil
    if min_registered_vms.nil? || nvms < min_registered_vms
      s = storages.sort { |a,b| a.free_space <=> b.free_space }.last
      unless s.nil?
        host    = h
        storage = s
        min_registered_vms = nvms
      end
    end
  }

  # Set host and storage
  obj = $evm.object
  obj["host"]    = host    unless host.nil?
  obj["storage"] = storage unless storage.nil?

  $evm.log("info", "Inline Method: <#{@method}> -- vm=[#{vm.name}] host=[#{host}] storage=[#{storage}]")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="best_placement_with_scope" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: best_placement_with_scope
#
# Notes: This method is used to find the incoming templates cluster as well as hosts and storage that have the tag category
# prov_scope = 'all' && prov_scope = <group-name>
#
# Modified for RHEVM
#
###################################
begin
  @method = 'best_placement_with_scope'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get variables
  #
  prov = $evm.root["miq_provision"]
  vm = prov.vm_template
  raise "#{@method} - VM not specified" if vm.nil?
  user = prov.miq_request.requester
  raise "#{@method} - User not specified" if user.nil?
  ems  = vm.ext_management_system
  raise "#{@method} - EMS not found for VM:<#{vm.name}>" if ems.nil?
  cluster = vm.ems_cluster
  raise "#{@method} - Cluster not found for VM:<#{vm.name}>" if cluster.nil?
  $evm.log("info", "#{@method} - Selected Cluster: [#{cluster.nil? ? "nil" : cluster.name}]")

  # Log all provisioning options and space required
  #$evm.log("info", "Inspecting provisioning object: #{prov.options.inspect}") if @debug
  #$evm.log("info", "VM=<#{vm.name}>, Space Required=<#{vm.provisioned_storage}>")

  attrs = $evm.object.attributes
  tags  = {}
  #############################
  # Get Tags that are in scope
  # Default is to look for Hosts and Datastores tagged with prov_scope = All or match to Group
  #############################
  tags["prov_scope"] = ["all",user.normalized_ldap_group]

  $evm.log("info", "#{@method} - VM=<#{vm.name}>, Space Required=<#{vm.provisioned_storage}>, group=<#{user.normalized_ldap_group}>")

  #############################
  # STORAGE LIMITATIONS
  #############################
  STORAGE_MAX_VMS      = 0
  storage_max_vms      = $evm.object['storage_max_vms']
  storage_max_vms      = storage_max_vms.strip.to_i if storage_max_vms.kind_of?(String) && !storage_max_vms.strip.empty?
  storage_max_vms      = STORAGE_MAX_VMS unless storage_max_vms.kind_of?(Numeric)
  STORAGE_MAX_PCT_USED = 100
  storage_max_pct_used = $evm.object['storage_max_pct_used']
  storage_max_pct_used = storage_max_pct_used.strip.to_i if storage_max_pct_used.kind_of?(String) && !storage_max_pct_used.strip.empty?
  storage_max_pct_used = STORAGE_MAX_PCT_USED unless storage_max_pct_used.kind_of?(Numeric)
  $evm.log("info","#{@method} - storage_max_vms:<#{storage_max_vms}> storage_max_pct_used:<#{storage_max_pct_used}>")

  #############################
  # Set host sort order here
  # options: :active_provisioning_memory, :active_provisioning_cpu, :current_memory_usage,
  #          :current_memory_headroom, :current_cpu_usage, :random
  #############################
  HOST_SORT_ORDER = [:active_provisioning_memory, :current_memory_headroom, :random]

  #############################
  # Sort hosts
  #############################
  active_prov_data = prov.check_quota(:active_provisions)
  sort_data = []
  
  # Only consider hosts confined to the cluster where the template resides
  cluster.hosts.each do |h|
    sort_data << sd = [[], h.name, h]
    host_id = h.attributes['id'].to_i
    HOST_SORT_ORDER.each do |type|
      sd[0] << case type
      # Multiply values by (-1) to cause larger values to sort first
      when :active_provisioning_memory
        active_prov_data[:active][:memory_by_host_id][host_id]
      when :active_provisioning_cpu
        active_prov_data[:active][:cpu_by_host_id][host_id]
      when :current_memory_headroom
        h.current_memory_headroom * -1
      when :current_memory_usage
        h.current_memory_usage
      when :current_cpu_usage
        h.current_cpu_usage
      when :random
        rand(1000)
      else 0
      end
      ##### End sort options
    end
  end

  sort_data.sort! {|a,b| a[0] <=> b[0]}
  hosts = sort_data.collect {|sd| sd.pop}
  $evm.log("info", "#{@method} - Sorted host Order:<#{HOST_SORT_ORDER.inspect}> Results:<#{sort_data.inspect}>")

  #############################
  # Set storage sort order here
  # options: :active_provisioning_vms, :free_space, :free_space_percentage, :random
  #############################
  STORAGE_SORT_ORDER = [:free_space, :active_provisioning_vms, :random]

  host = storage = nil
  min_registered_vms = nil
  hosts.each do |h|
    next unless h.power_state == "on"

    #############################
    # Only consider hosts that have the required tags
    #############################
    next unless tags.all? do |key, value|
      if value.kind_of?(Array)
        value.any? { |v| h.tagged_with?(key, v) }
      else
        h.tagged_with?(key, value)
      end
    end

    nvms = h.vms.length

    #############################
    # Only consider storages that have the tag category group=all
    #############################
    storages = h.storages.find_all do |s|
      tags.all? do |key, value|
        if value.kind_of?(Array)
          value.any? { |v| s.tagged_with?(key, v) }
        else
          s.tagged_with?(key, value)
        end
      end
    end

    $evm.log("info", "#{@method} - Evaluating storages:<#{storages.collect {|s| s.name}.join(", ")}>")

    #############################
    # Filter out storages that do not have enough free space for the VM
    #############################
    active_prov_data = prov.check_quota(:active_provisions)
    storages = storages.find_all { |s|
      storage_id = s.attributes['id'].to_i
      actively_provisioned_space = active_prov_data[:active][:storage_by_id][storage_id]
      if s.free_space > vm.provisioned_storage + actively_provisioned_space
        #        $evm.log("info", "Active Provision Data inspect: [#{active_prov_data.inspect}]")
        #        $evm.log("info", "Active provision space requirement: [#{actively_provisioned_space}]")
        #        $evm.log("info", "Valid Datastore: [#{s.name}], enough free space for VM -- Available: [#{s.free_space}], Needs: [#{vm.provisioned_storage}]")
        true
      else
        $evm.log("info", "#{@method} - Skipping Datastore:<#{s.name}>, not enough free space for VM:<#{vm.name}>. Available:<#{s.free_space}>, Needs:<#{vm.provisioned_storage}>")
        false
      end
    }

    #############################
    # Filter out storages number of VMs is greater than the max number of VMs allowed per Datastore
    #############################
    storages = storages.find_all { |s|
      storage_id = s.attributes['id'].to_i
      active_num_vms_for_storage = active_prov_data[:active][:vms_by_storage_id][storage_id].length
      if (storage_max_vms == 0) || ((s.vms.size + active_num_vms_for_storage) < storage_max_vms)
        true
      else
        $evm.log("info", "#{@method} - Skipping Datastore:<#{s.name}>, max number of VMs:<#{s.vms.size + active_num_vms_for_storage}> exceeded")
        false
      end
    }

    #############################
    # Filter out storages where percent used will be greater than the max % allowed per Datastore
    #############################
    storages = storages.find_all { |s|
      storage_id = s.attributes['id'].to_i
      active_pct_of_storage  = ((active_prov_data[:active][:storage_by_id][storage_id]) / s.total_space.to_f) * 100
      request_pct_of_storage = (vm.provisioned_storage / s.total_space.to_f) * 100

      #      $evm.log("info", "Active Provision Data inspect: [#{s.name}]:[#{storage_id}] -- [#{active_prov_data.inspect}]")
      #      $evm.log("info", "Datastore Percent: [#{s.name}]:[#{storage_id}] -- Storage:[#{s.v_used_space_percent_of_total}]  Active:[#{active_pct_of_storage}]  Request:[#{request_pct_of_storage}]")

      if (storage_max_pct_used == 100) || ((s.v_used_space_percent_of_total + active_pct_of_storage + request_pct_of_storage) < storage_max_pct_used)
        #        $evm.log("info", "Current PCT of active provision: [#{active_pct_of_storage}]")
        #        $evm.log("info", "Valid Datastore: [#{s.name}], enough free space for VM -- Total Datastore Size: [#{s.total_space}], Available: [#{s.free_space}], Needs: [#{vm.provisioned_storage}]")
        true
      else
        $evm.log("info", "#{@method} - Skipping Datastore:<#{s.name}> percent of used space #{s.v_used_space_percent_of_total + active_pct_of_storage + request_pct_of_storage} exceeded")
        #        $evm.log("info", "Total Datastore Size: [#{s.total_space}], Total Percentage Required: ([#{s.v_used_space_percent_of_total}] + [#{active_pct_of_storage}])")
        false
      end
    }


    if min_registered_vms.nil? || nvms < min_registered_vms
      #############################
      # Sort storage to determine target datastore
      #############################
      sort_data = []
      storages.each_with_index do |s, idx|
        sort_data << sd = [[], s.name, idx]
        storage_id = s.attributes['id'].to_i
        STORAGE_SORT_ORDER.each do |type|
          sd[0] << case type
          when :free_space
            # Multiply values by (-1) to cause larger values to sort first
            (s.free_space - active_prov_data[:active][:storage_by_id][storage_id]) * -1
          when :free_space_percentage
            active_pct_of_storage  = ((active_prov_data[:active][:storage_by_id][storage_id]) / s.total_space.to_f) * 100
            s.v_used_space_percent_of_total + active_pct_of_storage
          when :active_provioning_vms
            active_prov_data[:active][:vms_by_storage_id][storage_id].length
          when :random
            rand(1000)
          else 0
          end
          ##### End sort options
        end
      end

      sort_data.sort! {|a,b| a[0] <=> b[0]}
      $evm.log("info", "#{@method} - Sorted storage Order:<#{STORAGE_SORT_ORDER.inspect}>  Results:<#{sort_data.inspect}>")
      selected_storage = sort_data.first
      unless selected_storage.nil?
        selected_idx = selected_storage.last
        storage = storages[selected_idx]
        host    = h
      end

      #$evm.log("info", "Found Host:<#{h.name}> with Tags:<#{h.tags.inspect}>") if @debug

      # Stop checking if we have found both host and storage
      break if host && storage
    end

  end # END - hosts.each

  # Set Host
  obj = $evm.object
  $evm.log("info", "#{@method} - Selected Host:<#{host.nil? ? "nil" : host.name}>")
  obj["host"] = host unless host.nil?

  # Set Storage
  $evm.log("info", "#{@method} - Selected Datastore:<#{storage.nil? ? "nil" : storage.name}>")
  obj["storage"] = storage unless storage.nil?

  # Set cluster
  obj["cluster"] = cluster unless cluster.nil?
  $evm.log("info", "#{@method} - Selected Cluster:<#{cluster.nil? ? "nil" : cluster.name}>")

  # Set host and storage
  $evm.log("info", "#{@method} - vm=<#{vm.name}> host=<#{host.name}> storage=<#{storage.name}> cluster=<#{cluster.name}>")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="least_utilized" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: least_utilized
#
# Notes: This method is used to find all hosts, datastores that are the least utilized
#
###################################
begin
  @method = 'least_utilized'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  # Dump incoming Arguments
  $evm.log("info", "Args:    #{MIQ_ARGS.inspect}") if @debug

  #
  # Get variables
  #
  prov = $evm.root["miq_provision"]
  vm = prov.vm_template
  raise "VM not specified" if vm.nil?
  ems  = vm.ext_management_system
  raise "EMS not found for VM [#{vm.name}" if vm.nil?

  # Log all provisioning options and space required
  $evm.log("info", "options: #{prov.options.inspect}") if @debug
  $evm.log("info", "Inline Method: <#{@method}> -- vm=[#{vm.name}], space required=[#{vm.provisioned_storage}]")

  host = storage = nil
  min_registered_vms = nil
  prov.eligible_hosts.each { |h|
    next unless h.power_state == "on"
    nvms = h.vms.length
    if min_registered_vms.nil? || nvms < min_registered_vms
      s = h.storages.sort { |a,b| a.free_space <=> b.free_space }.last
      unless s.nil?
        host    = h
        storage = s
        min_registered_vms = nvms
      end
    end
  }

  # Set host and storage
  obj = $evm.object
  obj["host"]    = host    unless host.nil?
  obj["storage"] = storage unless storage.nil?

  $evm.log("info", "Inline Method: <#{@method}> -- vm=[#{vm.name}] host=[#{host}] storage=[#{storage}]")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="vm" substitute="true" aetype="attribute" datatype="vm" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="host" substitute="true" aetype="attribute" datatype="host" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="storage" substitute="true" aetype="attribute" datatype="storage" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="storage_max_vms" substitute="true" aetype="attribute" datatype="integer" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used" substitute="true" aetype="attribute" datatype="integer" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" priority="18" message="create" collect="host = host; storage = storage">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" priority="20" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" priority="21" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" priority="22" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" priority="23" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" priority="24" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="25" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="best_fit" display_name="best_fit_default">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
/factory/method/host_and_storage_least_utilized      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="best_fit_availability_zone">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
best_fit_availability_zone      </MiqAeField>
      <MiqAeField name="rel6" collect="availability_zone = availability_zone">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="best_fit_cluster">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
best_fit_cluster      </MiqAeField>
      <MiqAeField name="rel6" collect="cluster = cluster">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="best_fit_least_utilized">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
least_utilized      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="best_fit_with_scope">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
best_fit_with_scope      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="best_fit_with_tags">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
best_fit_with_tags      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="best_placement_with_scope">
      <MiqAeField name="vm">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="host">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_vms">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="storage_max_pct_used">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
best_placement_with_scope      </MiqAeField>
      <MiqAeField name="rel6" collect="cluster = cluster; host = host; storage = storage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Host" namespace="Factory" display_name="Host">
    <MiqAeMethod name="CustomizeRequest" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: CustomizeRequest
#
# Notes: This method is used to Customize the provisioning request
#
###################################
begin
  @method = 'CustomizeRequest'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Initialize variables
  #
  prov   = $evm.root['miq_host_provision']
  $evm.log("info","Inspecting the provisioning object: <#{prov.inspect}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PostProvision_Host" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PostProvision_Host
#
# Notes: This method is used to perform post provisioning tasks
#
###################################
begin
  @method = 'PostProvision_Host'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  #
  # Initialize variables
  #
  prov = $evm.root['miq_host_provision']

  ks_cfg = prov.get_option_last(:customization_template_id)

  # ESX Processing only
  if ks_cfg.include?('ESXi')
    # Enabling VMOTION traffic on vm Kernel
    prov.host.enable_vmotion
    $evm.log("info","Host: <#{prov.host.name}> Enabling VMOTION on vm Kernel")

    # Exit Maintenance Mode
    prov.host.exit_maintenance_mode
    $evm.log("info","Host: <#{prov.host.name}> Exiting maintenance-mode")
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PreProvision_Host" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PreProvision
#
# Notes: This method is used to Customize the provisioning request
#
###################################
begin
  @method = 'PreProvision'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get variables
  #
  prov   = $evm.root['miq_host_provision']

  # prov.set_option(:gateway,'192.168.252.1')
  # prov.set_option(:ip_addr,'192.168.252.116')
  # prov.set_option(:dns_servers,'192.168.252.19')
  # prov.set_option(:subnet_mask,'255.255.254.0')
  # prov.set_option(:dns_suffixes,'manageiq.com')

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Provision" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: provision
#
# Notes: This method launches the provisioning job
#
###################################
begin
  @method = 'provision'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")


  $evm.root["miq_host_provision"].execute


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="check_provisioned" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: check_provisioned
#
# Notes: This method checks to see if the vm has been provisioned
#
###################################
begin
  @method = 'check_provisioned'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Get provision object
  prov = $evm.root['miq_provision'] || $evm.root['miq_host_provision']

  # Get current provisioning status
  result = prov.status

  $evm.log('info', "ProvisionCheck returned <#{result}>")

  case result
  when 'error'
    $evm.root['ae_result'] = 'error'
    reason = prov.message
    reason = reason[7..-1] if reason[0..6] == 'Error: '
    $evm.root['ae_reason'] = reason
  when 'retry'
    $evm.root['ae_result']         = 'retry'
    $evm.root['ae_retry_interval'] = '1.minute'
  when 'ok'
    # Bump State
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="CheckProvisioned">
      <MiqAeField name="execute">
check_provisioned      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CustomizeRequest">
      <MiqAeField name="execute">
CustomizeRequest      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PostProvision_Host">
      <MiqAeField name="execute">
PostProvision_Host      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PreProvision_Host">
      <MiqAeField name="execute">
PreProvision_Host      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Provision">
      <MiqAeField name="execute">
Provision      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Method" namespace="Factory" description="Factory Methods" display_name="Methods">
    <MiqAeMethod name="host_and_storage_least_utilized" language="ruby" scope="instance" location="builtin"><![CDATA[]]>    </MiqAeMethod>
    <MiqAeMethod name="log_vm_event" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: log_vm_event
#
# Notes: This method is used to log_vm_events
#
###################################
begin
  @method = 'log_vm_event'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  obj = $evm.object("process")
  $evm.log("info", "VM Discovery for #{obj['name']} State: #{obj['vm_state']} Family: #{obj['vm_os_family']}")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_allowed" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_allowed
#
# Notes: This method will parse a text file for vm names
#
###################################
begin
  @method = 'vm_allowed'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  obj = $evm.object("process")
  name = obj['vm_name']
  $evm.log("info", "VM Name: #{name}")

  exit MIQ_STOP unless ["vm1", "vm2", "vm3"].include?(name.downcase)

  fname = "/var/www/miq/vmdb/authorizedvms.txt"
  raise "File '#{fname}' does not exist" unless File.exist?(fname)

  allowed_names = File.read(fname).split("\n").collect { |n| n.downcase }
  $evm.log("info", "VM Allowed for #{obj['name']} Name: #{name} Allowed: #{allowed_names.inspect}") if @debug

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  #
  # No VM Found, exit
  #
  if vm.nil?
    $evm.log("error", "Could not find VM in current or root objects")
    exit MIQ_ABORT
  end

  unless allowed_names.include?(name.downcase)
    $evm.log("info", "Unregistering VM: [#{name}]")
    vm.unregister

    # Tag the VM
    tag = "function/VM_REJECTED_BY_POLICY"
    vm.tag_assign(tag)
  else
    $evm.log("info", "Analyzing VM: [#{name}]")

    parent = $evm.object("..")
    profiles = parent.attributes["profiles"]
    $evm.log("info", "scan profiles: #{profiles.inspect}") if @debug

    job = vm.scan(profiles)
    $evm.log("info", "Job Attributes")
    job.attributes.sort.each { |k, v| next if k == 'process'; $evm.log("info", "\t#{k}: #{v}")}
  end


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_allowed2" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_allowed2
#
# Notes: This method will parse .csv file for vmnames
#
###################################
begin
  @method = 'vm_allowed2'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")


  # Turn of verbose logging
  @debug = true

  def find_vm_in_csv(contents, name)
    contents.each { |line|
      CSV::Reader.parse(line) { |row|
        return line if row[0].downcase == name.downcase
      }
    }
    return nil
  end

  def vm_allowed?(contents, name)
    find_vm_in_csv(contents, name).nil? ? false : true
  end

  def vm_tags(contents, name)
    line = find_vm_in_csv(contents, name)
    tags = []

    CSV::Reader.parse(line) { |row|
      row.shift   # remove the name

      loop do
        tag = row.shift
        break if tag.nil?
        tags << tag
      end

    } unless line.nil?

    return tags
  end


  obj = $evm.object("process")
  name = obj['vm_name']
  $evm.log("info", "VM Name: #{name}")

  exit MIQ_STOP unless ["vm1", "vm2", "vm3"].include?(name.downcase)

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  #
  # No VM Found, exit
  #
  if vm.nil?
    $evm.log("error", "Could not find VM in current or root objects")
    exit MIQ_ABORT
  end

  require 'csv'
  fname = "/var/www/miq/vmdb/authorizedvms.csv"
  raise "File '#{fname}' does not exist" unless File.exist?(fname)

  csv = File.read(fname).split("\n")
  $evm.log("info", "VM Allowed for #{obj['name']} Name: #{name} CSV Contents: #{csv.inspect}") if @debug

  unless vm_allowed?(csv, name)
    $evm.log("info", "Unregistering VM: [#{name}]")
    vm.unregister

    # Tag the VM
    tag = "function/VM_REJECTED_BY_POLICY"
    vm.tag_assign(tag)
  else
    $evm.log("info", "Analyzing VM: [#{name}]")

    vm_tags(csv, name).each { |tag|
      $evm.log("info", "Tagging VM with [#{tag}]")
      vm.tag_assign(tag)
    }

    parent = $evm.object("..")
    profiles = parent.attributes["profiles"]
    $evm.log("info", "scan profiles: #{profiles.inspect}") if @debug

    job = vm.scan(profiles)
    $evm.log("info", "Job Attributes")
    job.attributes.sort.each { |k, v| next if k == 'process'; $evm.log("info", "\t#{k}: #{v}")}
  end


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_email_remedy" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_email_remedy
#
# Notes: This method is used to send an email to remedy
#
###################################
begin
  @method = 'vm_email_remedy'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  obj   = $evm.object

  $evm.log("info", "Listing Object Attributes:")
  obj.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug
  $evm.log("info", "===========================================")

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  #
  # No VM Found, exit
  #
  raise "VM not found" if vm.nil?


  process = $evm.object("process")
  policy_id = process.attributes["policy_id"].to_i
  policy_name = process.attributes["policy_name"]
  policy_description = process.attributes["policy_description"]
  $evm.log("info", "Policy ID:          #{policy_id}")
  $evm.log("info", "Policy Name:        #{policy_name}")
  $evm.log("info", "Policy Description: #{policy_description}")
  #policy    = $evm.vmdb('policy', policy_id)

  subject = "Remedy Ticket - Policy Violation"
  body =  "Schema: HD Incident"
  body << "<br/>Server: DemoRemedy"
  body << "<br/>Login: EVM_Demo"
  body << "<br/>Password: <mypassword>"
  body << "<br/>Action: Submit"
  body << "<br/>!Submitter!: EVM"
  body << "<br/>!Short Description!: VM policy violation VM Name: #{vm.name} Policy: #{policy_description}"
  body << "<br>"
  body << "<br><br>To view and manage your virtual machine go to <a href='https://192.168.254.147/vm/show/#{vm['id']}'>https://192.168.254.147/vm/show/#{vm['id']}</a>"

  obj['to']      = "evmadmin@company.com"
  obj['subject'] = subject
  obj['body']    = body

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_scan" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_scan
#
# Notes: This method is used to launch a Smart State Analysis on a vm
#
###################################
begin
  @method = 'vm_scan'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  $evm.log("info", "===========================================")
  $evm.log("info", "Dumping Object")

  $evm.log("info", "Args:    #{MIQ_ARGS.inspect}")

  obj = $evm.object
  $evm.log("info", "Listing Object Attributes:")
  obj.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug
  $evm.log("info", "===========================================")

  parent = $evm.object("..")
  profiles = parent.attributes["profiles"]
  $evm.log("info", "scan profiles: #{profiles.inspect}") if @debug

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the parent object for a VM
  #
  if vm.nil?
    vm = parent['vm']
    if vm.nil?
      vm_id = parent['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  #
  # No VM Found, exit
  #
  raise "VM not found" if vm.nil?
  

  $evm.log("info", "VM Attributes")
  vm.attributes.sort.each  { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug

  job = vm.scan(profiles)
  $evm.log("info", "Job Attributes")
  job.attributes.sort.each { |k, v| next if k == 'process'; $evm.log("info", "\t#{k}: #{v}")} if @debug
  $evm.log("info", "===========================================")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm_stop_and_unregister" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_stop_and_unregister
#
# Notes: This method is used to stop a vm and unregister a vm from the VC
#
###################################
begin
  @method = 'vm_stop_and_unregister'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  #
  # No VM Found, exit
  #
  raise "VM not found" if vm.nil?

  $evm.log("info", "VM Tags: #{vm.tags.inspect}") if @debug
  if vm.attributes['power_state'] == "on"
    $evm.log("info", "Stopping VM: [#{vm.attributes['name']}]")
    vm.stop
  end

  $evm.log("info", "Unregistering VM: [#{vm.attributes['name']}]")
  vm.unregister

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="20" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Log_Vm_Event">
      <MiqAeField name="meth5">
log_vm_event      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Vm_Allowed">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Vm_Email_Remedy">
      <MiqAeField name="meth3">
vm_email_remedy      </MiqAeField>
      <MiqAeField name="meth5">
send_email      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Vm_Post_Retire" display_name="Stop VM, Unregister and Email Owner">
      <MiqAeField name="meth3">
vm_stop_and_unregister      </MiqAeField>
      <MiqAeField name="meth5">
vm_email_owner      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Vm_Scan">
      <MiqAeField name="meth5">
vm_scan      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="host_and_storage_least_utilized">
      <MiqAeField name="meth5">
host_and_storage_least_utilized      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Service" namespace="Factory" description="Service" display_name="Service">
    <MiqAeMethod name="CatalogBundleInitialization" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: CatalogBundleInitialization
#
# Notes: This method Performs the following functions:
# 1. Look for all Service Dialog Options in the service_template_provision_task.dialog_options 
#    (i.e. Options that come from a Service Dialog)
# 2. Any Service dialog option keys that match the regular expression /^tag_0_(.*)/i will be used to 
#    tag the destination Service
# 3. Service dialog option keys that match the regular expression /^(option|tag)_(\d*)_(.*)/ 
#    (I.e. <option_type>_<sequence_id>_variable,  option_0_vm_memory, tag_1_environment) are sorted 
#    by sequence_id into an options_hash[sequence_id] and then distributed to the appropriate 
#    child catalog items. For example, a sequence_id of 0 means that all catalog items will inhereit 
#    these variables. A sequence_id of 1 means that the variable is only intended for a catalog item 
#    with a group index of 1.
# 4. Service dialog option keys that do NOT match the regular expression are then inserted into the 
#    options_hash[0] for all catalog items.
#
# Inputs: $evm.root['service_template_provision_task'].dialog_options
#
###################################
begin
  @method = 'CatalogBundleInitialization'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  #########################
  #
  # Method: get_options_hash
  # Description: Look for service dialog variables in the root object that start with "dialog_option_[0-9]",
  #
  ##########################
  def get_options_hash(dialog_options)
    # Setup regular expression for service dialog tags
    options_regex = /^(dialog_option|dialog_tag)_(\d*)_(.*)/i
    options_hash = {}

    # Loop through all of the options and build an options_hash from them
    dialog_options.each do |k,v|

      option_key = k.downcase.to_sym
      if options_regex =~ k
        sequence_id = $2.to_i

        unless v.blank?
          $evm.log("info", "#{@method} - Adding sequence_id:<#{sequence_id}> option_key:<#{option_key.inspect}> v:<#{v.inspect}> to options_hash") if @debug
          if options_hash.has_key?(sequence_id)
            options_hash[sequence_id][option_key] = v
          else
            options_hash[sequence_id] = { option_key => v }
          end
        end
      else
        # If options_regex does not match then stuff dialog options into options_hash[0]
        sequence_id = 0
        unless v.nil?
          $evm.log("info", "#{@method} - Adding sequence_id:<#{sequence_id}> option_key:<#{option_key.inspect}> v:<#{v.inspect}> to options_hash") if @debug
          if options_hash.has_key?(sequence_id)
            options_hash[sequence_id][option_key] = v
          else
            options_hash[sequence_id] = { option_key => v }
          end
        end
      end # if options_regex =~ k
    end # dialog_options.each do
    $evm.log("info", "#{@method} - Inspecting options_hash:<#{options_hash.inspect}>") if @debug
    return options_hash
  end


  #########################
  #
  # Method: tag_parent_service
  # Description: Look for tags with a sequence_id of 0 and tag the parent service
  #
  ##########################
  def tag_parent_service(service, options_hash)

    # Setup regular expression for service dialog tags
    tags_regex = /^dialog_tag_0_(.*)/i
    tags_hash = {}

    # Look for tags with a sequence_id of 0 to tag the destination Service
    options_hash[0].each do |k,v|
      $evm.log("info", "#{@method} - Processing Tag Key:<#{k.inspect}> Value:<#{v.inspect}>") if @debug
      if tags_regex =~ k
        # Convert key to symbol
        tag_category = $1
        tag_value = v.downcase
        unless tag_value.blank?
          $evm.log("info", "#{@method} - Adding tag_category:<#{tag_category.inspect}> value:<#{tag_value.inspect}> to Service:<#{service.name}>") if @debug
          service.tag_assign("#{tag_category}/#{tag_value}")
        end
      end # if tags_regex
    end # options_hash[0].each
  end


  # Get the task object from root
  service_template_provision_task = $evm.root['service_template_provision_task']

  # List Service Task Attributes
  #service_template_provision_task.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Task:<#{service_template_provision_task}> Attributes - #{k}: #{v}")} if @debug

  # Get destination service object
  service = service_template_provision_task.destination
  $evm.log("info","#{@method} - Detected Service:<#{service.name}> Id:<#{service.id}>") if @debug

  # Get dialog options from options hash
  # I.e. {:dialog=>{"option_0_myvar"=>"myprefix", "option_1_vservice_workers"=>"2", "tag_0_environment"=>"test", "tag_0_location"=>"paris",
  # "option_2_vm_memory"=>"2048", "option_0_vlan"=>"Internal", "option_1_cores_per_socket"=>"1"}}
  dialog_options = service_template_provision_task.dialog_options
  $evm.log("info","#{@method} - Inspecting Dialog Options:<#{dialog_options.inspect}>") if @debug

  # Get options_hash
  options_hash = get_options_hash(dialog_options)

  # Tag Parent Service
  tag_parent_service(service, options_hash)

  # Process Child Services
  service_template_provision_task.miq_request_tasks.each do |t|
    # Child Service
    child_service = t.destination
    # Service Bundle Resource
    child_service_resource = t.service_resource

    # Increment the provision_index number since the child resource starts with a zero
    group_idx = child_service_resource.provision_index + 1
    $evm.log("info","#{@method} - Child service name:<#{child_service.name}> group_idx:<#{group_idx}>") if @debug

    # Create dialog options hash variable
    dialog_options_hash = {}

    # Set all dialog options pertaining to the catalog item plus any options destined for the catalog bundle
    unless options_hash[0].nil?
      unless options_hash[group_idx].nil?
        # Merge child options with global options if any
        dialog_options_hash = options_hash[0].merge(options_hash[group_idx])
      else
        dialog_options_hash = options_hash[0]
      end
    else # unless options_hash[0].nil?
      unless options_hash[group_idx].nil?
        dialog_options_hash = options_hash[group_idx]
      end
    end

    # Pass down dialog options to catalog items
    dialog_options_hash.each do |k,v|
      $evm.log("info","#{@method} - Adding Dialog Option:<{#{k.inspect} => #{v.inspect}}> to Child Service:<#{child_service.name}>") if @debug
      t.set_dialog_option(k, v)
    end
    $evm.log("info","#{@method} - Inspecting Child Service:<#{child_service.name}> Dialog Options:<#{t.dialog_options.inspect}>") if @debug
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="CatalogItemInitialization" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: CatalogItemInitialization
#
# Notes: This method Performs the following functions:
# 1. Look for all Service Dialog Options in the service_template_provision_task.dialog_options 
#    (i.e. Dialog options that came from either a Catalog Bundle Service or a Service Dialog)
# 2. Service dialog option keys that match the regular expression /^tag_\d*_(.*)/i 
#    (I.e. <tag>_<sequence_id>_variable,  tag_0_function, tag_1_environment) will be used to 
#    tag the destination Catalog Item Service and any subordinate miq_provision tasks
# 3. The remaining Service Dialog Option keys are simply passed into the subordinate 
#    miq_provision object. I.e. option_0_vm_memory => 2048
#
# Inputs: $evm.root['service_template_provision_task'].dialog_options
#
###################################
begin
  @method = 'CatalogItemInitialization'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  #########################
  #
  # Method: get_tags_hash
  # Description: Look for service dialog variables in the dialog options hash that start with "tag_[0-9]",
  #
  ##########################
  def get_tags_hash(dialog_options)
    # Setup regular expression for service dialog tags
    tags_regex = /^dialog_tag_\d*_(.*)/

    tags_hash = {}

    # Loop through all of the tags and build an options_hash from them
    dialog_options.each do |k,v|
      if tags_regex =~ k
        #$evm.log("info", "#{@method} - Processing Tag Key:<#{k.inspect}> Value:<#{v.inspect}>") if @debug
        # Convert key to symbol
        tag_category = $1.to_sym
        tag_value = v.downcase

        unless tag_value.blank?
          $evm.log("info", "#{@method} - Adding category:<#{tag_category.inspect}> tag:<#{tag_value.inspect}> to tags_hash") if @debug
          tags_hash[tag_category] = tag_value
        end
      end
    end
    $evm.log("info", "#{@method} - Inspecting tags_hash:<#{tags_hash.inspect}>") if @debug
    return tags_hash
  end


  #########################
  #
  # Method: get_options_hash
  # Description: Look for service dialog variables in the dialog options hash that start with "option_[0-9]",
  #
  ##########################
  def get_options_hash(dialog_options)
    # Setup regular expression for service dialog tags
    options_regex = /^dialog_option_\d*_(.*)/
    options_hash = {}

    # Loop through all of the options and build an options_hash from them
    dialog_options.each do |k,v|
      if options_regex =~ k
        option_key = $1.to_sym
        option_value = v

        unless option_value.blank?
          $evm.log("info", "#{@method} - Adding option_key:<#{option_key.inspect}> option_value:<#{option_value.inspect}> to options_hash") if @debug
          options_hash[option_key] = option_value
        end
      else
        unless v.nil?
          $evm.log("info", "#{@method} - Adding option:<#{k.to_sym.inspect}> value:<#{v.inspect}> to options_hash") if @debug
          options_hash[k.to_sym] = v
        end
      end
    end
    $evm.log("info", "#{@method} - Inspecting options_hash:<#{options_hash.inspect}>") if @debug
    return options_hash
  end


  #########################
  #
  # Method: tag_service
  # Description: Look in tags_hash for tags and tag the service
  #
  ##########################
  def tag_service(service, tags_hash)
    # Look for tags with a sequence_id of 0 to tag the destination Service
    unless tags_hash.nil?
      tags_hash.each do |k,v|
        $evm.log("info","#{@method} - Adding Tag:<#{k.inspect}/#{v.inspect}> to Service:<#{service.name}>") if @debug
        service.tag_assign("#{k}/#{v}")
      end
    end
  end


  # Get the task object from root
  service_template_provision_task = $evm.root['service_template_provision_task']

  # List Service Task Attributes
  #service_template_provision_task.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Task:<#{service_template_provision_task}> Attributes - #{k}: #{v}")} if @debug

  # Get destination service object
  service = service_template_provision_task.destination
  $evm.log("info","#{@method} - Detected Service:<#{service.name}> Id:<#{service.id}>") if @debug

  # Get dialog options from options hash
  # {:dialog=>{"option_0_myvar"=>"myprefix", "option_1_vservice_workers"=>"2", "tag_0_environment"=>"test", "tag_0_location"=>"paris",
  # "option_2_vm_memory"=>"2048", "option_0_vlan"=>"Internal", "option_1_cores_per_socket"=>"1"}}
  dialog_options = service_template_provision_task.dialog_options
  $evm.log("info","#{@method} - Inspecting Dialog Options:<#{dialog_options.inspect}>") if @debug

  # Get tags_hash
  tags_hash = get_tags_hash(dialog_options)

  # Tag Service
  tag_service(service, tags_hash)

  # Get options_hash
  options_hash = get_options_hash(dialog_options)

  # Process Child Tasks
  service_template_provision_task.miq_request_tasks.each do |t|
    # Child Service
    child_service = t.destination

    # Process grandchildren service options
    unless t.miq_request_tasks.nil?
      grandchild_tasks = t.miq_request_tasks
      #$evm.log("info","#{@method} - Inspecting Grandchild Tasks:<#{grandchild_tasks.inspect}>") if @debug

      grandchild_tasks.each do |gc|
        $evm.log("info","#{@method} -  Detected Grandchild Task ID:<#{gc.id}> Description:<#{gc.description}> source type:<#{gc.source_type}>") if @debug

        # If child task is provisioning then apply tags and options
        if gc.source_type == "template"
          unless tags_hash.nil?
            tags_hash.each do |k,v|
              $evm.log("info","#{@method} - Adding Tag:<#{k.inspect}/#{v.inspect}> to Provisioning ID:<#{gc.id}>") if @debug
              gc.add_tag(k, v)
            end
          end
          unless options_hash.nil?
            options_hash.each do |k,v|
              $evm.log("info","#{@method} - Adding Option:<{#{k.inspect} => #{v.inspect}}> to Provisioning ID:<#{gc.id}>") if @debug
              gc.set_option(k,v)
            end
          end
        else
          $evm.log("info","#{@method} - Invalid Source Type:<#{gc.source_type}>. Skipping task ID:<#{gc.id}>") if @debug
        end # if gc.source_type
      end # grandchild_tasks.each do
    end # unless t.miq_request_tasks.nil?
  end # service_template_provision_task.miq_request_tasks.each do


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ConfigureChildDialog" language="ruby" scope="instance" location="inline"><![CDATA[#
#            EVM Automate Method
#
$evm.log("info", "EVM Automate Method ConfigureChildDialog Started")
#
#            Method Code Goes here
#
  $evm.log("info", "===========================================")  
  $evm.log("info", "Listing ROOT Attributes:")
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")}
  $evm.log("info", "===========================================")

  stp_task = $evm.root["service_template_provision_task"]
  $evm.log("info", "===========================================")  
  $evm.log("info", "Listing task Attributes:")
  stp_task.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")}
  $evm.log("info", "===========================================")

  $evm.log("info","No child dialog options have been configured.")
  exit MIQ_OK

  dialog_service_type = $evm.root['dialog_service_type']
  $evm.log("info","User selected Dialog option = [#{dialog_service_type}]")

  stp_miq_request_task = stp_task.miq_request_task
  #$evm.log("info","(parent) miq_request_task:  = [#{stp_miq_request_task}]")

  stp_miq_request_tasks = stp_task.miq_request_tasks
  #$evm.log("info","(children) miq_request_tasks count:  = [#{stp_miq_request_tasks.count}]")

  stp_miq_request_tasks.each do |t|
    $evm.log("info"," Setting dialog for: #{t.description}")
    service = t.source
    service_resource = t.service_resource
    #$evm.log("info"," Child service resource name: #{service_resource.resource_name}")
    #$evm.log("info"," Child service resource description: #{service_resource.resource_description}")

    service_tag_array = service.tags(:app_tier)  
    service_tag = service_tag_array.first.to_s

    memory_size = nil
    
    case dialog_service_type
    when "Small"
      case service_tag
      when "app"
        memory_size = 1024
      when "web"
        memory_size = 1024
      when "db"
        memory_size = 4096
      else
        $evm.log("info","Unknown Dialog type")
      end
    when "Large"
      case service_tag
      when "app"
        memory_size = 4096
      when "web"
        memory_size = 4096
      when "db"
        memory_size = 8192
      else
        $evm.log("info","Unknown Dialog type")
      end
    else
      $evm.log("info","Unknown Dialog type - setting Dialog options here")
    end
    
    t.set_dialog_option('memory',memory_size) unless memory_size.nil?

    $evm.log("info","Set dialog for selection: [#{dialog_service_type}]  Service_Tier: [#{service_tag}] Memory size: [#{memory_size}]")
  end
#
#
#
$evm.log("info", "EVM Automate Method ConfigureChildDialog Ended")
exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="GroupSequenceCheck" language="ruby" scope="instance" location="inline" display_name="GroupSequenceCheck"><![CDATA[###################################
#
# EVM Automate Method: GroupSequenceCheck
#
# Notes: This method checks to see if the task can be processed
#
###################################
begin
  @method = 'GroupSequenceCheck'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn on verbose logging
  @debug = true

  $evm.log("info", "#{@method} - Listing Root Object Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
  $evm.log("info", "#{@method} - ===========================================") if @debug

  # Get current provisioning status
  task = $evm.root['service_template_provision_task']

  # check if the task is in a runnable state, otherwise abort processing
  unless task.attributes['status'] == 'Ok' 
    $evm.log('info', "#{@method} - Aborting due to task status: <#{task.status}>  task real status: <#{task.attributes['status']}> for Task: <#{task.id}> Description: <#{task.description}> state: <#{task.state}>.") if @debug
    exit MIQ_ABORT
  end

  result = task.group_sequence_run_now?
  $evm.log('info', "#{@method} group_sequence_run_now returned: <#{result}> for Task: <#{task.id}> Description: <#{task.description}> state: <#{task.state}> ") if @debug

  case result
  when false
    $evm.root['ae_result']         = 'retry'
    $evm.root['ae_retry_interval'] = '1.minute'
    $evm.log('info', "#{@method} - Service GroupSequenceCheck determined that it cannot run yet. Setting retry for task id: <#{task.id}> description: <#{task.description}> Parent task: <#{task.miq_request_id}> Parent description: <#{task.miq_request.description}> ") if @debug
  when true
    # Bump State
    $evm.root['ae_result'] = 'ok'
    $evm.log('info', "#{@method} - Service GroupSequenceCheck determined that it can run. Proceeding with task id: <#{task.id}> description: <#{task.description}>  Parent task: <#{task.miq_request_id}> Parent description: <#{task.miq_request.description}> ") if @debug
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="check_provisioned" language="ruby" scope="instance" location="inline" display_name="CheckProvisioned"><![CDATA[###################################
#
# EVM Automate Method: check_provisioned
#
# Notes: This method checks to see if the service has been provisioned
#
###################################
begin
  @method = 'check_provisioned'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  $evm.log("info", "#{@method} - Listing Root Object Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
  $evm.log("info", "#{@method} - ===========================================") if @debug

  # Get current provisioning status
  task = $evm.root['service_template_provision_task']
  task_status = task['status']
  result = task.status

  $evm.log('info', "#{@method} - Service ProvisionCheck returned <#{result}> for state <#{task.state}> and status <#{task_status}>") if @debug

  case result
  when 'error'
    $evm.root['ae_result'] = 'error'
    reason = $evm.root['miq_provision'].message
    reason = reason[7..-1] if reason[0..6] == 'Error: '
    $evm.root['ae_reason'] = reason
  when 'retry'
    $evm.root['ae_result']         = 'retry'
    $evm.root['ae_retry_interval'] = '1.minute'
  when 'ok'
    # Bump State
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="checkservicevmretirement" language="ruby" scope="instance" location="inline" display_name="checkservicevmretirement"><![CDATA[###################################
#
# EVM Automate Method: checkservicevmretirement
#
# Notes: This method checks to see that all of the vms are retired before retiring the service.
#
###################################
begin
  @method = 'checkservicevmretirement'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  $evm.log("info", "#{@method} - Listing Root Object Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
  $evm.log("info", "#{@method} - ===========================================") if @debug

  # Get current provisioning status
  service = $evm.root['service']
  if service.nil?
    $evm.log('info', "#{@method} - Service Object not found") 
    exit MIQ_ABORT
  end

  $evm.log('info', "#{@method} - Service inspect: #{service.inspect} ") 

  unless service.parent_service.nil?
    $evm.log('info', "#{@method} - Cannot continue, Not the top level service.  Parent_service: #{service.parent_service}")
    exit MIQ_ABORT
  end

  result = 'ok'
  vm_name = nil

  service.vms.each do |v|
    $evm.log('info', "#{@method} - checking if vm: #{v.name} is retired.")  
    unless v.retired
      result = 'retry'
      vm_name = v.name
      #$evm.log('info', "#{@method} - Checking if vm: #{v.name}" is retired.")  
      $evm.log('info', "#{@method} - vm: #{v.name} is not retired, setting retry.")  
      break
    end
  end


  $evm.log('info', "#{@method} - Service: #{service.name} VM retirement check returned <#{result}>") if @debug

  case result
  when 'error'
    $evm.log('info', "#{@method} - Service: #{service.name}. Not all VMs are retired. can not proceed with retirement.")  
    $evm.root['ae_result'] = 'error'
    reason = $evm.root['service_template_provision_task'].message
    reason = reason[7..-1] if reason[0..6] == 'Error: '
    $evm.root['ae_reason'] = reason
  when 'retry'
    $evm.log('info', "#{@method} - Service: #{service.name} VM: #{vm_name} is not retired, setting retry.")  
    $evm.root['ae_result']         = 'retry'
    $evm.root['ae_retry_interval'] = '1.minute'
  when 'ok'
    # Bump State
    $evm.log('info', "#{@method} - All VMs are retired for service: #{service.name}. ")  
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="deleteservicefromvmdb" language="ruby" scope="instance" location="inline" display_name="DeleteServiceFromVMDB"><![CDATA[###################################
#
# EVM Automate Method: delete_from_vmdb
#
# Notes: This method removes the Service from the VMDB database
#
###################################
begin
  @method = 'delete_from_vmdb'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  service = $evm.root['service']
  category = "lifecycle"
  tag = "retire_full"

  if service 
    $evm.log('info', "#{@method} - Deleting Service <#{service.name}> from VMDB") if @debug
    service.remove_from_vmdb
  end

  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="markserviceasretired" language="ruby" scope="instance" location="inline" display_name="MarkServiceAsRetired"><![CDATA[###################################
#
# EVM Automate Method: markserviceasretired
#
# Notes: This method marks the service as retired
#
###################################
begin
  @method = 'markserviceasretired'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  $evm.log("info", "#{@method} - Listing Root Object Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
  $evm.log("info", "#{@method} - ===========================================") if @debug

  service = $evm.root['service']
  if service.nil?
    $evm.log('info', "#{@method} - Service Object not found") 
    exit MIQ_ABORT
  end

  $evm.log('info', "#{@method} - Service inspect: #{service.inspect} ") 

  unless service.parent_service.nil?
    $evm.log('info', "#{@method} - Cannot continue, Not the top level service.  Parent_service: #{service.parent_service}")
    exit MIQ_ABORT
  end

  $evm.log('info', "#{@method} - Service before: #{service.inspect} marked as retired.")

  service.retire_now
  $evm.log('info', "#{@method} - Service: #{service.inspect} marked as retired.")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="provision" language="ruby" scope="instance" location="inline" display_name="provision"><![CDATA[###################################
#
# EVM Automate Method: provision
#
# Notes: This method launches the provisioning job
#
###################################
begin
  @method = 'provision'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  $evm.log("info", "#{@method} - Listing Root Object Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
  $evm.log("info", "#{@method} - ===========================================") if @debug

  $evm.root["service_template_provision_task"].execute


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="retireservicevms" language="ruby" scope="instance" location="inline" display_name="RetireServiceVms"><![CDATA[###################################
#
# EVM Automate Method: retireservicemethods
#
# Notes: This method attempts to retire all of the vms under this top level service
#
###################################
begin
  @method = 'retireservicevms'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  $evm.log("info", "#{@method} - Listing Root Object Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
  $evm.log("info", "#{@method} - ===========================================") if @debug

  service = $evm.root['service']
  if service.nil?
    $evm.log('info', "#{@method} - Service Object not found") 
    exit MIQ_ABORT
  end

  $evm.log('info', "#{@method} - Service inspect: #{service.inspect} ") 

  unless service.parent_service.nil?
    $evm.log('info', "#{@method} - Cannot continue, Not the top level service.  Parent_service: #{service.parent_service}")
    exit MIQ_ABORT
  end

  service.vms.each  do |v|
    $evm.log('info', "#{@method} - ZZZZZZZ Would call vm retirement for vm: #{v.inspect}")  
    $evm.root['vm'] = v
    $evm.root['vm_id'] = v.id
    $evm.log("info", "#{@method} - AGAIN Listing Root Object Attributes:") if @debug
    $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug }
    $evm.log("info", "#{@method} - ===========================================") if @debug
    #$evm.instantiate("/Automation/VMLifecycle/Retirement")
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="CatalogBundleInitialization">
      <MiqAeField name="execute">
CatalogBundleInitialization      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CatalogItemInitialization">
      <MiqAeField name="execute">
CatalogItemInitialization      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CheckProvisioned">
      <MiqAeField name="execute">
check_provisioned      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ConfigureChildDialog" description="ConfigureChildDialog">
      <MiqAeField name="execute">
configurechilddialog      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="GroupSequenceCheck" display_name="GroupSequenceCheck" description="GroupSequenceCheck">
      <MiqAeField name="execute">
GroupSequenceCheck      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="checkservicevmretirement" display_name="CheckServiceVMRetirement">
      <MiqAeField name="execute">
checkservicevmretirement      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="deleteservicefromvmdb" display_name="DeleteServiceFromVMDB">
      <MiqAeField name="execute">
deleteservicefromvmdb      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="markserviceasretired" display_name="MarkServiceAsRetired">
      <MiqAeField name="execute">
markserviceasretired      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="provision" display_name="Provision" description="provision">
      <MiqAeField name="execute">
provision      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="retireservicevms" display_name="RetireServiceVms">
      <MiqAeField name="execute">
retireservicevms      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ServiceNow" namespace="Factory" display_name="Service-Now">
    <MiqAeSchema>
      <MiqAeField name="server" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
manageiqdev.service-now.com      </MiqAeField>
      <MiqAeField name="username" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
itil      </MiqAeField>
      <MiqAeField name="password" substitute="true" aetype="attribute" datatype="password" priority="3" message="create">
v2:{a2NQnMqz6iSz31mmiv1Gig==}      </MiqAeField>
      <MiqAeField name="agent" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="queue" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
input      </MiqAeField>
      <MiqAeField name="topic" substitute="true" aetype="attribute" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="name" substitute="true" aetype="attribute" datatype="string" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="source" substitute="true" aetype="attribute" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="payload" substitute="true" aetype="attribute" datatype="array" priority="9" message="create" collect="['id', id, 'request_id', request_id, 'item_id', item_id, 'message', message, 'status', status, 'step', step]">
      </MiqAeField>
      <MiqAeField name="meth" substitute="true" aetype="method" datatype="string" priority="10" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="create_ci_in_eccq" display_name="Create CI in Service Now">
      <MiqAeField name="server">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="username">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="password">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="agent">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="queue">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="topic">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="source">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="payload" collect="['evm_vmname',evm_vmname,'evm_hostname',evm_hostname,'config_version',config_version,'virtual_hw_version',virtual_hw_version,'guest_os',guest_os,'numvcpus',numvcpus,'bios',bios,'bios_location',bios_location,'time_sync',time_sync,'annotation',annotation,'vm_id',vm_id,'memory_cpu',memory_cpu,'host_id',host_id,'cpu_speed',cpu_speed,'cpu_type',cpu_type,'size_on_disk',size_on_disk,'manufacturer',manufacturer,'model',model,'number_of_nics',number_of_nics,'cpu_usage',cpu_usage,'memory_usage',memory_usage,'cores_per_socket',cores_per_socket,'logical_cpus',logical_cpus,'vmotion_enabled',vmotion_enabled,'disk_free_space',disk_free_space,'disk_capacity',disk_capacity,'guest_os_full_name',guest_os_full_name,'memory_console',memory_console,'service_pack',service_pack,'product_name',product_name,'os_version',os_version,'os_type',os_type,'os_width',os_width,'host_name',host_name,'host_ipaddress',host_ipaddress,'ems_name',ems_name,'ems_ipaddress',ems_ipaddress,'vm_ipaddr',vm_ipaddr]">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth">
service_now_eccq_insert(server=&gt;server, username =&gt;username, password=&gt;password, agent =&gt;agent, queue=&gt;queue, topic=&gt;topic, name=&gt;name, source=&gt;source, payload=&gt;payload)      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="create_incident_in_eccq" display_name="Create Incident in Service Now">
      <MiqAeField name="server">
manageiqdemo.service-now.com      </MiqAeField>
      <MiqAeField name="username">
admin      </MiqAeField>
      <MiqAeField name="password">
"v2:{a2NQnMqz6iSz31mmiv1Gig==}"      </MiqAeField>
      <MiqAeField name="agent">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="queue">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="topic">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="source">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="payload" collect="['comments', comments, 'vmurl', vmurl, 'hosturl', hosturl, 'evm_vmname', evm_vmname, 'hostname', hostname, 'evm_policy_id', evm_policy_id, 'evm_policy_name', evm_policy_name, 'evm_policy_description', evm_policy_description, 'severity', severity, 'priority', priority, 'emsname', emsname, 'emsip', emsip, 'username', username, 'userid', userid]">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth">
service_now_eccq_insert(server=&gt;server, username =&gt;username, password=&gt;password, agent =&gt;agent, queue=&gt;queue, topic=&gt;topic, name=&gt;name, source=&gt;source, payload=&gt;payload)      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="eccq_insert">
      <MiqAeField name="server">
manageiqdemo.service-now.com      </MiqAeField>
      <MiqAeField name="username">
admin      </MiqAeField>
      <MiqAeField name="password">
"v2:{a2NQnMqz6iSz31mmiv1Gig==}"      </MiqAeField>
      <MiqAeField name="agent">
EVM Automate      </MiqAeField>
      <MiqAeField name="queue">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="topic">
VM Provisioning      </MiqAeField>
      <MiqAeField name="name">
Request for EVM Provisioning      </MiqAeField>
      <MiqAeField name="source">
EVM Test      </MiqAeField>
      <MiqAeField name="payload">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth">
service_now_eccq_insert(server=&gt;server, username =&gt;username, password=&gt;password, agent =&gt;agent, queue=&gt;queue, topic=&gt;topic, name=&gt;name, source=&gt;source, payload=&gt;payload)      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="eccq_insert1">
      <MiqAeField name="server">
manageiqdemo.service-now.com      </MiqAeField>
      <MiqAeField name="username">
admin      </MiqAeField>
      <MiqAeField name="password">
"v2:{a2NQnMqz6iSz31mmiv1Gig==}"      </MiqAeField>
      <MiqAeField name="agent">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="queue">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="topic">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="name">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="source">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="payload">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth">
service_now_eccq_insert(server=&gt;server, username =&gt;username, password=&gt;password, agent =&gt;agent, queue=&gt;queue, topic=&gt;topic, name=&gt;name, source=&gt;source, payload=&gt;payload)      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="HostProvision" namespace="Factory/StateMachines" description="Factory State Machines" display_name="Host Provision State Machine">
    <MiqAeMethod name="update_provision_status" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: update_provision_status
#
# Notes: This method updates provisioning status and calls Service Now if applicable
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_provision_status'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Initialize variables
  #
  prov = $evm.root['miq_host_provision'] || $evm.root['miq_host_provision']
  prov_id = prov['id']

  # Get variables from Server object
  server  = $evm.root['miq_server']
  evm_ipaddr  = server.ipaddress
  evm_hostname = server.hostname
  evm_region = server.region_number

  # Get provisioning type [host_pxe_install, template, clone_to_vm or clone_to_template]
  prov_type = prov.provision_type

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']


  ###################################
  #
  # Update Status for on_entry,on_exit
  #
  ###################################
  if $evm.root['ae_result'] == 'ok'

    # Check to see if provisioning is complete
    if status == 'provision_complete'
      message      = 'Host Provisioned Successfully'
      prov.finished(message)
    end
    prov.message = status
  end


  ###################################
  #
  # Update Status for on_error
  #
  ###################################
  if $evm.root['ae_result'] == 'error'
    prov.message = status
  end


  ###################################
  #
  # Call Service-Now
  #
  ###################################
  if prov.options.has_key?(:ws_values)
    ws_values  = prov.options[:ws_values]

    # Set request_id from Service-Now unless nil set to provisioning id
    request_id = ws_values[:request_id] || ws_values[:requestid] || prov_id
    item_id    = ws_values[:item_id]    || ws_values[:itemid] || prov_id
    friendly_itemid = ws_values[:friendly_itemid]

    $evm.log("info","RequestID: <#{request_id}>") if @debug
    $evm.log("info","ItemID: <#{item_id}>") if @debug
    $evm.log("info","Friendly ItemID: <#{friendly_itemid}>") if @debug

    unless request_id.nil? || item_id.nil?

      message = status_state
      # state_retries = $evm.root['ae_state_retries'] || 0

      agent         = "EVM Automate Provisioning"
      topic         = "Item:#{friendly_itemid} | EVM:#{prov_id} | StateMachine:#{state}"
      name          = "Step:#{step} | State:#{status_state}"
      source        = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

      require 'uri'
      args = "agent=#{agent}&topic=#{topic}&source=#{source}&name=#{name}&id=#{prov_id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      #args = "topic=#{topic}&id=#{id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      args = URI.escape(args)

      $evm.log("info","Calling Service-Now with arguments: #{args}")
      $evm.instantiate("/Factory/ServiceNow/eccq_insert1?#{args}")
    end
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>      <MiqAeField name="status_state" substitute="true" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="status" substitute="true" priority="2" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="CustomizeRequest" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_provision_status(status =&gt; 'Customizing Request',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Customized Request',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Customizing Request',status_state =&gt; 'on_error')" max_retries="100">
/Factory/Host/CustomizeRequest      </MiqAeField>
      <MiqAeField name="AcquireIPAddress" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_provision_status(status =&gt; 'Acquiring IP Address',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Acquired IP Address',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Acquiring IP Address',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="AcquireMACAddress" substitute="true" aetype="state" datatype="string" priority="3" message="create" on_entry="update_provision_status(status =&gt; 'Acquiring MAC Address',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Acquired MAC Address',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Acquiring MAC Address',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="RegisterDNS" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_provision_status(status =&gt; 'Registering DNS',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered DNS',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering DNS',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="RegisterCMDB" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_entry="update_provision_status(status =&gt; 'Registering CMDB',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered CMDB',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="RegisterAD" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="update_provision_status(status =&gt; 'Registering ActiveDirectory',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered ActiveDirectory',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering ActiveDirectory',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="PreProvision" substitute="true" aetype="state" datatype="string" priority="7" message="create" on_entry="update_provision_status(status =&gt; 'Applying PreProvision Customizations',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Applied PreProvision Customizations',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Applying PreProvision Customizations',status_state =&gt; 'on_error')" max_retries="100">
/Factory/Host/PreProvision_Host      </MiqAeField>
      <MiqAeField name="Provision" substitute="true" aetype="state" datatype="string" priority="8" message="create" on_entry="update_provision_status(status =&gt; 'PXE Booting Host',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'PXE Booted Host',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in PXE Booting Host',status_state =&gt; 'on_error')" max_retries="100">
/Factory/Host/Provision      </MiqAeField>
      <MiqAeField name="CheckProvisioned" substitute="true" aetype="state" datatype="string" priority="9" message="create" on_exit="update_provision_status(status =&gt; 'Provisioning Host',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; '${/#ae_reason}',status_state =&gt; 'on_error')" max_retries="100">
/Factory/Host/CheckProvisioned      </MiqAeField>
      <MiqAeField name="PostProvision" substitute="true" aetype="state" datatype="string" priority="10" message="create" on_entry="update_provision_status(status =&gt; 'Applying PostProvision Customizations',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Applied PostProvision Customizations',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Applying PostProvision Customizations',status_state =&gt; 'on_error')">
/Factory/Host/PostProvision_Host      </MiqAeField>
      <MiqAeField name="RegisterDHCP" substitute="true" aetype="state" datatype="string" priority="11" message="create" on_entry="update_provision_status(status =&gt; 'Registering DHCP',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered DHCP',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering DHCP',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="ActivateCMDB" substitute="true" aetype="state" datatype="string" priority="12" message="create" on_entry="update_provision_status(status =&gt; 'Activating CMDB',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Activated CMDB',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Activating CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="EmailOwner" substitute="true" aetype="state" datatype="string" priority="13" message="create" on_entry="update_provision_status(status =&gt; 'Emailing Owner',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'provision_complete',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Emailing Owner',status_state =&gt; 'on_error')" max_retries="100">
/Alert/EmailNotifications/MiqHostProvision_complete?event=host_provisioned      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="host_pxe_install" display_name="Provision Host from PXE">
      <MiqAeField name="CustomizeRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="AcquireIPAddress">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="AcquireMACAddress">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="RegisterDNS">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="RegisterCMDB">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="RegisterAD">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="PreProvision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="CheckProvisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PostProvision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="RegisterDHCP">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="ActivateCMDB">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ProvisionRequestApproval" namespace="Factory/StateMachines" description="Factory State Machines" display_name="VM Provision Approval State Machine">
    <MiqAeMethod name="approve_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: approve_request
#
# This method is executed when the provisioning request is auto-approved
#
###################################
begin
  @method = 'approve_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Auto-Approve request
  $evm.log("info", "#{@method} - AUTO-APPROVING") if @debug
  $evm.root["miq_request"].approve("admin", "Auto-Approved")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK
 
  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="pending_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: pending_request
#
# Notes: This method is executed when the provisioning request is NOT auto-approved
#
###################################
begin
  @method = 'pending_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get objects
  provision_request = $evm.root['miq_request'].resource
  msg = $evm.object['reason']
  $evm.log('info',"#{@method} - #{msg}") if @debug


  # execute email method to notify the requester
  #$evm.instantiate("/Alert/EmailNotifications/request_pending?reason=>#{msg}")


  # Raise automation event: request_pending
  $evm.root["miq_request"].pending


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>      <MiqAeField name="reason" substitute="true" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeMethod name="validate_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: validate_request
#
# Notes: This method validates the provisioning request using the values
# [max_vms, max_cpus, max_memory, max_retirement_days] from values in the following order:
# 1. In the model
# 2. Template tags - This looks at the source provisioning template/VM for the following tag
# category values: [prov_max_cpu, prov_max_vm, prov_max_memory, prov_max_retirement_days]
#
#
###################################
begin
  @method = 'validate_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Initialize Variables
  #
  prov = $evm.root['miq_request']
  prov_resource = prov.resource
  raise "#{@method} - Provisioning Request not found" if prov.nil? || prov_resource.nil?

  # Dump the provisioning object
  #$evm.log("info","Inspecting Provisioning Object: <#{prov.inspect}>") if @debug
  #$evm.log("info","Inspecting Provisioning Resource Object: <#{prov.resource.inspect}>") if @debug

  # Get template information
  template = prov.resource.vm_template rescue nil
  raise "#{@method} - VM template not specified" if template.nil?

  # Dump template object to the log
  #$evm.log("info","Inspecting Template object: <#{template.inspect}>") if @debug


  # Initialize variables used
  approval_req = false
  reason1      = nil
  reason2      = nil
  reason3      = nil
  reason4      = nil


  ###################################
  #
  # max_cpus:
  # Validate max_cpus by first checking the below
  # value, then check the model and finally the template tag
  #
  ###################################
  # Set max_cpus here to override the model
  max_cpus = nil

  # Use value from model unless specified above
  max_cpus ||= $evm.object['max_cpus']
  unless max_cpus.nil?
    $evm.log("info","#{@method} - Auto-Approval Threshold(Model):<max_cpus=#{max_cpus}> detected") if @debug
  end

  # Reset to nil if value is zero
  max_cpus = nil if max_cpus == '0'

  # Get Template Tag
  prov_max_cpus = template.tags(:prov_max_cpu).first
  # If template is tagged then override
  unless prov_max_cpus.nil?
    $evm.log("info","#{@method} - Auto-Approval Threshold(Tag):<prov_max_cpus=#{prov_max_cpus}> from template:<#{template.name}> detected") if @debug
    max_cpus = prov_max_cpus.first.to_i
  end

  # Validate max_cpus if not nil or empty
  unless max_cpus.blank?
    desired_cpus = prov_resource.get_option(:number_of_cpus).to_i
    if desired_cpus.zero?
      desired_cpus = prov_resource.get_option(:number_of_sockets).to_i * prov_resource.get_option(:cores_per_socket).to_i
    end

    if desired_cpus > max_cpus.to_i
      $evm.log("info", "#{@method} - Auto-Approval Threshold(Warning): Number of vCPUs requested:<#{desired_cpus}> exceeds:<#{max_cpus}>") if @debug
      approval_req = true
      reason1 = "Requested CPUs #{desired_cpus} limit is #{max_cpus}"
    end
  end


  ###################################
  #
  # max_vms:
  # Validate max_vms by first checking the below
  # value, then check the model and finally the template tag
  #
  ###################################
  # Set max_vms here to override the model
  max_vms = nil

  # Use value from model unless specified above
  max_vms ||= $evm.object['max_vms']
  unless max_vms.nil?
    $evm.log("info","#{@method} - Auto-Approval Threshold(Model):<max_vms=#{max_vms}> detected") if @debug
  end

  # Reset to nil if value is zero
  max_vms = nil if max_vms == '0'

  # Get Template Tag
  prov_max_vms = template.tags(:prov_max_vm).first
  # If template is tagged then override
  unless prov_max_vms.nil?
    $evm.log("info","#{@method} - Auto-Approval Threshold(Tag):<prov_max_vms=#{prov_max_vms}> from template:<#{template.name}> detected") if @debug
    max_vms = prov_max_vms.to_i
  end

  # Validate max_vms if not nil or empty
  unless max_vms.blank?
    desired_nvms = prov_resource.get_option(:number_of_vms)
    if desired_nvms && (desired_nvms.to_i > max_vms.to_i)
      $evm.log("info", "#{@method} - Auto-Approval Threshold(Warning): Number of VMs requested:<#{desired_nvms}> exceeds:<#{max_vms}>") if @debug
      approval_req = true
      reason3 = "Requested VMs #{desired_nvms} limit is #{max_vms}"
    end
  end


  ###################################
  #
  # max_memory:
  # Validate max_memory by first checking the below
  # value, then check the model and finally the template tag
  #
  ###################################
  # Set max_memory here to override the model
  max_memory = nil

  # Use value from model unless specified above
  max_memory ||= $evm.object['max_memory']
  unless max_memory.nil?
  $evm.log("info","#{@method} - Auto-Approval Threshold(Model):<max_memory=#{max_memory}> detected") if @debug
end

  # Reset to nil if value is zero
  max_memory = nil if max_memory == '0'

  # Get Tag
  prov_max_memory = template.tags(:prov_max_memory).first
  # If template is tagged then override
  unless prov_max_memory.nil?
    $evm.log("info","#{@method} - Auto-Approval Threshold(Tag):<prov_max_memory=#{prov_max_memory}> from template:<#{template.name}> detected") if @debug
    max_memory = prov_max_memory.to_i
  end

  # Validate max_memory if not nil or empty
  unless max_memory.blank?
    desired_mem = prov_resource.get_option(:vm_memory)
    if desired_mem && (desired_mem.to_i > max_memory.to_i)
      $evm.log("info", "#{@method} - Auto-Approval Threshold(Warning): Number of vRAM requested:<#{desired_mem}> exceeds:<#{max_memory}>") if @debug
      approval_req = true
      reason2 = "Requested Memory #{desired_mem}MB limit is #{max_memory}MB"
    end
  end


  ###################################
  #
  # max_retirement_days:
  # Validate max_retirement_days by first checking the below
  # value, then check the model and finally the template tag
  #
  ###################################
  # Set max_retirement_days here to override the model
  max_retirement_days = nil

  # Use value from model unless specified above
  max_retirement_days ||= $evm.object['max_retirement_days']
unless max_retirement_days.nil?
  $evm.log("info","#{@method} - Auto-Approval Threshold(Model):<max_retirement_days=#{max_retirement_days}> detected") if @debug
end

  # Reset to nil if value is zero
  max_retirement_days = nil if max_retirement_days == '0'

  # Get Tag
  prov_max_retirement_days = template.tags(:prov_max_retirement_days).first
  # If template is tagged then override
  unless prov_max_retirement_days.nil?
    $evm.log("info","#{@method} - Auto-Approval Threshold(Tag):<prov_max_retirement_days=#{prov_max_retirement_days}> from template:<#{template.name}> detected") if @debug
    max_retirement_days = prov_max_retirement_days.to_i
  end

  # Validate max_retirement_days if not nil or empty
  unless max_retirement_days.blank?
    desired_retirement_days = prov_resource.get_retirement_days
    if desired_retirement_days && (desired_retirement_days.to_i > max_retirement_days.to_i)
      $evm.log("info", "#{@method} - Auto-Approval Threshold(Warning): Number of Retirement Days requested:<#{desired_retirement_days}> exceeds:<#{max_retirement_days}>") if @debug
      approval_req = true
      reason4 = "Requested Retirement Days #{desired_retirement_days} limit is #{max_retirement_days}"
    end
  end


  ######################################
  #
  # Update Message to Requester
  #
  ######################################
  if approval_req == true
    msg = ""
    msg =  "Request was not auto-approved for the following reasons: "
    msg += "(#{reason1}) " unless reason1.nil?
    msg += "(#{reason2}) " unless reason2.nil?
    msg += "(#{reason3}) " unless reason3.nil?
    msg += "(#{reason4}) " unless reason4.nil?
    prov_resource.set_message(msg)
    $evm.log("info","#{@method} - Inspecting Messge:<#{msg}>") if @debug

    $evm.root['ae_result'] = 'error'
    $evm.object['reason'] = msg
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="max_cpus" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="max_vms" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="max_memory" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="max_retirement_days" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="ValidateRequest" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_entry="validate_request" on_error="pending_request" max_retries="100">
      </MiqAeField>
      <MiqAeField name="ApproveRequest" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="approve_request" max_retries="100">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Default" display_name="Default">
      <MiqAeField name="max_cpus">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="max_vms">
1      </MiqAeField>
      <MiqAeField name="max_memory">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="max_retirement_days">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ValidateRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ApproveRequest">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ProvisionRequestQuotaVerification" namespace="Factory/StateMachines" description="Factory State Machines" display_name="VM Provision Quota Verification State Machine">
    <MiqAeMethod name="rejected" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: rejected
#
# Notes: This method runs when the provision request quota validation has failed
#
###################################
begin
  @method = 'rejected'
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Started")

  # Deny the request
  $evm.log('info',"Request denied because of Quota")
  $evm.root["miq_request"].deny("admin", "Quota Exceeded")
  #$evm.root["miq_request"].pending("admin", "Quota Exceeded")


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK


  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>      <MiqAeField name="reason" substitute="true" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeMethod name="validate_quotas" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: validate_quotas
#
# Notes: This method validates the group or owner quotas using the values
# [max_group_cpu, max_group_memory, max_group_storage, max_owner_cpu, max_owner_memory, max_owner_storage]
# from values in the following order:
# 1. In the model
# 2. Group tags - This looks at the Group for the following
# tag values: [quota_max_cpu, quota_max_memory, quota_max_storage]
# 2a. Owner tags - This looks at the User for the following
# tag values: [quota_max_cpu, quota_max_memory, quota_max_storage]
#
###################################
begin
  @method = 'validate_quotas'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Initialize Variables
  #
  quota_exceeded = false
  miq_request = $evm.root['miq_request']
  miq_provision_request = miq_request.resource
  user = miq_request.requester
  group = user.current_group

  # Specify whether quotas should be managed by group or user
  manage_quotas_by_group = true

  # Extract Request Information
  vms_in_request = miq_provision_request.get_option(:number_of_vms).to_i
  cpu_in_request = miq_provision_request.get_option(:number_of_cpus).to_i
  if cpu_in_request.zero?
    cpu_in_request = miq_provision_request.get_option(:number_of_sockets).to_i * miq_provision_request.get_option(:cores_per_socket).to_i
  end
  memory_in_request = miq_provision_request.get_option(:vm_memory).to_i

  # Calculate total CPU based on number of VMs in request
  total_cpu_in_request = vms_in_request * cpu_in_request
  $evm.log("info", "#{@method} - Total Requested Provisioning vCPUs: #{total_cpu_in_request}") if @debug

  # Calculate total Memory based on number of VMs in request
  total_memory_in_request = vms_in_request * memory_in_request
  total_memory_nice = "%.2fGB" % (total_memory_in_request / 1024)
  $evm.log("info", "#{@method} - Total Requested Provisioning Memory: #{total_memory_nice}") if @debug

  # Calculate total Storage based on number of VMs in request
  vm_size = miq_provision_request.vm_template.provisioned_storage
  total_storage_nice = "%.2fGB" % (vm_size * vms_in_request / 1024**3)
  $evm.log("info", "#{@method} - Total Requested Provisioning Storage: #{total_storage_nice}") if @debug


  if manage_quotas_by_group
    # Available check_quota methods [:vms_by_group, :vms_by_owner_and_group]
    quota_group = miq_provision_request.check_quota(:vms_by_group, {:include_retired_vms => false})
    $evm.log("info","#{@method} - Inspecting quota_group:<#{quota_group.inspect}>") if @debug

    ##########################
    #
    # Group CPU Quota Check
    #
    ##########################
    $evm.log("info","#{@method} - Beginning Group CPU Quota Check") if @debug
    $evm.log("info", "#{@method} - Group: <#{group.description}> current CPU usage: <#{quota_group[:cpu]}>") if @debug

    max_group_cpu   = nil
    g_quota_exceeded_reason1 = nil

    # Use value from model unless specified above
    max_group_cpu ||= $evm.object['max_group_cpu']
    unless max_group_cpu.nil?
      $evm.log("info","#{@method} - Found quota from model <quota_max_cpu> with value <#{max_group_cpu}>") if @debug
    end

    # Get tag from Group
    tag_max_group_cpu = group.tags(:quota_max_cpu).first
    unless tag_max_group_cpu.nil?
      $evm.log("info","#{@method} - Found quota from Group <#{group.description}> tag <:quota_max_cpu> with value <#{tag_max_group_cpu}>") if @debug
    end

    # If group is tagged then override
    unless tag_max_group_cpu.nil?
      max_group_cpu = tag_max_group_cpu.to_i
      $evm.log("info","#{@method} - Overriding quota from Group <#{group.description}> tag <:quota_max_cpu> with value <#{tag_max_group_cpu}>") if @debug
    end

    # Validate Group CPU Quota
    unless max_group_cpu.blank?
      if quota_group && (quota_group[:cpu] + total_cpu_in_request > max_group_cpu.to_i)
        $evm.log("info", "#{@method} - CPUs allocated for Group <#{quota_group[:cpu]}> +  Requested CPUs <#{total_cpu_in_request}> exceeds Quota Max CPUs <#{max_group_cpu}>") if @debug
        quota_exceeded = true
        g_total_vcpus = quota_group[:cpu]
        g_quota_exceeded_reason1 = "Group Allocated vCPUs #{g_total_vcpus} + Requested #{total_cpu_in_request} > Quota #{max_group_cpu}"
      end
    end

    ##########################
    #
    # Group Memory Quota Check
    #
    ##########################
    $evm.log("info","#{@method} - Beginning Group Memory Quota Check") if @debug
    $evm.log("info", "#{@method} - Group: <#{group.description}> current Memory usage: <#{quota_group[:memory]}>") if @debug

    max_group_memory   = nil
    g_quota_exceeded_reason2 = nil

    # Use value from model unless specified above
    max_group_memory ||= $evm.object['max_group_memory']
    unless max_group_memory.nil?
      $evm.log("info","#{@method} - Found quota from model <max_group_memory> with value:<#{max_group_memory}>") if @debug
    end

    # Get tag from Group
    tag_max_group_memory = group.tags(:quota_max_memory).first
    unless tag_max_group_memory.nil?
      $evm.log("info","#{@method} - Found quota from group <#{group.description}> tag <quota_max_memory> with value <#{tag_max_group_memory}>")  if @debug
    end

    # If group is tagged then override
    unless tag_max_group_memory.nil?
      max_group_memory = tag_max_group_memory.to_i
      $evm.log("info","#{@method} - Overriding quota from group <#{group.description}> tag <quota_max_memory> with value <#{tag_max_group_memory}>") if @debug
    end

    # Validate Group Memory Quota
    unless max_group_memory.blank?
      if quota_group && (quota_group[:memory] + total_memory_in_request > max_group_memory.to_i)
        $evm.log("info", "#{@method} - Memory allocated for Group <#{quota_group[:memory]}> +  Requested Memory <#{total_memory_in_request}> exceeds Quota Max <#{max_group_memory}>") if @debug
        quota_exceeded = true
        g_mem_total_nice = "%.2fGB" % (quota_group[:memory] / 1024)
        g_mem_quota_nice = "%.2fGB" % (max_group_memory.to_i / 1024)
        g_quota_exceeded_reason2 = "Group Allocated Memory #{g_mem_total_nice} + Requested #{total_memory_nice} > Quota #{g_mem_quota_nice}"
      end
    end



    ##########################
    #
    # Group Storage Quota Check
    #
    ##########################
    $evm.log("info","#{@method} - Beginning Group Storage Quota Check") if @debug
    $evm.log("info", "#{@method} - Group: <#{group.description}> current Storage usage: <#{quota_group[:allocated_storage]}>") if @debug

    max_group_storage   = nil
    g_quota_exceeded_reason3 = nil

    # Use value from model unless specified above
    max_group_storage ||= $evm.object['max_group_storage']
    unless max_group_storage.nil?
      $evm.log("info","#{@method} - Found quota from model <max_group_storage> with value:<#{max_group_storage}GB>")  if @debug
    end

    # Get tag from Group
    tag_max_group_storage = group.tags(:quota_max_storage).first
    unless tag_max_group_storage.nil?
      $evm.log("info","#{@method} - Found quota from group <#{group.description}> tag <quota_max_storage> with value <#{tag_max_group_storage}>") if @debug
    end

    # If group is tagged then override
    unless tag_max_group_storage.nil?
      max_group_storage = tag_max_group_storage.to_i
      $evm.log("info","#{@method} - Overriding quota from Group <#{group.description}> tag <quota_max_storage> with value <#{tag_max_group_storage}GB> or <#{tag_max_group_storage.to_i * (1024**3)} bytes>") if @debug
    end

    # Validate Group Storage Quota
    unless max_group_storage.blank?
      max_group_storage = max_group_storage.to_i
      if quota_group && (quota_group[:allocated_storage] + vm_size > max_group_storage.to_i * (1024**3))
        $evm.log("info", "#{@method} - Storage allocated for Group <#{quota_group[:allocated_storage]}> +  Requested Storage <#{vm_size}> exceeds Quota Max <#{max_group_storage}>") if @debug
        quota_exceeded = true
        g_stor_total_nice = "%.2fGB" % (quota_group[:allocated_storage] / 1024**3)
        g_stor_quota_nice = "%.2fGB" % (max_group_storage)
        g_quota_exceeded_reason3 = "Group Allocated Storage #{g_stor_total_nice} + Requested #{total_storage_nice} > Quota #{g_stor_quota_nice}"
      end
    end

  else
    # Available check_quota methods [:vms_by_owner, :vms_by_owner_and_group]
    quota_owner = miq_provision_request.check_quota(:vms_by_owner, {:include_retired_vms => false})
    $evm.log("info","#{@method} - Inspecting quota_owner:<#{quota_owner.inspect}>") if @debug

    ##########################
    #
    # Owner CPU Quota Check
    #
    ##########################
    $evm.log("info","#{@method} - Beginning Owner CPU Quota Check") if @debug
    $evm.log("info", "#{@method} - Owner: <#{user.name}> current CPU usage: <#{quota_owner[:cpu]}>") if @debug

    max_owner_cpu   = nil
    o_quota_exceeded_reason1 = nil

    # Use value from model unless specified above
    max_owner_cpu ||= $evm.object['max_owner_cpu']
    unless max_owner_cpu.nil?
      $evm.log("info","#{@method} - Found quota from model <max_owner_cpu> with value:<#{max_owner_cpu}>") if @debug
    end

    # Get tag from Owner
    tag_max_owner_cpu = user.tags(:quota_max_cpu).first
    unless tag_max_owner_cpu.nil?
      $evm.log("info","#{@method} - Found quota from user <#{user.name}> tag <quota_max_cpu> with value <#{tag_max_owner_cpu}>>") if @debug
    end

    # If owner is tagged then override
    unless tag_max_owner_cpu.nil?
      max_owner_cpu = tag_max_owner_cpu.to_i
      $evm.log("info","#{@method} - Overriding quota from User <#{user.name}> tag <quota_max_cpu> with value <#{tag_max_owner_cpu}>") if @debug
    end

    # Validate Owner CPU Quota
    unless max_owner_cpu.blank?
      if quota_owner && (quota_owner[:cpu] + total_cpu_in_request > max_owner_cpu.to_i)
        $evm.log("info", "#{@method} - CPUs allocated for Owner <#{quota_owner[:cpu]}> +  Requested CPUs <#{total_cpu_in_request}> exceeds Quota Max <#{max_owner_cpu}>") if @debug
        quota_exceeded = true
        o_total_vcpus = quota_owner[:cpu]
        o_quota_exceeded_reason1 = "Owner Allocated vCPUs #{o_total_vcpus} + Requested #{total_cpu_in_request} > Quota #{max_owner_cpu}"
      end
    end



    ##########################
    #
    # Owner Memory Quota Check
    #
    ##########################
    $evm.log("info","#{@method} - Beginning Owner Memory Quota Check") if @debug
    $evm.log("info", "#{@method} - Owner: <#{user.name}> current Memory usage: <#{quota_owner[:memory]}>") if @debug

    max_owner_memory   = nil
    o_quota_exceeded_reason2 = nil

    # Use value from model unless specified above
    max_owner_memory ||= $evm.object['max_owner_memory']
    unless max_owner_memory.nil?
      $evm.log("info","#{@method} - Found quota from model <max_owner_memory> with value:<#{max_owner_memory}>") if @debug
    end

    # Get tag from Owner
    tag_max_owner_memory = user.tags(:quota_max_memory).first
    unless tag_max_owner_memory.nil?
      $evm.log("info","#{@method} - Found quota from user <#{user.name}> tag <quota_max_memory> with value <#{tag_max_owner_memory}>") if @debug
    end

    # If owner is tagged then override
    unless tag_max_owner_memory.nil?
      max_owner_memory = tag_max_owner_memory.to_i
      $evm.log("info","#{@method} - Overriding quota from User <#{user.name}> tag <quota_max_memory> with value <#{tag_max_owner_memory}>") if @debug
    end

    # Validate Owner Memory Quota
    unless max_owner_memory.blank?
      if quota_owner && (quota_owner[:memory] + total_memory_in_request > max_owner_memory.to_i)
        $evm.log("info", "#{@method} - Memory allocated for Owner <#{quota_owner[:memory]}> +  Requested Memory <#{total_memory_in_request}> exceeds Quota Max <#{max_owner_memory}>") if @debug
        quota_exceeded = true
        o_mem_total_nice = "%.2fGB" % (quota_owner[:memory] / 1024)
        o_mem_quota_nice = "%.2fGB" % (max_owner_memory.to_i / 1024)
        o_quota_exceeded_reason2 = "Owner Allocated Memory #{o_mem_total_nice} + Requested #{total_memory_nice} > Quota #{o_mem_quota_nice}"
      end
    end


    ##########################
    #
    # Owner Storage Quota Check
    #
    ##########################
    $evm.log("info","#{@method} - Beginning Owner Storage Quota Check") if @debug
    $evm.log("info", "#{@method} - Owner: <#{user.name}> current Storage usage: <#{quota_owner[:allocated_storage]}>") if @debug

    max_owner_storage   = nil
    o_quota_exceeded_reason3 = nil

    # Use value from model unless specified above
    max_owner_storage ||= $evm.object['max_owner_storage']
    unless max_owner_storage.nil?
      $evm.log("info","#{@method} - Found quota from model <max_owner_storage> with value:<#{max_owner_storage}GB>") if @debug
    end

    # Get tag from Owner
    tag_max_owner_storage = user.tags(:quota_max_storage).first
    unless tag_max_owner_storage.nil?
      $evm.log("info","#{@method} - Found quota from user <#{user.name}> tag <quota_max_storage> with value <#{tag_max_owner_storage}GB> or <#{tag_max_group_storage * (1024**3)} bytes>") if @debug
    end

    # If owner is tagged then override
    unless tag_max_owner_storage.nil?
      max_owner_storage = tag_max_owner_storage.to_i
      $evm.log("info","#{@method} - Overriding quota from User <#{user.name}> tag <quota_max_storage> with value <#{tag_max_owner_storage}GB>") if @debug
    end

    # Validate Owner Storage Quota
    unless max_owner_storage.blank?
      max_owner_storage = max_owner_storage.to_i
      if quota_owner && (quota_owner[:allocated_storage] + vm_size > max_owner_storage.to_i * (1024**3))
        $evm.log("info", "#{@method} - Storage allocated for Owner <#{quota_owner[:allocated_storage]}> +  Requested Storage <#{vm_size}> exceeds Quota Max <#{max_owner_storage}>") if @debug
        quota_exceeded = true
        o_stor_total_nice = "%.2fGB" % (quota_owner[:allocated_storage] / 1024**3)
        o_stor_quota_nice = "%.2fGB" % (max_owner_storage)
        o_quota_exceeded_reason3 = "Owner Allocated Storage #{o_stor_total_nice} + Requested #{total_storage_nice} > Quota #{o_stor_quota_nice}"
      end
    end
  end


  ##########################
  #
  # Quota Exceeded Check
  #
  ##########################
  if quota_exceeded == true
    msg = ""
    #msg +=  "VMs cannot be provisioned at this time due to the following quota limits: "
    msg +=  "Request denied due to the following quota limits:"
    msg += "(#{g_quota_exceeded_reason1}) " unless g_quota_exceeded_reason1.nil?
    msg += "(#{g_quota_exceeded_reason2}) " unless g_quota_exceeded_reason2.nil?
    msg += "(#{g_quota_exceeded_reason3})" unless g_quota_exceeded_reason3.nil?
    msg += "(#{o_quota_exceeded_reason1}) " unless o_quota_exceeded_reason1.nil?
    msg += "(#{o_quota_exceeded_reason2}) " unless o_quota_exceeded_reason2.nil?
    msg += "(#{o_quota_exceeded_reason3})" unless o_quota_exceeded_reason3.nil?
    $evm.log("info","#{@method} - Inspecting Messge:<#{msg}>") if @debug

    miq_provision_request.set_message(msg)

    $evm.root['ae_result'] = 'error'
    $evm.object['reason']  = msg
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="max_owner_cpu" substitute="true" aetype="attribute" display_name="Owner - Max CPUs Allowed" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="max_owner_memory" substitute="true" aetype="attribute" display_name="Owner - Max Memory Allowed (MB)" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="max_owner_storage" substitute="true" aetype="attribute" display_name="Owner - Max Storage Allowed (GB)" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="max_group_cpu" substitute="true" aetype="attribute" display_name="Group - Max CPUs Allowed" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="max_group_memory" substitute="true" aetype="attribute" display_name="Group - Max Memory Allowed (MB)" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="max_group_storage" substitute="true" aetype="attribute" display_name="Group - Max Storage Allowed (GB)" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="ValidateQuotas" substitute="true" aetype="state" datatype="string" priority="7" message="create" on_entry="validate_quotas" on_error="rejected" max_retries="100">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Default" display_name="Default">
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ServiceProvisionRequestApproval" namespace="Factory/StateMachines" display_name="Service Provision Request Approval">
    <MiqAeMethod name="approve_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: approve_request
#
# This method is executed when the provisioning request is auto-approved
#
###################################
begin
  @method = 'approve_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Auto-Approve request
  $evm.log("info", "#{@method} - AUTO-APPROVING") if @debug
  $evm.root["miq_request"].approve("admin", "Auto-Approved")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK
 
  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="pending_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: pending_request
#
# Notes: This method is executed when the provisioning request is NOT auto-approved
#
###################################
begin
  @method = 'pending_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get objects
  provision_request = $evm.root['miq_request'].resource
  msg = $evm.object['reason']
  $evm.log('info',"#{@method} - #{msg}") if @debug


  # execute email method to notify the requester
  #$evm.instantiate("/Alert/EmailNotifications/request_pending?reason=>#{msg}")


  # Raise automation event: request_pending
  $evm.root["miq_request"].pending


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="validate_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: validate_request
#
# 
###################################
begin
  @method = 'validate_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of debugging
  @debug = true


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="ValidateRequest" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="validate_request" on_error="pending_request" max_retries="100">
      </MiqAeField>
      <MiqAeField name="ApproveRequest" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="approve_request" on_error="pending_request" max_retries="100">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Default" display_name="Default">
      <MiqAeField name="ValidateRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ApproveRequest">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ServiceProvision_Template" namespace="Factory/StateMachines" description="Service Provision State Machine" display_name="Service Provision State Machine">
    <MiqAeMethod name="update_serviceprovision_status" language="ruby" scope="instance" location="inline" display_name="update_serviceprovision_status"><![CDATA[###################################
#
# EVM Automate Method: update_serviceprovision_status
#
# Notes: This method updates the service provisioning status
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_serviceprovision_status'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  $evm.log("info", "===========================================")
  $evm.log("info", "Listing ROOT Attributes:")
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")}
  $evm.log("info", "===========================================")

  prov    = $evm.root['service_template_provision_task']

  # Get provisioning type [template, clone_to_vm or clone_to_template]
  prov_type = prov.request_type

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']


  ###################################
  #
  # Update Status for on_entry,on_exit
  #
  ###################################
  if $evm.root['ae_result'] == 'ok'

    # Check to see if provisioning is complete
    if status == 'provision_complete'
      message      = 'Service Provisioned Successfully'
      prov.finished(message)
    end
    prov.message = status
  end

  ###################################
  #
  # Update Status for on_error
  #
  ###################################
  if $evm.root['ae_result'] == 'error'
    prov.message = status
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>      <MiqAeField name="status" substitute="true" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="status_state" substitute="true" priority="2" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="pre1" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_serviceprovision_status(status =&gt; 'pre1',status_state =&gt; 'on_entry')" on_exit="update_serviceprovision_status(status =&gt; 'pre1',status_state =&gt; 'on_exit')" on_error="update_serviceprovision_status(status =&gt; 'error in pre1',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="pre2" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_serviceprovision_status(status =&gt; 'pre2',status_state =&gt; 'on_entry')" on_exit="update_serviceprovision_status(status =&gt; 'pre2',status_state =&gt; 'on_exit')" on_error="update_serviceprovision_status(status =&gt; 'error in pre2',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="configurechilddialog" substitute="true" aetype="state" datatype="string" priority="3" message="create">
#/Factory/Service/ConfigureChildDialog      </MiqAeField>
      <MiqAeField name="provision" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_serviceprovision_status(status =&gt; 'Creating Service',status_state =&gt; 'on_entry')" on_exit="update_serviceprovision_status(status =&gt; 'Creating Service',status_state =&gt; 'on_exit')" on_error="update_serviceprovision_status(status =&gt; 'error in Cloning Service',status_state =&gt; 'on_error')" max_retries="100">
/Factory/Service/Provision      </MiqAeField>
      <MiqAeField name="checkprovisioned" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_exit="update_serviceprovision_status(status =&gt; 'Cloning Service',status_state =&gt; 'on_exit')" on_error="update_serviceprovision_status(status =&gt; '${/#ae_reason}',status_state =&gt; 'on_error')" max_retries="100">
/Factory/Service/CheckProvisioned      </MiqAeField>
      <MiqAeField name="post1" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="update_serviceprovision_status(status =&gt; 'Applying Post1 Customizations',status_state =&gt; 'on_entry')" on_exit="update_serviceprovision_status(status =&gt; 'Applied Post1 Customizations',status_state =&gt; 'on_exit')" on_error="update_serviceprovision_status(status =&gt; 'error in Applying Post1 Customizations',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="post2" substitute="true" aetype="state" datatype="string" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="post3" substitute="true" aetype="state" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="EmailOwner" substitute="true" aetype="state" datatype="string" priority="9" message="create" on_entry="update_serviceprovision_status(status =&gt; 'Emailing Owner',status_state =&gt; 'on_entry')" on_exit="update_serviceprovision_status(status =&gt; 'service_provision_complete',status_state =&gt; 'on_exit')" on_error="update_serviceprovision_status(status =&gt; 'error in Emailing Owner',status_state =&gt; 'on_error')" max_retries="100">
/Alert/EmailNotifications/ServiceProvision_complete?event=service_provisioned      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="CatalogBundleInitialization">
      <MiqAeField name="pre1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre2">
/Factory/Service/CatalogBundleInitialization      </MiqAeField>
      <MiqAeField name="configurechilddialog">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="checkprovisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CatalogItemInitialization">
      <MiqAeField name="pre1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre2">
/Factory/Service/CatalogItemInitialization      </MiqAeField>
      <MiqAeField name="configurechilddialog">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="checkprovisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="clone_to_service" display_name="clone_to_service" description="clone_to_service">
      <MiqAeField name="pre1">
/Factory/Service/GroupSequenceCheck      </MiqAeField>
      <MiqAeField name="pre2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="configurechilddialog">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="checkprovisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="default" display_name="default" description="default">
      <MiqAeField name="pre1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="configurechilddialog">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="checkprovisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="post3">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="ServiceRetirement" namespace="Factory/StateMachines" display_name="Service Retirement State Machine">
    <MiqAeMethod name="update_service_retirement_status" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: update_service_retirement_status
#
# Notes: This method updates retirement status
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_service_retirement_status'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get vm from root
  service = $evm.root['service']

  # Get variables from Server object
  server = $evm.root['miq_server']

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']

  $evm.log("info", "#{@method} - Server:<#{server.name}> Ae_Result:<#{$evm.root['ae_result']}> State:<#{state}> Step:<#{step}> Status_State:<#{status_state}> Status:<#{status}>")


  ###################################
  #
  # Update Status for on_entry,on_exit
  #
  ###################################
  if $evm.root['ae_result'] == 'ok'

  end


  ###################################
  #
  # Update Status for on_error
  #
  ###################################
  if $evm.root['ae_result'] == 'error'

  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="pre1" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_service_retirement_status(status =&gt; 'pre1',status_state =&gt; 'on_entry')" on_exit="update_service_retirement_status(status =&gt; 'pre1',status_state =&gt; 'on_exit')" on_error="update_service_retirement_status(status =&gt; 'pre1',status_state =&gt; 'on_error')" max_retries="3">
      </MiqAeField>
      <MiqAeField name="pre2" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_service_retirement_status(status =&gt; 'pre2',status_state =&gt; 'on_entry')" on_exit="update_service_retirement_status(status =&gt; 'pre2',status_state =&gt; 'on_exit')" on_error="update_service_retirement_status(status =&gt; 'pre2',status_state =&gt; 'on_error')" max_retries="3">
      </MiqAeField>
      <MiqAeField name="retireservicevms" substitute="true" aetype="state" datatype="string" priority="3" message="create" on_entry="update_service_retirement_status(status =&gt; 'Retiring Service Vms',status_state =&gt; 'on_entry')" on_exit="update_service_retirement_status(status =&gt; 'Retiring Service VMs',status_state =&gt; 'on_exit')" on_error="update_service_retirement_status(status =&gt; 'Retiring Service Vms',status_state =&gt; 'on_error')" max_retries="3">
      </MiqAeField>
      <MiqAeField name="checkservicevmretirement" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_service_retirement_status(status =&gt; 'Checking Service VM retirement',status_state =&gt; 'on_entry')update_service_retirement_status(status =&gt; 'Removing Service from VMDB',status_state =&gt; 'on_entry')" on_exit="update_service_retirement_status(status =&gt; 'Checking Service VM retirement',status_state =&gt; 'on_exit')" on_error="update_service_retirement_status(status =&gt; 'Checking Service VM retirement',status_state =&gt; 'on_error')" max_retries="3">
      </MiqAeField>
      <MiqAeField name="markserviceasretired" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_entry="update_service_retirement_status(status =&gt; 'Marking Service as retired',status_state =&gt; 'on_entry')" on_exit="update_service_retirement_status(status =&gt; 'Marking Service as retired',status_state =&gt; 'on_exit')" on_error="update_service_retirement_status(status =&gt; 'Marking Service as retired',status_state =&gt; 'on_error')" max_retries="3">
      </MiqAeField>
      <MiqAeField name="deleteservicefromVMDB" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="update_service_retirement_status(status =&gt; 'Deleting Retired Service from VMDB',status_state =&gt; 'on_entry')" on_exit="update_service_retirement_status(status =&gt; 'Deleting Retired Service from VMDB',status_state =&gt; 'on_exit')" on_error="update_service_retirement_status(status =&gt; 'Deleting Retired Service from VMDB',status_state =&gt; 'on_error')" max_retries="3">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Default" display_name="Default">
      <MiqAeField name="pre1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="pre2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="retireservicevms">
#/Factory/Service/retireservicevms      </MiqAeField>
      <MiqAeField name="checkservicevmretirement">
/Factory/Service/checkservicevmretirement      </MiqAeField>
      <MiqAeField name="markserviceasretired">
#/Factory/Service/markserviceasretired      </MiqAeField>
      <MiqAeField name="deleteservicefromVMDB">
#/Factory/Service/DeleteFromVMDB      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VMMigrate" namespace="Factory/StateMachines" description="Factory State Machines" display_name="VM Migration State Machine">
    <MiqAeMethod name="update_migration_status" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: update_migration_status
#
# Notes: This method updates migration status and calls Service Now if applicable
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_migration_status'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Initialize variables
  #
  miq_task = $evm.root['vm_migrate_task']
  miq_task_id     = miq_task['id']

  # Get variables from Server object
  server = $evm.root['miq_server']
  evm_ipaddr    = server.ipaddress
  evm_hostname  = server.hostname
  evm_region    = server.region_number

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']


  ###################################
  #
  # Update Status for on_entry,on_exit
  #
  ###################################
  if $evm.root['ae_result'] == 'ok'

    # Check to see if provisioning is complete
    if status == 'migration_complete'
      message = 'VM Migrated Successfully'
      miq_task.finished(message)
    end
    miq_task.message = status
  end


  ###################################
  #
  # Update Status for on_error
  #
  ###################################
  if $evm.root['ae_result'] == 'error'
    miq_task.message = status
  end


  ###################################
  #
  # Call Service-Now
  #
  ###################################
  if miq_task.options.has_key?(:ws_values)
    ws_values  = miq_task.options[:ws_values]

    # Set request_id from Service-Now unless nil set to provisioning id
    request_id = ws_values[:request_id] || ws_values[:requestid] || miq_task_id
    item_id    = ws_values[:item_id]    || ws_values[:itemid] || miq_task_id
    friendly_itemid = ws_values[:friendly_itemid]

    $evm.log("info","RequestID: <#{request_id}>") if @debug
    $evm.log("info","ItemID: <#{item_id}>") if @debug
    $evm.log("info","Friendly ItemID: <#{friendly_itemid}>") if @debug

    unless request_id.nil? || item_id.nil?

      message = status_state
      # state_retries = $evm.root['ae_state_retries'] || 0

      agent         = "EVM Automate Migration"
      topic         = "Item:#{friendly_itemid} | EVM:#{miq_task_id} | StateMachine:#{state}"
      name          = "Step:#{step} | State:#{status_state}"
      source        = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

      require 'uri'
      args = "agent=#{agent}&topic=#{topic}&source=#{source}&name=#{name}&id=#{miq_task_id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      #args = "topic=#{topic}&id=#{id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      args = URI.escape(args)

      $evm.log("info","Calling Service-Now with arguments: #{args}")
      $evm.instantiate("/Factory/ServiceNow/eccq_insert1?#{args}")
    end
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>      <MiqAeField name="status_state" substitute="true" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="status" substitute="true" priority="2" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="CustomizeRequest" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_migration_status(status =&gt; 'Customizing Request',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Customized Request',status_state =&gt; 'on_error')" on_error="update_migration_status(status =&gt; 'error in Customizing Request',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/CustomizeRequest      </MiqAeField>
      <MiqAeField name="BestHost" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_migration_status(status =&gt; 'Determining Best Host',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Determined Best Host',status_state =&gt; 'on_error')" on_error="update_migration_status(status =&gt; 'error in Best Host',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/BestHost      </MiqAeField>
      <MiqAeField name="BestStorage" substitute="true" aetype="state" datatype="string" priority="3" message="create" on_entry="update_migration_status(status =&gt; 'Determining Best Storage',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Determined Best Storage',status_state =&gt; 'on_error')" on_error="update_migration_status(status =&gt; 'error in Best Storage',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/BestStorage      </MiqAeField>
      <MiqAeField name="PreMigration" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_migration_status(status =&gt; 'Applying PreMigration Customizations',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Applied PreMigration Customizations',status_state =&gt; 'on_exit')" on_error="update_migration_status(status =&gt; 'error in Applying PreMigration Customizations',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/PreMigration      </MiqAeField>
      <MiqAeField name="Migrate" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_entry="update_migration_status(status =&gt; 'Migrating VM',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Migrated VM',status_state =&gt; 'on_exit')" on_error="update_migration_status(status =&gt; 'error in Migrating VM',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/Migrate      </MiqAeField>
      <MiqAeField name="CheckMigration" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_exit="update_migration_status(status =&gt; 'Migrating VM',status_state =&gt; 'on_exit')" on_error="update_migration_status(status =&gt; '${/#ae_reason}',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/CheckMigration      </MiqAeField>
      <MiqAeField name="PostMigration" substitute="true" aetype="state" datatype="string" priority="7" message="create" on_entry="update_migration_status(status =&gt; 'Applying PostMigration Customizations',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Applied PostMigration Customizations',status_state =&gt; 'on_exit')" on_error="update_migration_status(status =&gt; 'error in Applying PostMigration Customizations',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VMMigrate/PostMigration      </MiqAeField>
      <MiqAeField name="ActivateCMDB" substitute="true" aetype="state" datatype="string" priority="8" message="create" on_entry="update_migration_status(status =&gt; 'Activating CMDB',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'Activated CMDB',status_state =&gt; 'on_exit')" on_error="update_migration_status(status =&gt; 'error in Activating CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="EmailOwner" substitute="true" aetype="state" datatype="string" priority="9" message="create" on_entry="update_migration_status(status =&gt; 'Emailing Owner',status_state =&gt; 'on_entry')" on_exit="update_migration_status(status =&gt; 'migration_complete',status_state =&gt; 'on_exit')" on_error="update_migration_status(status =&gt; 'error in Emailing Owner',status_state =&gt; 'on_error')" max_retries="100">
/Alert/EmailNotifications/vm_migration_complete?event=vm_migrated      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="default">
      <MiqAeField name="CustomizeRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="BestHost">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="BestStorage">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PreMigration">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Migrate">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="CheckMigration">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PostMigration">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ActivateCMDB">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
/Alert/EmailNotifications/VmMigrateTask_Complete      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VMProvision_Template" namespace="Factory/StateMachines" description="Factory State Machines" display_name="VM Provision State Machine">
    <MiqAeMethod name="update_provision_status" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: update_provision_status
#
# Notes: This method updates provisioning status and calls Service Now if applicable
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_provision_status'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Initialize variables
  #
  prov   = $evm.root['miq_provision']
  prov_id     = prov['id']

  # Get variables from Server object
  server = $evm.root['miq_server']
  evm_ipaddr    = server.ipaddress
  evm_hostname  = server.hostname
  evm_region    = server.region_number

  # Get provisioning type [template, clone_to_vm or clone_to_template]
  prov_type = prov.provision_type

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']


  ###################################
  #
  # Update Status for on_entry,on_exit
  #
  ###################################
  if $evm.root['ae_result'] == 'ok'

    # Check to see if provisioning is complete
    if status == 'provision_complete'
      message      = 'VM Provisioned Successfully'
      prov.finished(message)
    end
    prov.message = status
  end


  ###################################
  #
  # Update Status for on_error
  #
  ###################################
  if $evm.root['ae_result'] == 'error'
    prov.message = status
  end


  ###################################
  #
  # Call Service-Now
  #
  ###################################
  if prov.options.has_key?(:ws_values)
    ws_values  = prov.options[:ws_values]

    # Set request_id from Service-Now unless nil set to provisioning id
    request_id = ws_values[:request_id] || ws_values[:requestid] || prov_id
    item_id    = ws_values[:item_id]    || ws_values[:itemid] || prov_id
    friendly_itemid = ws_values[:friendly_itemid]

    $evm.log("info","RequestID: <#{request_id}>") if @debug
    $evm.log("info","ItemID: <#{item_id}>") if @debug
    $evm.log("info","Friendly ItemID: <#{friendly_itemid}>") if @debug

    unless request_id.nil? || item_id.nil?

      message = status_state
      # state_retries = $evm.root['ae_state_retries'] || 0

      agent         = "EVM Automate Provisioning"
      topic         = "Item:#{friendly_itemid} | EVM:#{prov_id} | StateMachine:#{state}"
      name          = "Step:#{step} | State:#{status_state}"
      source        = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

      require 'uri'
      args = "agent=#{agent}&topic=#{topic}&source=#{source}&name=#{name}&id=#{prov_id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      #args = "topic=#{topic}&id=#{id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      args = URI.escape(args)

      $evm.log("info","Calling Service-Now with arguments: #{args}")
      $evm.instantiate("/Factory/ServiceNow/eccq_insert1?#{args}")
    end
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>      <MiqAeField name="status_state" substitute="true" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="status" substitute="true" priority="2" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="CustomizeRequest" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_provision_status(status =&gt; 'Customizing Request',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Customized Request',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Customizing Request',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/CustomizeRequest      </MiqAeField>
      <MiqAeField name="RegisterCMDB" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_provision_status(status =&gt; 'Registering CMDB',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered CMDB',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="PreProvision" substitute="true" aetype="state" datatype="string" priority="3" message="create" on_entry="update_provision_status(status =&gt; 'Applying PreProvision Customizations',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Applied PreProvision Customizations',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Applying PreProvision Customizations',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/PreProvision_Clone_to_Template      </MiqAeField>
      <MiqAeField name="Provision" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_provision_status(status =&gt; 'Creating VM',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Creating VM',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Cloning VM',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/Provision      </MiqAeField>
      <MiqAeField name="CheckProvisioned" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_exit="update_provision_status(status =&gt; 'Cloning VM',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; '${/#ae_reason}',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/CheckProvisioned      </MiqAeField>
      <MiqAeField name="PostProvision" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="update_provision_status(status =&gt; 'Applying PostProvision Customizations',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Applied PostProvision Customizations',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Applying PostProvision Customizations',status_state =&gt; 'on_error')">
      </MiqAeField>
      <MiqAeField name="ActivateCMDB" substitute="true" aetype="state" datatype="string" priority="7" message="create" on_entry="update_provision_status(status =&gt; 'Activating CMDB',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Activated CMDB',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Activating CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="EmailOwner" substitute="true" aetype="state" datatype="string" priority="8" message="create" on_entry="update_provision_status(status =&gt; 'Emailing Owner',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'provision_complete',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Emailing Owner',status_state =&gt; 'on_error')" max_retries="100">
/Alert/EmailNotifications/MiqProvision_complete?event=template_provisioned      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="clone_to_template" display_name="Clone VM to Template">
      <MiqAeField name="CustomizeRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="RegisterCMDB">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PreProvision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="CheckProvisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PostProvision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ActivateCMDB">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VMProvision_VM" namespace="Factory/StateMachines" description="Factory State Machines" display_name="VM Provision State Machine">
    <MiqAeMethod name="update_provision_status" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: update_provision_status
#
# Notes: This method updates provisioning status and calls Service-Now/Remedy if applicable
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_provision_status'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: call_servicenow
  #
  ###################################
  def call_servicenow(prov, ws_values, server, state, step, status, status_state)

    # Set request_id from Service-Now unless nil set to provisioning id
    request_id = ws_values[:request_id] || ws_values[:requestid] || prov['id']
    item_id    = ws_values[:item_id]    || ws_values[:itemid] || prov['id']
    friendly_itemid = ws_values[:friendly_itemid]

    $evm.log("info","#{@method} - RequestID:<#{request_id}> ItemID:<#{item_id}> Friendly ItemID:<#{friendly_itemid}>") if @debug

    unless request_id.nil? || item_id.nil?

      message = status_state
      # state_retries = $evm.root['ae_state_retries'] || 0

      agent         = "EVM Automate Provisioning"
      topic         = "Item:#{friendly_itemid} | EVM:#{prov['id']} | StateMachine:#{state}"
      name          = "Step:#{step} | State:#{status_state}"
      source        = "EVM Region:#{server.region_number} | Hostname:#{server.hostname} | IP:#{server.ipaddress}"

      require 'uri'
      args = "agent=#{agent}&topic=#{topic}&source=#{source}&name=#{name}&id=#{prov['id']}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      #args = "topic=#{topic}&id=#{id}&request_id=#{request_id}&item_id=#{item_id}&message=#{message}&step=#{step}&status=#{status}"
      args = URI.escape(args)

      $evm.log("info","#{@method} - Calling Service-Now with arguments: #{args}")
      $evm.instantiate("/Factory/ServiceNow/eccq_insert1?#{args}")
    end
  end


  ####################################
  #
  # Method: call_remedy
  #
  ####################################
  def call_remedy(prov, ws_values, server, state, step, status, status_state)
    parent_id = ws_values[:parent_id]
    $evm.log("info","#{@method} - Parent_ID:<#{parent_id}>") if @debug

    unless parent_id.nil?
      comment         =  "#{prov.get_option(:vm_target_name)} - #{status}"
      $evm.log("info","#{@method} - Step:<#{step}>") if @debug


      # Build provisioning object hash prov[:submitComments] that contains comments
      $evm.log("info","#{@method} - Building provisioning object hash prov['submit_comments'] that contains comments") if @debug
      prov['submit_comments'] = {
        :comment => comment,
        :subject => 'Status Update',
        :submitter => 'EVM',
        :parent_id => parent_id
      }

      $evm.log("info","#{@method} - Calling Remedy_SubmitComment with the following parameters:<#{prov['submit_comments'].inspect}>") if @debug
      $evm.instantiate("/Integration/Remedy/Remedy_SubmitComment")

      # Reset submitComments Hash
      prov['submit_comments'] = {}
    end
  end


  ###################################
  #
  # Method: boolean
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  # Initialize variables
  prov   = $evm.root['miq_provision']

  # Set servicenow to true to always post status to service-now
  servicenow = false

  # Set remedy to true to always post status to service-now
  remedy = false

  # Get variables from Server object
  server = $evm.root['miq_server']

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']

  $evm.log("info", "#{@method} - Server:<#{server.name}> Ae_Result:<#{$evm.root['ae_result']}> State:<#{state}> Step:<#{step}> Status_State:<#{status_state}> Status:<#{status}>")

  # Update Status for on_entry,on_exit
  if $evm.root['ae_result'] == 'ok'

    # Check to see if provisioning is complete
    if status == 'provision_complete'
      message      = 'VM Provisioned Successfully'
      prov.finished(message)
    end
    prov.message = status
  end


  # Update Status for on_error
  if $evm.root['ae_result'] == 'error'
    prov.message = status
  end


  # Call external services to post status
  if prov.options.has_key?(:ws_values)
    ws_values  = prov.options[:ws_values]

    # Check if ws_values[:servicenow] is set to true
    if boolean(ws_values[:servicenow]) || servicenow
      call_servicenow(prov, ws_values, server, state, step, status, status_state)
    end

    # Check if ws_values[:remedy] is set to true
    if boolean(ws_values[:remedy]) || remedy
      call_remedy(prov, ws_values, server, state, step, status, status_state)
    end
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>      <MiqAeField name="status_state" substitute="true" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="status" substitute="true" priority="2" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="CustomizeRequest" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_provision_status(status =&gt; 'Customizing Request',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Customized Request',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Customizing Request',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/CustomizeRequest      </MiqAeField>
      <MiqAeField name="AcquireIPAddress" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_provision_status(status =&gt; 'Acquiring IP Address',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Acquired IP Address',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Acquiring IP Address',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="AcquireMACAddress" substitute="true" aetype="state" datatype="string" priority="3" message="create" on_entry="update_provision_status(status =&gt; 'Acquiring MAC Address',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Acquired MAC Address',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Acquiring MAC Address',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="RegisterDNS" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_provision_status(status =&gt; 'Registering DNS',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered DNS',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering DNS',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="RegisterCMDB" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_entry="update_provision_status(status =&gt; 'Registering CMDB',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered CMDB',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="RegisterAD" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="update_provision_status(status =&gt; 'Registering ActiveDirectory',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered ActiveDirectory',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering ActiveDirectory',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="PreProvision" substitute="true" aetype="state" datatype="string" priority="7" message="create" on_entry="update_provision_status(status =&gt; 'Applying PreProvision Customizations',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Applied PreProvision Customizations',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Applying PreProvision Customizations',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/PreProvision      </MiqAeField>
      <MiqAeField name="Provision" substitute="true" aetype="state" datatype="string" priority="8" message="create" on_entry="update_provision_status(status =&gt; 'Creating VM',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Creating VM',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Cloning VM',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/Provision      </MiqAeField>
      <MiqAeField name="CheckProvisioned" substitute="true" aetype="state" datatype="string" priority="9" message="create" on_exit="update_provision_status(status =&gt; 'Cloning VM',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; '${/#ae_reason}',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/CheckProvisioned      </MiqAeField>
      <MiqAeField name="PostProvision" substitute="true" aetype="state" datatype="string" priority="10" message="create" on_entry="update_provision_status(status =&gt; 'Applying PostProvision Customizations',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Applied PostProvision Customizations',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Applying PostProvision Customizations',status_state =&gt; 'on_error')">
/Factory/VM/PostProvision      </MiqAeField>
      <MiqAeField name="RegisterDHCP" substitute="true" aetype="state" datatype="string" priority="11" message="create" on_entry="update_provision_status(status =&gt; 'Registering DHCP',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Registered DHCP',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Registering DHCP',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="ActivateCMDB" substitute="true" aetype="state" datatype="string" priority="12" message="create" on_entry="update_provision_status(status =&gt; 'Activating CMDB',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'Activated CMDB',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Activating CMDB',status_state =&gt; 'on_error')" max_retries="100">
      </MiqAeField>
      <MiqAeField name="VDIWaitForHostname" substitute="true" aetype="state" datatype="string" priority="13" message="create" on_entry="update_provision_status(status =&gt; 'VDI: Waiting for Hostname',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'VDI: Retrieved Hostname',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in VDI: Wait for hostname',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/VdiWaitForHostname      </MiqAeField>
      <MiqAeField name="VDIAddVmToDesktopPool" substitute="true" aetype="state" datatype="string" priority="14" message="create" on_entry="update_provision_status(status =&gt; 'VDI: Adding VM to Desktop Pool',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'VDI: VM Added to Desktop Pool',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in VDI: Adding VM to Desktop Pool',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/VdiAddVmToDesktopPool      </MiqAeField>
      <MiqAeField name="EmailOwner" substitute="true" aetype="state" datatype="string" priority="15" message="create" on_entry="update_provision_status(status =&gt; 'Emailing Owner',status_state =&gt; 'on_entry')" on_exit="update_provision_status(status =&gt; 'provision_complete',status_state =&gt; 'on_exit')" on_error="update_provision_status(status =&gt; 'error in Emailing Owner',status_state =&gt; 'on_error')" max_retries="100">
/Alert/EmailNotifications/MiqProvision_Complete?event=vm_provisioned      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="clone_to_vm" display_name="Clone VM">
      <MiqAeField name="CustomizeRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="AcquireIPAddress">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="AcquireMACAddress">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="RegisterDNS">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="RegisterCMDB">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="RegisterAD">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PreProvision">
/Factory/VM/PreProvision_Clone_to_VM      </MiqAeField>
      <MiqAeField name="Provision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="CheckProvisioned">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PostProvision">
/Factory/VM/PostProvision_Clone_to_VM      </MiqAeField>
      <MiqAeField name="RegisterDHCP">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ActivateCMDB">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="VDIWaitForHostname">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="VDIAddVmToDesktopPool">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
/Alert/EmailNotifications/MiqProvision_Complete?event=vm_cloned      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="template" display_name="Provision VM from Template">
      <MiqAeField name="CustomizeRequest">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="AcquireIPAddress">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="AcquireMACAddress">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="RegisterDNS">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="RegisterCMDB">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="RegisterAD">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="PreProvision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="Provision">
/Factory/VM/Provision      </MiqAeField>
      <MiqAeField name="CheckProvisioned">
/Factory/VM/CheckProvisioned      </MiqAeField>
      <MiqAeField name="PostProvision">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="RegisterDHCP">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="ActivateCMDB">
        <![CDATA[ ]]>
      </MiqAeField>
      <MiqAeField name="VDIWaitForHostname">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="VDIAddVmToDesktopPool">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VMRetirement" namespace="Factory/StateMachines" description="Factory State Machines" display_name="VM Retirement State Machine">
    <MiqAeMethod name="update_retirement_status" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: update_retirement_status
#
# Notes: This method updates retirement status
#
# Required inputs: status, status_state
#
###################################
begin
  @method = 'update_retirement_status'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get vm from root
  vm = $evm.root['vm']

  # Get variables from Server object
  server = $evm.root['miq_server']

  # Get State Machine
  state = $evm.current_object.class_name

  # Get current step
  step = $evm.current_object.current_field_name

  # Get status from input field status
  status = $evm.inputs['status']

  # Get status_state ['on_entry', 'on_exit', 'on_error'] from input field
  status_state = $evm.inputs['status_state']

  $evm.log("info", "#{@method} - Server:<#{server.name}> Ae_Result:<#{$evm.root['ae_result']}> State:<#{state}> Step:<#{step}> Status_State:<#{status_state}> Status:<#{status}>")


  ###################################
  #
  # Update Status for on_entry,on_exit
  #
  ###################################
  if $evm.root['ae_result'] == 'ok'

  end


  ###################################
  #
  # Update Status for on_error
  #
  ###################################
  if $evm.root['ae_result'] == 'error'

  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>      <MiqAeField name="status_state" substitute="true" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="status" substitute="true" priority="2" message="create">
      </MiqAeField>
    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="CheckPoweredOff" substitute="true" aetype="state" datatype="string" priority="1" message="create" on_entry="update_retirement_status(status =&gt; 'Powering Off VM',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Powered Off VM',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Powering Off VM',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/CheckPoweredOff      </MiqAeField>
      <MiqAeField name="DeactivateCMDB" substitute="true" aetype="state" datatype="string" priority="2" message="create" on_entry="update_retirement_status(status =&gt; 'Deactivating from CMDB',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Deactivated from CMDB',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Deactivating from CMDB',status_state =&gt; 'on_error')" max_retries="100">
#/Integration/CMDB/Deactivate      </MiqAeField>
      <MiqAeField name="UnregisterDHCP" substitute="true" aetype="state" datatype="string" priority="3" message="create" on_entry="update_retirement_status(status =&gt; 'Unregistering from DHCP',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Unregistered from DHCP',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Unregistering from DHCP',status_state =&gt; 'on_error')" max_retries="100">
#/Integration/IPAM/UnregisterDHCP      </MiqAeField>
      <MiqAeField name="UnregisterAD" substitute="true" aetype="state" datatype="string" priority="4" message="create" on_entry="update_retirement_status(status =&gt; 'Unregistering from AD',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Unregistered from AD',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Unregistering from AD',status_state =&gt; 'on_error')" max_retries="100">
#/Integration/IPAM/UnregisterAD      </MiqAeField>
      <MiqAeField name="UnregisterDNS" substitute="true" aetype="state" datatype="string" priority="5" message="create" on_entry="update_retirement_status(status =&gt; 'Unregistering from DNS',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Unregistered from DNS',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Unregistering from DNS',status_state =&gt; 'on_error')" max_retries="100">
#/Integration/IPAM/UnregisterDNS      </MiqAeField>
      <MiqAeField name="ReleaseMACAddress" substitute="true" aetype="state" datatype="string" priority="6" message="create" on_entry="update_retirement_status(status =&gt; 'Releasing MAC Address',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Released MAC Address',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Releasing MAC Address',status_state =&gt; 'on_error')" max_retries="100">
#/Integration/IPAM/ReleaseMACAddress      </MiqAeField>
      <MiqAeField name="ReleaseIPAddress" substitute="true" aetype="state" datatype="string" priority="7" message="create" on_entry="update_retirement_status(status =&gt; 'Releasing IP Address',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Released IP Address',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Releasing IP Address',status_state =&gt; 'on_error')" max_retries="100">
#/Integration/IPAM/ReleaseIPAddress      </MiqAeField>
      <MiqAeField name="PreDeleteEmailOwner" substitute="true" aetype="state" datatype="string" priority="8" message="create" on_entry="update_retirement_status(status =&gt; 'Notifying VM Owner',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Notified VM Owner',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Notifying VM Owner',status_state =&gt; 'on_error')" max_retries="100">
#/Alert/EmailNotifications/vm_retirement_emails?event=vm_entered_retirement      </MiqAeField>
      <MiqAeField name="UnregisterFromVC" substitute="true" aetype="state" datatype="string" priority="9" message="create" on_entry="update_retirement_status(status =&gt; 'Unregistering from VC',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Unregistered from VC',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Unregistering from VC',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/UnregisterFromVC      </MiqAeField>
      <MiqAeField name="PreDeleteFromVC" substitute="true" aetype="state" datatype="string" priority="10" message="create" on_entry="update_retirement_status(status =&gt; 'Executing PreDelete from VC',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Executed PreDelete from VC',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Executing PreDelete from VC',status_state =&gt; 'on_error')" max_retries="100">
#/Factory/VM/PreDeleteFromVC      </MiqAeField>
      <MiqAeField name="DeleteFromVC" substitute="true" aetype="state" datatype="string" priority="11" message="create" on_entry="update_retirement_status(status =&gt; 'Deleting from VC',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Deleted from VC',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Deleting from VC',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/DeleteFromVC      </MiqAeField>
      <MiqAeField name="EmailOwner" substitute="true" aetype="state" datatype="string" priority="12" message="create" on_entry="update_retirement_status(status =&gt; 'Emailing VM Owner',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Emailed VM Owner',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Emailing VM Owner',status_state =&gt; 'on_error')" max_retries="100">
/Alert/EmailNotifications/vm_retirement_emails?event=vm_retired      </MiqAeField>
      <MiqAeField name="CheckUnregisteredFromVC" substitute="true" aetype="state" datatype="string" priority="13" message="create" on_entry="update_retirement_status(status =&gt; 'Checking Unregistration from VC',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Checked Unregistration from VC',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Checking Unregistration from VC',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/CheckUnregisteredFromVC      </MiqAeField>
      <MiqAeField name="DeleteFromVMDB" substitute="true" aetype="state" datatype="string" priority="14" message="create" on_entry="update_retirement_status(status =&gt; 'Removing from VMDB',status_state =&gt; 'on_entry')" on_exit="update_retirement_status(status =&gt; 'Removed from VMDB',status_state =&gt; 'on_exit')" on_error="update_retirement_status(status =&gt; 'Error in Removing from VMDB',status_state =&gt; 'on_error')" max_retries="100">
/Factory/VM/DeleteFromVMDB      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Default" display_name="Default">
      <MiqAeField name="CheckPoweredOff">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="DeactivateCMDB">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="UnregisterDHCP">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="UnregisterAD">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="UnregisterDNS">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ReleaseMACAddress">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="ReleaseIPAddress">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="PreDeleteEmailOwner">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="UnregisterFromVC">
#/Factory/VM/UnregisterFromVC      </MiqAeField>
      <MiqAeField name="PreDeleteFromVC">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="DeleteFromVC">
/Factory/VM/DeleteFromVC      </MiqAeField>
      <MiqAeField name="EmailOwner">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="CheckUnregisteredFromVC">
/Factory/VM/CheckUnregisteredFromVC      </MiqAeField>
      <MiqAeField name="DeleteFromVMDB">
/Factory/VM/DeleteFromVMDB      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VM" namespace="Factory" display_name="Virtual Machine">
    <MiqAeMethod name="CustomizeRequest" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: CustomizeRequest
#
# Notes: This method is used to Customize the Provisioning Request
#
# 1. Customization Specification Mapping for VMware provisioning
# 2. Customization Template and PXE for RHEV provisioning
# 3. Customization Processing for Amazon provisioning
# 4. Customization Template Processing for RHEV based ISO Provisioning
#
###################################
# Method for logging
def log(level, message)
  @method = 'CustomizeRequest'
  $evm.log(level, "#{@method} - #{message}")
end

begin
  log(:info, "EVM Automate Method Started")


  #################################
  #
  # Method: set_customspec
  #
  # Notes: This method sets the customization spec for vmware
  #
  #################################
  def set_customspec(prov, spec)
    prov.set_customization_spec(spec, true)
    log(:info,"Provisioning object updated - <:sysprep_custom_spec> with <#{prov.get_option(:sysprep_custom_spec)}>")
    log(:info,"Provisioning object <:sysprep_spec_override> updated with <#{prov.get_option(:sysprep_spec_override)}>")
  end


  #################################
  #
  # Method: process_vmware
  #
  #################################
  def process_vmware(mapping, prov )
    # Get information from the template platform
    template = prov.vm_template
    product  = template.operating_system['product_name'].downcase
    bitness = template.operating_system['bitness']
    log(:info,"Template:<#{template.name}> Vendor:<#{template.vendor}> Product:<#{product}> Bitness:<#{bitness}>")

    # Skip automatic customization spec mapping if template is 'Other' or provision_type is clone_to_[template]
    unless product.include?("Other") || prov.provision_type.include?("clone_to_template")
      case mapping

      when 0
        # Skip mapping
        log(:info, "Skipping #{prov.type} mapping:<#{mapping}>")

      when 1
        # Automatic customization specification mapping if template is RHEL,Suse or Windows
        if product.include?("red hat") || product.include?("suse") || product.include?("windows")
          spec = prov.vm_template.name # to match the template name
          set_customspec(prov, spec)
        end

      when 2
        ###################################
        # Use this option to use a combination of product name and bitness to select your customization specification
        ###################################
        spec = "default_spec" # unknown type

        if product.include?("2003")
          # Windows Server 2003
          if product.include?("enterprise")
            spec = "W2K3R2-Entx64"
          else
            if bitness == 64 # 2003 Std x64
              spec = "W2K3R2-Stdx64" # Win2003 64 bit
            else # 2003 Std x86
              spec = "W2K3R2-Stdx32" # Win2003 32 bit
            end
          end
        elsif product.include?("2008")
          # Windows Server 2008
          if product.include?("datacenter")
            spec = "W2K8R2-Datx64" # Win2k8 64 bit
          else # Standard x64
            spec = "W2K8R2-Stdx64" # Win2k8 32 bit
          end
        elsif product.include?("windows 7")
          if bitness == 64
            spec = "W7-Prox64" # Windows7 64 bit
          else
            spec = "W7-Prox86" # Windows7 32 bit
          end
        elsif product.include?("windows xp")
          if product.include?("64-bit")
            spec = "WXP-Prox64" # Windows XP 64 bit
          else
            spec = "WXP-Prox32" # Windows XP 32 bit
          end
        elsif product.include?("suse")
          spec = "suse_custom_spec" # Suse
        elsif product.include?("red hat")
          spec = "rhel_custom_spec" # RHEL
        end
        log(:info,"VMware Custom Specification:<#{spec}> bitness:<#{bitness}>")

        # Set values in provisioning object
        set_customspec(prov, spec) unless spec.nil?
      when 3
        #
        # Enter your own VMware custom mapping here
        #
      else
        # Skip mapping
        log(:info, "Skipping #{prov.type} mapping:<#{mapping}>")
      end # end case
    end # end unless
  end # end process_vmware


  #################################
  #
  # Method: process_redhat
  # Notes: Red Hat PXE Provisioning
  #
  #################################
  def process_redhat(mapping, prov )
    # Get information from the template platform
    template = prov.vm_template
    product  = template.operating_system['product_name'].downcase
    log(:info,"Template:<#{template.name}> Vendor:<#{template.vendor}> Product:<#{product}>")

    case mapping

    when 0
      # No mapping

    when 1
      if product.include?("windows")
        # find the windows image that matches the template name if a PXE Image was NOT chosen in the dialog
        if prov.get_option(:pxe_image_id).nil?

          pxe_image = prov.eligible_windows_images.detect { |pi| pi.name.casecmp(template.name)==0 }
          if pxe_image.nil?
            message "Failed to find matching PXE Image"
            prov.message = message
            log(:info,"Inspecting Eligible Windows Images:<#{prov.eligible_windows_images.inspect}>")
            raise message
          else
            log(:info,"Found matching Windows PXE Image ID:<#{pxe_image.id}> Name:<#{pxe_image.name}> Description:<#{pxe_image.description}>")
          end
          prov.set_windows_image(pxe_image)
          log(:info,"Provisioning object <:pxe_image_id> updated with <#{prov.get_option(:pxe_image_id).inspect}>")
        end
        # Find the first customization template that matches the template name if none was chosen in the dialog
        if prov.get_option(:customization_template_id).nil?
          cust_temp = prov.eligible_customization_templates.detect { |ct| ct.name.casecmp(template.name)==0 }
          if cust_temp.nil?
            message "Failed to find matching PXE Image"
            prov.message = message
            log(:info,"Inspecting Eligible Customization Templates:<#{prov.eligible_customization_templates.inspect}>")
            raise message
          end
          log(:info,"Found mathcing Windows Customization Template ID:<#{cust_temp.id}> Name:<#{cust_temp.name}> Description:<#{cust_temp.description}>")
          prov.set_customization_template(cust_temp)
          log(:info,"Provisioning object <:customization_template_id> updated with <#{prov.get_option(:customization_template_id).inspect}>")
        end
      else
        # find the first PXE Image that matches the template name if NOT chosen in the dialog
        if prov.get_option(:pxe_image_id).nil?
          pxe_image = prov.eligible_pxe_images.detect { |pi| pi.name.casecmp(template.name)==0 }
          log(:info,"Found Linux PXE Image ID:<#{pxe_image.id}> Name:<#{pxe_image.name}> Description:<#{pxe_image.description}>")
          prov.set_pxe_image(pxe_image)
          log(:info,"Provisioning object <:pxe_image_id> updated with <#{prov.get_option(:pxe_image_id).inspect}>")
        end
        # Find the first Customization Template that matches the template name if NOT chosen in the dialog
        if prov.get_option(:customization_template_id).nil?
          cust_temp = prov.eligible_customization_templates.detect { |ct| ct.name.casecmp(template.name)==0 }
          log(:info,"Found Customization Template ID:<#{cust_temp.id}> Name:<#{cust_temp.name}> Description:<#{cust_temp.description}>")
          prov.set_customization_template(cust_temp)
          log(:info,"Provisioning object <:customization_template_id> updated with <#{prov.get_option(:customization_template_id).inspect}>")
        end
      end
    when 3
      #
      # Enter your own RHEV PXE custom mapping here
      #

    else
      # Skip mapping
      log(:info, "Skipping #{prov.type} mapping:<#{mapping}>")
    end # end case
  end # end process_redhat


  #################################
  #
  # Method: process_redhat_iso
  # Notes: Red Hat ISO Provisioning
  #
  #################################
  def process_redhat_iso(mapping, prov )
    # Get information from the template platform
    template = prov.vm_template
    product  = template.operating_system['product_name'].downcase
    log(:info,"Template:<#{template.name}> Vendor:<#{template.vendor}> Product:<#{product}>")

    case mapping

    when 0
      # No mapping
    when 1
      if product.include?("windows")
        # Linux Support only for now

      else
        # Linux - Find the first ISO Image that matches the template name if NOT chosen in the dialog
        if prov.get_option(:iso_image_id).nil?
          iso_image = prov.eligible_iso_images.detect { |iso| iso.name.casecmp(template.name)==0 }
          log(:info,"Found Linux ISO Image ID:<#{iso_image.id}> Name:<#{iso_image.name}> Description:<#{iso_image.description}>")
          prov.set_iso_image(iso_image)
          log(:info,"Provisioning object <:iso_image_id> updated with <#{prov.get_option(:iso_image_id).inspect}>")
        end
        # Find the first Customization Template that matches the template name if NOT chosen in the dialog
        if prov.get_option(:customization_template_id).nil?
          cust_temp = prov.eligible_customization_templates.detect { |ct| ct.name.casecmp(template.name)==0 }
          log(:info,"Found Customization Template ID:<#{cust_temp.id}> Name:<#{cust_temp.name}> Description:<#{cust_temp.description}>")
          prov.set_customization_template(cust_temp)
          log(:info,"Provisioning object <:customization_template_id> updated with <#{prov.get_option(:customization_template_id).inspect}>")
        end
      end
    when 2
      #
      # Enter your own RHEV ISO custom mapping here
      #

    else
      # Skip mapping
      log(:info, "Skipping #{prov.type} mapping:<#{mapping}>")
    end
  end


  #################################
  #
  # Method: process_amazon
  #
  #
  #################################
  def process_amazon(mapping, prov )

  end # end process_amazon



  # Get provisioning object
  prov = $evm.root["miq_provision"]

  log(:info, "Provision:<#{prov.id}> Request:<#{prov.miq_provision_request.id}> Type:<#{prov.type}>")

  # Log all of the provisioning options to the automation.log
  #prov.options.each { |k,v| log(:info,"Provisioning Option Key:<#{k.inspect}> Value:<#{v.inspect}>") }

  # Build case statement to determine which type of processing is required
  case prov.type

  when 'MiqProvisionRedhatViaIso'
    ##########################################################
    # Red Hat Customization Template Mapping for ISO Provisioning
    #
    # Possible values:
    #   0 - (DEFAULT No Mapping) This option skips the mapping of iso images and customization templates
    #
    #   1 - CFME will look for a iso image and a customization template with
    #   the exact name as the template name if none were chosen from the provisioning dialog
    #
    #   2 - Include your own custom mapping logic here
    #
    ##########################################################
    mapping = 0
    process_redhat_iso(mapping, prov )

  when 'MiqProvisionRedhatViaPxe'
    ##########################################################
    # Red Hat Customization Template Mapping for PXE Provisioning
    #
    # Possible values:
    #   0 - (DEFAULT No Mapping) This option skips the mapping of pxe images and customization templates
    #
    #   1 - CFME will look for a pxe image and a customization template with
    #   the exact name as the template name if none were chosen from the provisioning dialog
    #
    #   2 - Include your own custom mapping logic here
    #
    ##########################################################
    mapping = 0
    process_redhat_iso(mapping, prov )

  when 'MiqProvisionVmware'
    ##########################################################
    # VMware Customization Specification Mapping
    #
    # Possible values:
    #   0 - (Default No Mapping) This option is automatically chosen if it finds a customization
    #   specification mapping chosen from the dialog
    #
    #   1 - CFME will look for a customization specification with
    #   the exact name as the template name
    #
    #   2 - Use this option to use a combination of product name and bitness to
    #   select your customization specification
    #
    #   3 - Include your own custom mapping logic here
    ##########################################################
    mapping = 0
    process_vmware(mapping, prov )

  when 'MiqProvisionAmazon'
    ##########################################################
    # Amazon Specification Mapping
    #
    # Placeholder for future enhancements:
    #
    ##########################################################
    mapping = 0
    process_amazon(mapping, prov )

  else
    log(:info, "Provisioning Type:<#{prov.type}> does not match, skipping processing")
  end


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PostProvision" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PostProvision
#
# Notes: This method is used to process tasks immediately after the VM has been provisioned
#
###################################
begin
  @method = 'PostProvision'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get Variables
  #
  prov = $evm.root["miq_provision"]
  $evm.log("info", "#{@method} - Provisioning ID:<#{prov.id}> Provision Request ID:<#{prov.miq_provision_request.id}>") if @debug

  # Get provissioned VM from prov object
  vm = prov.vm
  unless vm.nil?
    $evm.log("info","#{@method} - VM:<#{vm.name}> has been provisioned") if @debug
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PostProvision_Clone_to_VM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PostProvision_Clone_to_VM
#
# Notes: This method is used to customize the provisioning object prior to provisioning
#
###################################
begin
  @method = 'PostProvision_Clone_to_VM'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get Variables
  #
  prov = $evm.root["miq_provision"]
  $evm.log("info", "#{@method} - Inspecting Provisioning Object: #{prov.inspect}") if @debug

  # Get Provision Type
  prov_type = prov.provision_type
  $evm.log("info","#{@method} - Provision Type: <#{prov_type}>") if @debug

  # Get template
  template = prov.vm_template
  $evm.log("info", "#{@method} - Inspecting Template Object: #{template.inspect}") if @debug

  tags = template.tags
  $evm.log("info", "#{@method} - Inspecting Template Tags: #{tags.inspect}") if @debug


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PreDeleteFromVC" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PreDeleteFromVC
#
# Notes:This retirement method runs prior to deleting the VM from VC
#
#
###################################
begin
  @method = 'PreDeleteFromVC'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

 

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PreProvision" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PreProvision
#
# Notes: This default method is used to apply PreProvision customizations for VMware, RHEV and Amazon provisioning
#
###################################
# Method for logging
def log(level, message)
  @method = 'PreProvision'
  $evm.log(level, "#{@method} - #{message}")
end

begin
  log(:info, "EVM Automate Method Started")

  #################################
  #
  # Method: process_vmware
  # Notes: Process vmware specific provisioning options
  #
  #################################
  def process_vmware(prov)
    # Choose the sections to process
    set_vlan = false
    set_folder = false
    set_resource_pool = false
    set_notes = true

    # Get information from the template platform
    template = prov.vm_template
    product  = template.operating_system['product_name'].downcase
    bitness = template.operating_system['bitness']
    log(:info,"Template:<#{template.name}> Vendor:<#{template.vendor}> Product:<#{product}> Bitness:<#{bitness}>")

    if set_vlan
      ###################################
      # Was a VLAN selected in dialog?
      # If not you can set one here.
      ###################################
      default_vlan = "vlan1"
      default_dvs = "portgroup1"

      if prov.get_option(:vlan).nil?
        log(:info, "Provisioning object <:vlan> updated with <#{default_vlan}>")
        prov.set_vlan(default_vlan)
        #prov.set_dvs(default_dvs)
      end
    end

    if set_folder
      ###################################
      # Drop the VM in the targeted folder if no folder was chosen in the dialog
      # The vCenter folder must exist for the VM to be placed correctly else the
      # VM will placed along with the template
      # Folder starts at the Data Center level
      ###################################
      default_folder = 'DC1/Infrastructure/ManageIQ/SelfService'

      if prov.get_option(:placement_folder_name).nil?
        prov.get_folder_paths.each { |key, path| $evm.log("info", "#{@method} - Eligible folders:<#{key}> - <#{path}>") }
        prov.set_folder(default_folder)
        log(:info, "Provisioning object <:placement_folder_name> updated with <#{default_folder}>")
      else
        log(:info, "Placing VM in folder: <#{prov.get_option(:placement_folder_name)}>")
      end
    end

    if set_resource_pool
      if prov.get_option(:placement_rp_name).nil?
        ############################################
        # Find and set the Resource Pool for a VM:
        ############################################
        default_resource_pool = 'MyResPool'
        respool = prov.eligible_resource_pools.detect {|c| c.name.casecmp(default_resource_pool)==0}
        log(:info, "Provisioning object <:placement_rp_name> updated with <#{respool.name}>")
        prov.set_resource_pool(respool)
      end
    end

    if set_notes
      ###################################
      # Set the VM Description and VM Annotations  as follows:
      # The example would allow user input in provisioning dialog "vm_description"
      # to be added to the VM notes
      ###################################
      # Stamp VM with custom description
      unless prov.get_option(:vm_description).nil?
        vmdescription = prov.get_option(:vm_description)
        prov.set_option(:vm_description,vmdescription)
        log(:info,"Provisioning object <:vmdescription> updated with <#{vmdescription}>")
      end

      # Setup VM Annotations
      vm_notes =  "Owner: #{prov.get_option(:owner_first_name)} #{prov.get_option(:owner_last_name)}"
      vm_notes += "\nEmail: #{prov.get_option(:owner_email)}"
      vm_notes += "\nSource Template: #{template.name}"
      vm_notes += "\nCustom Description: #{vmdescription}" unless vmdescription.nil?
      prov.set_vm_notes(vm_notes)
      log(:info,"Provisioning object <:vm_notes> updated with <#{vm_notes}>")
    end

      # Log all of the provisioning options to the automation.log
      prov.options.each { |k,v| log(:info,"Provisioning Option Key:<#{k.inspect}> Value:<#{v.inspect}>") }
  end


  #################################
  #
  # Method: process_redhat
  # Notes: Process redhat specific provisioning options
  #
  #################################
  def process_redhat(prov )
    # Choose the sections to process
    set_vlan = true
    set_notes = false

    # Get information from the template platform
    template = prov.vm_template
    product  = template.operating_system['product_name'].downcase
    log(:info,"Template:<#{template.name}> Vendor:<#{template.vendor}> Product:<#{product}>")


    if set_vlan
      # Set default VLAN here if one was not chosen in the dialog?
      default_vlan = "rhevm"

      if prov.get_option(:vlan).nil?
        prov.set_vlan(default_vlan)
        log(:info, "Provisioning object <:vlan> updated with <#{default_vlan}>")
      end
    end

    if set_notes
      ###################################
      # Set the VM Description and VM Annotations  as follows:
      # The example would allow user input in provisioning dialog "vm_description"
      # to be added to the VM notes
      ###################################
      # Stamp VM with custom description
      unless prov.get_option(:vm_description).nil?
        vmdescription = prov.get_option(:vm_description)
        prov.set_option(:vm_description,vmdescription)
        log(:info,"Provisioning object <:vmdescription> updated with <#{vmdescription}>")
      end

      # Setup VM Annotations
      vm_notes =  "Owner: #{prov.get_option(:owner_first_name)} #{prov.get_option(:owner_last_name)}"
      vm_notes += "\nEmail: #{prov.get_option(:owner_email)}"
      vm_notes += "\nSource Template: #{template.name}"
      vm_notes += "\nCustom Description: #{vmdescription}" unless vmdescription.nil?
      prov.set_vm_notes(vm_notes)
      log(:info,"Provisioning object <:vm_notes> updated with <#{vm_notes}>")
    end

      # Log all of the provisioning options to the automation.log
      prov.options.each { |k,v| log(:info,"Provisioning Option Key:<#{k.inspect}> Value:<#{v.inspect}>") }
  end


  #################################
  #
  # Method: process_amazon
  # Notes: Process Amazon specific provisioning options
  #
  #################################
  def process_amazon(prov )

  end # end process_amazon


  # Get provisioning object
  prov = $evm.root["miq_provision"]
  log(:info, "Provision:<#{prov.id}> Request:<#{prov.miq_provision_request.id}> Type:<#{prov.type}>")

  # Build case statement to determine which type of processing is required
  case prov.type
  when 'MiqProvisionRedhatViaIso', 'MiqProvisionRedhatViaPxe';  process_redhat(prov)
  when 'MiqProvisionVmware';                                    process_vmware(prov)
  when 'MiqProvisionAmazon';                                    process_amazon(prov)
  else                                                          log(:info, "Provision Type:<#{prov.type}> does not match, skipping processing")
  end


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PreProvision_Clone_to_Template" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PreProvision_Clone_to_Template
#
# Notes: This default method is used to apply PreProvision customizations as follows:
# 1. VM Description/Annotations
# 2. Target VC Folder
# 3. Tag Inheritance
#
###################################
begin
  @method = 'PreProvision_Clone_to_Template'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn on verbose debugging
  @debug = true

  # Get provisioning object
  prov = $evm.root["miq_provision"]
  #$evm.log("info", "#{@method} - Inspecting Provisioning Object: #{prov.inspect}") if @debug

  # Get Provision Type
  prov_type = prov.provision_type
  $evm.log("info","#{@method} - Provision Type: <#{prov_type}>")


  # Get template
  template = prov.vm_template
  #$evm.log("info", "#{@method} - Inspecting Template Object: #{template.inspect}") if @debug

  # Get OS Type from the template platform
  product  = template.operating_system['product_name'] rescue ''
  $evm.log("info","#{@method} - Source Product: <#{product}>")

  ###################################
  # Set the customization spec here
  # If one selected in dialog it will be used,
  # else it will map template to customization spec based on template name
  ###################################

  # Skip automatic customization spec mapping if template is 'Other' or provision_type is clone_to_[template|vm]
  unless product.include?("Other") || prov_type.include?("clone")
    if prov.get_option(:sysprep_custom_spec).nil?
      customization_spec = prov.vm_template.name # to match the template name
      prov.set_customization_spec(customization_spec)
      $evm.log("info","#{@method} - Provisioning object updated - <:sysprep_custom_spec> = <#{customization_spec}>")
    end
  else
    $evm.log("info", "#{@method} - Skipping automatic customization spec mapping")
  end


  ###################################
  # Set the VM Description and VM Annotations  as follows:
  # The example would allow user input in provisioning dialog "vm_description"
  # to be added to the VM notes
  ###################################
  # Stamp VM with custom description
  unless prov.get_option(:vm_description).nil?
    vmdescription = prov.get_option(:vm_description)
    prov.set_option(:vm_description,vmdescription)
    $evm.log("info","#{@method} - Provisioning object <:vmdescription> updated with <#{vmdescription}>")
  end

  # Setup VM Annotations
  vm_notes =  "Owner: #{prov.get_option(:owner_first_name)} #{prov.get_option(:owner_last_name)}"
  vm_notes += "\nEmail: #{prov.get_option(:owner_email)}"
  vm_notes += "\nSource Template: #{prov.vm_template.name}"
  vm_notes += "\nCustom Description: #{vmdescription}" unless vmdescription.nil?
  prov.set_vm_notes(vm_notes)
  $evm.log("info","#{@method} - Provisioning object <:vm_notes> updated with <#{vm_notes}>")


  ###################################
  # Drop the VM in the targeted folder if no folder was chosen in the dialog
  # The VC folder must exist for the VM to be placed correctly else the
  # VM will placed along with the template
  # Folder starts at the Data Center level
  ###################################
  default_folder = 'DC1/Infrastructure/ManageIQ/SelfService'

  if prov.get_option(:placement_folder_name).nil?
    #prov.get_folder_paths.each do |key, path|
    #$evm.log("info", "Dumping all folders:<#{key}> - <#{path}>") if @debug
    #end
    prov.set_folder(default_folder)
    $evm.log("info", "#{@method} - Provisioning object <:placement_folder_name> updated with <#{default_folder}>")
  else
    $evm.log("info", "#{@method} - Placing VM in folder: <#{prov.get_option(:placement_folder_name)}>")
  end


  ###################################
  #
  # Inherit parent VM's tags and apply
  # them to the published template
  #
  ###################################

  # List of tag categories to carry over
  tag_categories_to_migrate = ['environment', 'department', 'location', 'function']

  # Assign variables
  prov_tags = prov.get_tags
  $evm.log("info","#{@method} - Inspecting Provisioning Tags: <#{prov_tags.inspect}>") if @debug
  template_tags = template.tags
  $evm.log("info","#{@method} - Inspecting Template Tags: <#{template_tags.inspect}>") if @debug

  # Loop through each source tag for matching categories
  template_tags.each do |cat_tagname|
    category, tag_value = cat_tagname.split('/')
    $evm.log("info","#{@method} - Processing Tag Category: <#{category}> Value: <#{tag_value}>") if @debug
    next unless tag_categories_to_migrate.include?(category)
    prov.add_tag(category, tag_value)
    $evm.log("info","#{@method} - Updating Provisioning Tags with Category: <#{category}> Value: <#{tag_value}>")
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PreProvision_Clone_to_VM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PreProvision_Clone_to_VM
#
# Notes: This default method is used to apply PreProvision customizations during the cloning to a VM:
# 1. Customization Spec
# 2. VLAN
# 3. VM Description/Annotations
# 4. Target VC Folder
# 5. Resource Pool
# 6. Tag Ineritance
#
###################################
begin
  @method = 'PreProvision_Clone_to_VM'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn on verbose debugging
  @debug = true

  # Get provisioning object
  prov = $evm.root["miq_provision"]
  #$evm.log("info", "#{@method} - Inspecting Provisioning Object: #{prov.inspect}") if @debug

  # Get Provision Type
  prov_type = prov.provision_type
  $evm.log("info","#{@method} - Provision Type: <#{prov_type}>") if @debug


  # Get template
  template = prov.vm_template
  #$evm.log("info", "#{@method} - Inspecting Template Object: #{template.inspect}") if @debug

  # Get OS Type from the template platform
  product  = template.operating_system['product_name'] rescue ''
  $evm.log("info","#{@method} - Source Product: <#{product}>") if @debug

  ###################################
  # Set the customization spec here
  # If one selected in dialog it will be used,
  # else it will map the customization spec based on the 
  # the entry below
  ###################################
  customization_spec = "my-custom-spec" 

  # Skip automatic customization spec mapping if template is 'Other'
  unless product.include?("Other") 
    if prov.get_option(:sysprep_custom_spec).nil?
      prov.set_customization_spec(customization_spec)
      $evm.log("info","#{@method} - Provisioning object updated - <:sysprep_custom_spec> = <#{customization_spec}>") if @debug
    end
  else
    $evm.log("info", "#{@method} - Skipping automatic customization spec mapping") if @debug
  end


  ###################################
  # Was a VLAN selected in dialog?
  # If not you can set one here.
  ###################################
  default_vlan = "vlan1"
  default_dvs = "portgroup1"

  if prov.get_option(:vlan).nil?
    prov.set_vlan(default_vlan)
    #prov.set_dvs(default_dvs)
  end


  ###################################
  # Set the VM Description and VM Annotations  as follows:
  # The example would allow user input in provisioning dialog "vm_description"
  # to be added to the VM notes
  ###################################
  # Stamp VM with custom description
  unless prov.get_option(:vm_description).nil?
    vmdescription = prov.get_option(:vm_description)
    prov.set_option(:vm_description,vmdescription)
    $evm.log("info","#{@method} - Provisioning object <:vmdescription> updated with <#{vmdescription}>") if @debug
  end

  # Setup VM Annotations
  vm_notes =  "Owner: #{prov.get_option(:owner_first_name)} #{prov.get_option(:owner_last_name)}"
  vm_notes += "\nEmail: #{prov.get_option(:owner_email)}"
  vm_notes += "\nSource VM: #{prov.vm_template.name}"
  vm_notes += "\nCustom Description: #{vmdescription}" unless vmdescription.nil?
  prov.set_vm_notes(vm_notes)
  $evm.log("info","#{@method} - Provisioning object <:vm_notes> updated with <#{vm_notes}>") if @debug


  ###################################
  # Drop the VM in the targeted folder if no folder was chosen in the dialog
  # The VC folder must exist for the VM to be placed correctly else the
  # VM will placed along with the template
  # Folder starts at the Data Center level
  ###################################
  default_folder = 'DC1/Infrastructure/ManageIQ/SelfService'

  if prov.get_option(:placement_folder_name).nil?
    #prov.get_folder_paths.each do |key, path|
    #$evm.log("info", "#{@method} - Dumping all folders:<#{key}> - <#{path}>") if @debug
    #end
    prov.set_folder(default_folder)
    $evm.log("info", "#{@method} - Provisioning object <:placement_folder_name> updated with <#{default_folder}>") if @debug
  else
    $evm.log("info", "#{@method} - Placing VM in folder: <#{prov.get_option(:placement_folder_name)}>") if @debug
  end


  ############################################
  # Find and set the Resource Pool for a VM:
  ############################################
  # respool = prov.eligible_resource_pools.detect {|c| c.name.casecmp('MyResPool')==0}
  # prov.set_resource_pool(respool)


  ###################################
  #
  # Inherit parent VM's tags and apply
  # them to the cloned VM
  #
  ###################################

  # List of tag categories to carry over
  tag_categories_to_migrate = ['environment', 'department', 'location', 'function']

  # Assign variables
  prov_tags = prov.get_tags
  $evm.log("info","#{@method} - Provisioning Tags: <#{prov_tags.inspect}>") if @debug
  template_tags = template.tags
  $evm.log("info","#{@method} - Template Tags: <#{template_tags.inspect}>") if @debug

  # Loop through each source tag for matching categories
  template_tags.each do |cat_tagname|
    category, tag_value = cat_tagname.split('/')
    $evm.log("info","#{@method} - Processing Tag Category: <#{category}> Value: <#{tag_value}>") if @debug
    next unless tag_categories_to_migrate.include?(category)
    prov.add_tag(category, tag_value)
    $evm.log("info","#{@method} - Updating Provisioning Tags with Category: <#{category}> Value: <#{tag_value}>") if @debug
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="check_powered_off" language="ruby" scope="instance" location="inline" display_name="CheckPoweredOff"><![CDATA[###################################
#
# EVM Automate Method: check_powered_off
#
# Notes: This method checks to see if the VM has been powered off or suspended
#
###################################
begin
  @method = 'check_powered_off'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get vm from root object
  vm = $evm.root['vm']

  unless vm.nil?
    power_state = vm.attributes['power_state']
    ems = vm.ext_management_system
    $evm.log('info', "#{@method} - VM:<#{vm.name}> on EMS:<#{ems ? ems.name : nil} has Power State:<#{power_state}>") if @debug

    # If VM is powered off or suspended exit
    if power_state == "off" || power_state == "suspended"
      # Bump State
      $evm.root['ae_result'] = 'ok'
    elsif power_state == "never"
      # If never then this VM is a template so exit the retirement state machine
      $evm.root['ae_result'] = 'error'
    else
      $evm.root['ae_result']         = 'retry'
      $evm.root['ae_retry_interval'] = '15.seconds'
    end
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} -  [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="check_provisioned" language="ruby" scope="instance" location="inline" display_name="CheckProvisioned"><![CDATA[###################################
#
# EVM Automate Method: check_provisioned
#
# Notes: This method checks to see if the vm has been provisioned
#
###################################
begin
  @method = 'check_provisioned'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get current provisioning status
  task = $evm.root['miq_provision']
  task_status = task['status']
  result = task.status

  $evm.log('info', "#{@method} - ProvisionCheck returned <#{result}> for state <#{task.state}> and status <#{task_status}>") if @debug
  
  case result
  when 'error'
    $evm.root['ae_result'] = 'error'
    reason = $evm.root['miq_provision'].message
    reason = reason[7..-1] if reason[0..6] == 'Error: '
    $evm.root['ae_reason'] = reason
  when 'retry'
    $evm.root['ae_result']         = 'retry'
    $evm.root['ae_retry_interval'] = '1.minute'
  when 'ok'
    # Bump State
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="check_unregistered_from_vc" language="ruby" scope="instance" location="inline" display_name="CheckUnregisteredFromVC"><![CDATA[###################################
#
# EVM Automate Method: check_unregistered_from_vc
#
# Notes: This method checks to see if the VM is unregistered from the VC
#
###################################
begin
  @method = 'check_unregistered_from_vc'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  vm = $evm.root['vm']

  unless vm.nil?
    if !vm.registered?
      # Bump State
      $evm.log('info', "#{@method} - VM:<#{vm.name}> has been unregistered from EMS") if @debug
      $evm.root['ae_result'] = 'ok'
    else
      $evm.log('info', "#{@method} - VM:<#{vm.name}> is on Host:<#{vm.host}>, EMS:<#{vm.ext_management_system.name}>") if @debug
      $evm.root['ae_result']         = 'retry'
      $evm.root['ae_retry_interval'] = '15.seconds'
    end
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="delete_from_vc" language="ruby" scope="instance" location="inline" display_name="DeleteFromVC"><![CDATA[###################################
#
# EVM Automate Method: delete_from_vc
#
# Notes: This method deletes the VM from the VC
#
###################################
begin
  @method = 'delete_from_vc'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Get vm from root object
  vm = $evm.root['vm']
  category = "lifecycle"
  tag = "retire_full"

  miq_guid = /\w*MIQ\sGUID/i
  if vm.v_annotation =~  miq_guid
    vm_was_provisioned = true
  else
    vm_was_provisioned = false
  end

  if vm && (vm_was_provisioned || vm.miq_provision || vm.tagged_with?(category,tag))
    ems = vm.ext_management_system
    $evm.log('info', "#{@method} - Deleting VM:<#{vm.name}> from EMS:<#{ems ? ems.name : nil}>") if @debug
    vm.remove_from_disk
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="delete_from_vc_check" language="ruby" scope="instance" location="inline" display_name="DeleteFromVCCheck"><![CDATA[###################################
#
# EVM Automate Method: delete_from_vc_check
#
# Notes: This method checks to see if the VM has been deleted from the VC
#
###################################
begin
  @method = 'delete_from_vc_check'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  vm = $evm.root['vm']

  category = "lifecycle"
  tag = "retire_full"

  miq_guid = /\w*MIQ\sGUID/i
  if vm.v_annotation =~  miq_guid
    vm_was_provisioned = true
  else
    vm_was_provisioned = false
  end

  if vm && (vm_was_provisioned || vm.miq_provision || vm.tagged_with?(category,tag))
    host = vm.host
    $evm.log('info', "#{@method} - VM <#{vm.name}> parent Host ID is <#{host}>")
    if host.nil?
      # Bump State
      $evm.root['ae_result'] = 'ok'
    else
      $evm.root['ae_result']         = 'retry'
      $evm.root['ae_retry_interval'] = '15.seconds'
    end
  else
    # Bump State
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="delete_from_vmdb" language="ruby" scope="instance" location="inline" display_name="DeleteFromVMDB"><![CDATA[###################################
#
# EVM Automate Method: delete_from_vmdb
#
# Notes: This method removes the VM from the VMDB database
#
###################################
begin
  @method = 'delete_from_vmdb'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  vm = $evm.root['vm']
  category = "lifecycle"
  tag = "retire_full"

  miq_guid = /\w*MIQ\sGUID/i
  if vm.v_annotation =~  miq_guid
    vm_was_provisioned = true
  else
    vm_was_provisioned = false
  end

  if vm && (vm_was_provisioned || vm.miq_provision || vm.tagged_with?(category,tag))
    $evm.log('info', "#{@method} - Deleting VM <#{vm.name}> from VMDB") if @debug
    vm.remove_from_vmdb
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="power_off" language="ruby" scope="instance" location="inline" display_name="PowerOff"><![CDATA[###################################
#
# EVM Automate Method: power_off
#
# Notes: This method powers-off the VM on the VC
#
###################################
begin
  @method = 'power_off'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  vm = $evm.root['vm']
  unless vm.nil? || vm.attributes['power_state'] == 'off'
    ems = vm.ext_management_system
    $evm.log('info', "#{@method} - Powering Off VM <#{vm.name}> in VC <#{ems ? ems.name : nil}") if @debug
    vm.stop
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="provision" language="ruby" scope="instance" location="inline" display_name="Provision"><![CDATA[###################################
#
# EVM Automate Method: provision
#
# Notes: This method launches the provisioning job
#
###################################
begin
  @method = 'provision'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  $evm.root["miq_provision"].execute

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="scan" language="ruby" scope="instance" location="inline" display_name="Scan"><![CDATA[###################################
#
# EVM Automate Method: scan
#
# Notes: This method performs SmartState analysis on a VM
#
###################################
begin
  @method = 'scan'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true
  
  vm = $evm.root['vm']
  unless vm.nil?
    ems = vm.ext_management_system
    $evm.log('info', "#{@method} - Starting Scan of VM <#{vm.name}> in VC <#{ems ? ems.name : nil}") if @debug
    vm.scan
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="unregister_from_vc" language="ruby" scope="instance" location="inline" display_name="UnregisterFromVC"><![CDATA[###################################
#
# EVM Automate Method: unregister_from_vc
#
# Notes: This method unregisters the VM from the EMS
#
###################################
begin
  @method = 'unregister_from_vc'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  vm = $evm.root['vm']
  unless vm.nil?
    ems = vm.ext_management_system
    $evm.log('info', "#{@method} - Unregistering VM:<#{vm.name}> from EMS:<#{ems ? ems.name : nil}") if @debug
    vm.unregister
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vdi_add_vm_to_desktop_pool" language="ruby" scope="instance" location="inline" display_name="VDI Add VM to Desktop Pool"><![CDATA[###################################
#
# EVM Automate Method: vdi_add_vm_to_desktop_pool
#
# Notes: This method adds a provisioned VM to a VDI Desktop Group and
#        optionally creates the Desktop Group.
#
###################################

def vmware_view_script(create_new_group, desktopgroup_name, ems, desktopgroup_type, vms_id_list, vm_name_list)
<<PS_SCRIPT
#Add the VMware View Broker snap-in to the current Powershell session
$required_plugins = @("VMware.view.broker")
foreach ($plugin in $required_plugins) {if ((Get-PSSnapin -Name $plugin -ErrorAction SilentlyContinue) -eq $null) {Add-PSSnapin $plugin -ErrorAction Stop}}

# Define variables for the script
$create_new_group = "#{create_new_group}"
$strDesktopGroupName = "#{desktopgroup_name}"
$strDesktopGroupDescription = "New Desktop Group #{desktopgroup_name} Created by EVM"
$strAssignmentBehavior = "#{desktopgroup_type}"
$strVmsIdList = "#{vms_id_list}"
$strVmsNameList = "#{vm_name_list}"

# Virtual Center Credentials
$strHypervisorAddress = "#{ems.ipaddress}"

$result = @{"desktop_pool_name"=$strDesktopGroupName; "error"=$false}

function find_view_vc($target_ip) {
  $vc = Get-ViewVC -serverName $target_ip
  if ($vc -ne $null) {
      Get-ViewVC | ForEach-Object {
      $ip = [System.Net.Dns]::GetHostAddresses($_.serverName)
      if ($ip[0].IPAddressToString -eq $target_ip) {
        $vc = $_
      }
    }
  }

  # Add the VC if not found
  if ($vc -eq $null) {
    miq_logger "info" "Adding ViewVC : <$target_ip>"
    Add-ViewVC -serverName $target_ip -username "#{ems.authentication_userid}" -password #{ems.authentication_password_encrypted} -ErrorAction Stop
    $vc = Get-ViewVC -serverName $target_ip
  }

  return $vc
}

miq_logger "info" "Create new Desktop Pool : <$create_new_group>"
miq_logger "info" "Desktop Pool Name       : <$strDesktopGroupName>"
miq_logger "info" "Desktop Pool Description: <$strDesktopGroupDescription>"
miq_logger "info" "VM Name List            : <$strVmsNameList>"
miq_logger "info" "VM ID List              : <$strVmsIdList>"

# Find the ViewVC for this request
$vc = find_view_vc $strHypervisorAddress

if ($vc -ne $null) {
  if ($strAssignmentBehavior -eq "Pooled") {$persistence = "NonPersistent"} else {$persistence = "Persistent"}
  $new_pool = Add-ManualPool -vc_id $vc.vc_id -pool_id $strDesktopGroupName -vm_id_list $strVmsIdList -description $strDesktopGroupDescription  -persistence $persistence -ErrorAction Stop
}

$result
PS_SCRIPT
end

def citrix_4_script(create_new_group, desktopgroup_name, vm_name, hostname, ems, desktopgroup_type, desktopgroup_users, request_task_idx)
<<PS_SCRIPT
#Add the XenDesktop snap-in to the current Powershell session
$required_plugins = @("XDCommands")
foreach ($plugin in $required_plugins) {if ((Get-PSSnapin -Name $plugin -ErrorAction SilentlyContinue) -eq $null) {Add-PSSnapin $plugin -ErrorAction Stop}}

# Define variables for the script
$create_new_group = "#{create_new_group}"
$strDesktopGroupName = "#{desktopgroup_name}"
$strDesktopGroupDescription = "New Desktop Group #{desktopgroup_name} Created by EVM"
$strDesktopGroupUserList = "#{desktopgroup_users}"
$strVMName = "#{vm_name}"         #This is the virtual machine name to add to the desktop group
$strADName = "#{hostname}"         #This is the corresponding Active Directory machine name

# Virtual Center Credentials
$strHypervisorAddress =  "http://"          # Or https
$strHypervisorAddress += "#{ems.hostname}"

# To ensure a specific domain name is used set it here.  Example: ($strDomainName = ".companyname.com")
$strDomainName = ""
if ($strHypervisorAddress -inotlike "*$($strDomainName)*") {$strHypervisorAddress += $strDomainName}

$strHypervisorAddress += "/sdk"
$strHypervisorUser = "#{ems.authentication_userid}"
$strAssignmentBehavior = "#{desktopgroup_type}"
$request_task_idx = #{request_task_idx}

$result = @{"desktop_pool_name"=$strDesktopGroupName; "error"=$false}

function add_users_to_group($strDesktopGroupUserList, $xdgroup) {
  # Add desktop users to group
  $users = $strDesktopGroupUserList.split(",")

  $user_sids = @()
  foreach ($user in $xdgroup.Users) {$user_sids += $user.Sid.Value}

  foreach ($user in $users) {
    $user = $user.Trim()
    if ($user.length -ne 0) {
      $xd_user = New-XdUser $user

      # Check if the user is already in the group
      if ($user_sids -notcontains $xd_user.Sid.Value) {
        miq_logger "info" "Adding User to group: <$user>"
        $xdgroup.Users.Add($xd_user)
      }
    }
  }
}

function add_pre_assigned_user_to_vm($strDesktopGroupUserList, $xdgroup, $vm, $request_task_idx) {
  $users = $strDesktopGroupUserList.split(",")
  $user  = $users[$request_task_idx]
  if ($user -ne $null) {
    $user  = $user.Trim()
    if ($user.length -ne 0) {
      miq_logger "info" "Processing User IDX: $($request_task_idx) <$($user)>"
      $xd_user = New-XdUser -Name $user

      # Check if the user is already in the group and skip assignment if they are.
      $user_sids = @()
      foreach ($desktop in $xdgroup.Desktops) {if ($desktop.AssignedUserSid -ne $null) {$user_sids += $desktop.AssignedUserSid.Value}}

      if ($user_sids -notcontains $xd_user.Sid.Value) {
        # Add User to VM
        if ($xd_user -ne $null) { $vm.AssignedUsername = $xd_user }
      }
      else
      {
        miq_logger "info" "User: <$($user)> already exists in the group and will not be assigned to the new VM."
      }
    }
  }
}

# Connect to the local farm and determine if the desktop group already exists
$farm = New-XdAdminConnection 127.0.0.1
$xdgroup = Get-XdDesktopGroup -Name $strDesktopGroupName -AdminConnection $farm
if ($xdgroup -eq $null) {
  if ($create_new_group -eq "true") {
    miq_logger "info" "Desktop Group <$strDesktopGroupName> does not exist.  Creating."

    # Connect to the hypervisor hosting the VM's using the supplied username/password
    $creds = new-object -typename System.Management.Automation.PSCredential -argumentlist $strHypervisorUser, (ConvertTo-SecureString #{ems.authentication_password_encrypted} -AsPlainText -Force)
    $hs = New-XdHostingServer -address $strHypervisorAddress -provider ( Get-XdHostingProvider -name "VMware virtualization" ) -credential $creds

    # Define the hosting infrastructure settings for the desktop group
    $hgs = New-XdGroupHostingSettings -hostingserver $hs

    miq_logger "info" "Creating Desktop Group:<$strDesktopGroupName>  Assignment:<$strAssignmentBehavior>"
    $xdgroup = New-XdDesktopGroup -Publish $strDesktopGroupName -Description $strDesktopGroupDescription -AdminConnection $farm -hostingsettings $hgs -AssignmentBehavior $strAssignmentBehavior
    Set-XdDesktopGroup $xdgroup | Out-Null

    miq_logger "info" "Desktop Group <$strDesktopGroupName> was created."
  }
  else
  {
    $result["error"] = $true
    $msg = "Desktop Group <$strDesktopGroupName> does not exist"
    miq_logger "error" $msg
    $result["msg"] = $msg
  }
}
else {
  miq_logger "info" "Desktop Group <$strDesktopGroupName> already exists."
}

if ($xdgroup -ne $null) {
  # If Pooled or AssignOnFirstUse we can add the users directly to the group.
  # For PreAssigned we need to add the user to the VM that gets added to the group.
  if ($strAssignmentBehavior -ieq "Pooled" -or  $strAssignmentBehavior -ieq "AssignOnFirstUse") {
    add_users_to_group $strDesktopGroupUserList $xdgroup
  }

  miq_logger "info" "Adding VM <$strVMName> to Desktop Group <$strDesktopGroupName>"
  #Get the VM (virtual desktop) that we want to add to the desktop group
  $vm = Get-XdHostedMachine -HostingServer $xdgroup.HostingSettings.HostingServer -AdminConnection $farm -Name $strVMName
  if ($vm -eq $null) { miq_logger "warn" "Get-XdHostedMachine returned a null VM handle" }

  if ($strAssignmentBehavior -ieq "PreAssigned") {
    add_pre_assigned_user_to_vm $strDesktopGroupUserList $xdgroup $vm $request_task_idx
  }

  #Create the mapping between virtual machine name and Active Directory machine name
  #Note:  When I echo the $vm variable created above, the "Name" property of the virtual machine seems to be already set for me.
  #       This might be because the mapping between VM Name and AD Name has been cached from adding this VM to other desktop groups on prior occasions.
  #       Keeping the statement below won't cause any problems in any case and it should not have to be modified.
  #       Just make sure the Active Directory machine name for this virtual machine is correct as defined above.
  miq_logger "info" "Setting vm.Name to Active Directory machine name = $($strADName)"
  $vm.Name = $strADName;

  #Add the VM (virtual desktop) to the desktop group
  $xdgroup.Desktops.Add($vm)

  #Apply the change to the DDC
  Set-XdDesktopGroup $xdgroup | Out-Null
  miq_logger "info" "VM <$strVMName> added to Desktop Group <$strDesktopGroupName>"
}

# Disconnect from the local farm
Disconnect-XdAdminConnection -AdminConnection $farm

$result
PS_SCRIPT
end

def citrix_5_script(create_new_group, desktopgroup_name, vm_name, hostname, vm_uid_ems, ems, desktopgroup_type, desktopgroup_users, request_task_idx)
<<PS_SCRIPT
# Define variables for the script
$create_new_group = "#{create_new_group}"
$strDesktopGroupName = "#{desktopgroup_name}"
$strDesktopGroupDescription = "New Desktop Group #{desktopgroup_name} Created by EVM"
$strDesktopGroupUserList = "#{desktopgroup_users}"
$strVMName = "#{vm_name}"          # This is the virtual machine name to add to the desktop group
$strADName = "#{hostname}"         # This is the corresponding Active Directory machine name
$strVMHostId = "#{vm_uid_ems}"

# Virtual Center Credentials
$strHypervisorAddress = "http://#{ems.ipaddress}/sdk"
$strHypervisorUser = "#{ems.authentication_userid}"
$strAssignmentBehavior = "#{desktopgroup_type}"
$request_task_idx = #{request_task_idx}

$result = @{"desktop_pool_name"=$strDesktopGroupName; "error"=$false}

function load_citrix_plugin($raise_error = $true, $log_result = $true) {
  $plugin_version = $null

  $requested_plugins = @("XDCommands", "Citrix.Broker.Admin.V1", "Citrix.Host.Admin.V1")
  foreach ($plugin in $requested_plugins) {if ((Get-PSSnapin -Name $plugin -ErrorAction SilentlyContinue) -eq $null) {Add-PSSnapin $plugin -ErrorAction SilentlyContinue}}

  if ((Get-PSSnapin     -Name "Citrix.Broker.Admin.V1" -ErrorAction SilentlyContinue) -ne $null) {$plugin_version = 5}
  elseif ((Get-PSSnapin -Name "XDCommands"             -ErrorAction SilentlyContinue) -ne $null) {$plugin_version = 4}

  if ($plugin_version -eq $null -and $raise_error -eq $true) {throw "No Citrix plug-in found"}
  if ($log_result) {
    if ($plugin_version -eq $null) {miq_logger "warn" "Citrix XenDesktop plugin not found"}
    else                           {miq_logger "info" "Citrix XenDesktop version $($plugin_version) plugin found"}
  }

  return $plugin_version
}

function create_desktop_group($strAssignmentBehavior, $strDesktopGroupName, $strDesktopGroupDescription, $strDesktopGroupUserList) {
  $dg = Get-BrokerDesktopGroup -Name $strDesktopGroupName -ErrorAction SilentlyContinue
  if ($dg -eq $null) {
    if ($strAssignmentBehavior -eq 'Pooled') { $desktop_group_type = 'Shared' }
    else                                     { $desktop_group_type = 'Private' }

    miq_logger "info" "Creating new Desktop Group <$($strDesktopGroupName)> with type <$($desktop_group_type)>"
    $dg = New-BrokerDesktopGroup -DesktopKind $desktop_group_type -Name $strDesktopGroupName -Description $strDesktopGroupDescription

    $apr = Get-BrokerAccessPolicyRule -Name "$($strDesktopGroupName)_Direct" -ErrorAction SilentlyContinue
    if ($apr -eq $null) {$pr = New-BrokerAccessPolicyRule -Name "$($strDesktopGroupName)_Direct" -IncludedDesktopGroups @($strDesktopGroupName) -AllowedConnections 'NotViaAG' -AllowedProtocols @('RDP','HDX') -AllowedUsers 'AnyAuthenticated' -AllowRestart $True -Enabled $True -IncludedDesktopGroupFilterEnabled $True -IncludedSmartAccessFilterEnabled $True -IncludedUserFilterEnabled $True}
    else { $apr | Set-BrokerAccessPolicyRule -AddIncludedDesktopGroups @($strDesktopGroupName)}

    $apr = Get-BrokerAccessPolicyRule -Name "$($strDesktopGroupName)_AG" -ErrorAction SilentlyContinue
    if ($apr -eq $null) {$pr = New-BrokerAccessPolicyRule -Name "$($strDesktopGroupName)_AG" -IncludedDesktopGroups @($strDesktopGroupName) -AllowedConnections 'ViaAG' -AllowedProtocols @('RDP','HDX') -AllowedUsers 'AnyAuthenticated' -AllowRestart $True -Enabled $True -IncludedDesktopGroupFilterEnabled $True -IncludedSmartAccessFilterEnabled $True -IncludedUserFilterEnabled $True}
    else {$apr | Set-BrokerAccessPolicyRule -AddIncludedDesktopGroups @($strDesktopGroupName)}
  }
  else {
    miq_logger "info" "Using existing Desktop Group <$($dg.name)> with type <$($dg.DesktopKind)>"
  }

  if ($dg.DesktopKind -icontains "Shared") {
    $policy_rule = Get-BrokerEntitlementPolicyRule -DesktopGroupUid $dg.Uid
    if ($policy_rule -eq $null) { $policy_rule = New-BrokerEntitlementPolicyRule $strDesktopGroupName -DesktopGroupUid $dg.Uid -PublishedName $strDesktopGroupName }
    add_users_to_group 'Entitlement' $strDesktopGroupUserList $policy_rule
  }
  else {
    $policy_rule = Get-BrokerAssignmentPolicyRule -DesktopGroupUid $dg.Uid
    if ($policy_rule -eq $null) { $policy_rule = New-BrokerAssignmentPolicyRule $strDesktopGroupName -DesktopGroupUid $dg.Uid -PublishedName $strDesktopGroupName }
    add_users_to_group 'Assignment' $strDesktopGroupUserList $policy_rule
  }
  return $dg
}

function add_users_to_group($policy_type, $strDesktopGroupUserList, $policy_rule) {
  $strDesktopGroupUserList.Split(",") | foreach {
    try {
      $user = $_.Trim()
      if ($user.Length -ne 0) {
        miq_logger "info" "Adding User <$user> to group"
        if ($policy_rule -is [System.Array]) {$policy_rule = $policy_rule[0]}
        if ($policy_type -eq 'Assignment') { $policy_rule | Set-BrokerAssignmentPolicyRule  -AddIncludedUsers $_ -ErrorAction SilentlyContinue }
        else                               { $policy_rule | Set-BrokerEntitlementPolicyRule -AddIncludedUsers $_ -ErrorAction SilentlyContinue }
      }
    }
    catch { miq_logger "warn" "Failed to add user: $($user).  Error: $($_)" }
  }
}

function resolve_url_to_ip($url) {
  $result = $null
  if ($url -imatch "https?://(.*)/") {
    $hosting_addr = $Matches[1]
    try { $result = [System.Net.Dns]::GetHostAddresses($hosting_addr)[0].IPAddressToString } catch {}
  }
  return $result
}

function find_connection_server($url, $username) {
  $result = $null
  $backslash_char = [char]92
  $requested_ip = resolve_url_to_ip $url
  Get-ChildItem (get-item -Path ('xdhyp:' + $backslash_char + 'Connections')).PSPath | foreach {
    if ($result -eq $null) {
      if (((resolve_url_to_ip $_.HypervisorAddress[0]) -eq $requested_ip) -and ($username.ToLower() -eq $_.UserName.ToLower())) {
        $result = Get-BrokerHypervisorConnection -HypHypervisorConnectionUid $_.HypervisorConnectionUid
      }
    }
  }
  return $result
}

function create_new_connection($url, $username) {
  $conn_name = ""
  $backslash_char = [char]92
  if ($url -imatch "https?://(.*)/") { $conn_name = $Matches[1] }
  $conn_name = $conn_name.Replace(".", "_")
  miq_logger "info" "Creating new connection server <$($conn_name)> for user <$($username)>"
  $new_conn = New-Item -Path ('xdhyp:' + $backslash_char + 'Connections') -Name $conn_name -HypervisorAddress @($url) -ConnectionType 'VCenter' -Username $username -Persist -Password 'smartvm'
  $hc = New-BrokerHypervisorConnection -HypHypervisorConnectionUid $new_conn.HypervisorConnectionUid
  return $hc
}

function get_connection_server($url, $username) {
  $hc = find_connection_server $url  $username
  if ($hc -eq $null) {$hc = create_new_connection $url $username}
  else               { miq_logger "info" "Using existing connection server <$($hc.Name)> with user credentials <$($username)>" }
  return $hc
}

function add_desktop_to_catalog($bhc, $dg, $strVMHostId, $strVMName, $strADName, $strAssignmentBehavior, $strDesktopGroupUserList, $request_task_idx) {
  $bc_name = $dg.name + " Catalog"
  $bc = Get-BrokerCatalog -Name $bc_name -ErrorAction SilentlyContinue
  if ($bc -eq $null) {
    if ($dg.DesktopKind -icontains "Shared") {$allocation_type = 'Random'}
    else                                     {$allocation_type = 'Permanent'}
    miq_logger "info" "Creating Machine Catalog <$($bc_name)> with AllocationType <$($allocation_type)>"
    $bc = New-BrokerCatalog -AllocationType $allocation_type -CatalogKind PowerManaged -Name $bc_name
  }
  else {
    miq_logger "info" "Using existing Machine Catalog <$($bc.name)> with AllocationType <$($bc.AllocationType)>"
  }

  miq_logger "info" "Adding VM <$($strVMName)> with uid <$($strVMHostId)> and machine name <$($strADName)> to catalog"
  $bm = New-BrokerMachine -HostedMachineId $strVMHostId -MachineName $strADName -CatalogUid $bc.Uid -HypervisorConnectionUid $bhc.Uid
  miq_logger "info" "Adding VM to Desktop Group"
  $add_count = Add-BrokerMachinesToDesktopGroup -Catalog $bc -DesktopGroup $dg -Count 1

  # Pre-assign a user to this VM
  if ($strAssignmentBehavior -eq "PreAssigned") {
    $users = $strDesktopGroupUserList.split(",")
    $user  = $users[$request_task_idx]
    if ($user -ne $null) {
      $user  = $user.Trim()
      if ($user.length -ne 0) {
        miq_logger "info" "Adding User IDX: $($request_task_idx) <$($user)> to Desktop <$($bm.MachineName)>"
        Add-BrokerUser -Name $user -Machine $bm.MachineName
      }
    }
  }
}

$plugin_version = load_citrix_plugin
$bhc = get_connection_server $strHypervisorAddress $strHypervisorUser
$dg = create_desktop_group $strAssignmentBehavior $strDesktopGroupName $strDesktopGroupDescription $strDesktopGroupUserList
if ($dg -is [System.Array]) {$dg = $dg[0]}
add_desktop_to_catalog $bhc $dg $strVMHostId $strVMName $strADName $strAssignmentBehavior $strDesktopGroupUserList $request_task_idx

$result
PS_SCRIPT
end


begin
  @method = 'vdi_add_vm_to_desktop_pool'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  prov = $evm.root["miq_provision"]
  $evm.log("info", "MIQ Provision Attribute info: #{prov.attributes.inspect}") if @debug

  # Determine if the Desktop tab was enabled and a valid VDI Farm selected.
  vdi_farm = prov.vdi_farm
  if vdi_farm.nil?
    exit MIQ_OK
  end

  proxy = vdi_farm.active_proxy
  if proxy.nil?
    $evm.log("error", "Could not find Active MiqProxy for VDI Farm #{vdi_farm.name}")
    exit MIQ_ABORT
  end

  # Load resources needed by the powershell script
  vdi_vendor = vdi_farm.nil? ? nil : vdi_farm.vendor
  ems = prov.vm_template.ext_management_system
  create_new_group = prov.get_option(:vdi_desktop_pool_create)
  desktopgroup_users = prov.get_option(:vdi_desktop_pool_user_list).to_s.split(',').collect{|user| user.split(' ')}.flatten.uniq.join(", ")
  request_task_idx   = prov.get_option(:pass).to_i - 1
  if create_new_group
    desktopgroup_name = prov.get_option(:vdi_new_desktop_pool_name)
    desktopgroup_type = prov.get_option(:vdi_new_desktop_pool_assignment)
    $evm.log("info", "Checking or creating Desktop Pool:  #{desktopgroup_name}")
  else
    desktopgroup_name = prov.get_option_last(:vdi_desktop_pool)
    $evm.log("info", "Checking for Desktop Pool:  #{desktopgroup_name}")
  end

  vm_name = prov.get_option(:vm_target_name).to_s.strip
  $evm.log("info", "VM Name:  #{vm_name}")

  #
  if vdi_vendor == 'citrix'

    full_hostname = prov.vm.hostnames.first
    hostname = full_hostname.to_s.split('.').first
    $evm.log("info", "VM Hostname:  #{hostname}")
    vm_uid_ems = prov.vm.uid_ems

    ps_script = if vdi_farm.version_major_minor.to_i == 4
      citrix_4_script(
                      create_new_group,
                      desktopgroup_name,
                      vm_name,
                      hostname,
                      ems,
                      desktopgroup_type,
                      desktopgroup_users,
                      request_task_idx)
    else
      citrix_5_script(
                      create_new_group,
                      desktopgroup_name,
                      vm_name,
                      hostname,
                      vm_uid_ems,
                      ems,
                      desktopgroup_type,
                      desktopgroup_users,
                      request_task_idx)
    end

  elsif vdi_vendor == 'vmware'
    vm_id_list = []
    vm_name_list = []
    ps_script = nil
    prov_req = prov.miq_provision_request

    dp_created_key = "vdi_desktop_create_initiated_#{prov_req.id}".to_sym
    unless prov_req.get_option(dp_created_key) == true
      number_of_vms_being_provisioned = prov_req.get_option(:number_of_vms).to_i

      prov_req.miq_provisions.each do |mp|
        vm = mp.vm
        vm_id_list   << "VirtualMachine-#{vm.ems_ref}" unless vm.nil?
        vm_name_list << vm.name unless vm.nil?
      end

      ps_script = nil
      if number_of_vms_being_provisioned == vm_id_list.length
        vms_id_list = vm_id_list.join(";")
        prov_req.set_option(dp_created_key, true)
        $evm.log("info", "Creating new Desktop Pool for VMs: <#{vm_name_list.inspect}>")
        ps_script = vmware_view_script(
                        create_new_group,
                        desktopgroup_name,
                        ems,
                        desktopgroup_type,
                        vms_id_list,
                        vm_name_list.join(", "))
      end
    else
      $evm.log("info", "Desktop Pool creation already initiated for this request.")
    end
  end

  unless ps_script.nil?
    $evm.log("info", "Powershell Script:\n#{ps_script}")
    result = proxy.powershell(ps_script, 'object')
    result = result.first
    $evm.log("info", "PShell Method returned: <#{result.inspect}>")
    if result[:error] == true
      $evm.log("error", result[:msg])
      exit MIQ_ABORT
    end
  else
    $evm.log("info", "Powershell script skipped on this pass.")
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} err [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vdi_wait_for_hostname" language="ruby" scope="instance" location="inline" display_name="VDI wait for hostname"><![CDATA[###################################
#
# EVM Automate Method: vdi_wait_for_hostname
#
# Notes: This method waits for the VM's hostname, then starts the VM
#
###################################
begin
  @method = 'vdi_wait_for_hostname'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  prov   = $evm.root["miq_provision"]
  result = 'ok'

  # Determine if the Desktop tab was enabled and a valid VDI Farm selected.
  vdi_farm = prov.vdi_farm
  vdi_vendor = vdi_farm.nil? ? nil : vdi_farm.vendor
  if vdi_vendor == "citrix"
    result = 'retry'
    full_hostname = prov.vm.hostnames.first
    unless full_hostname.nil?
      if full_hostname.to_s.split('.').length > 1
        result = 'ok'
      end
    end
    $evm.log("info", "#{@method} - VM Hostname:  #{full_hostname.inspect}") if @debug
  else
    result = 'ok'
  end

  $evm.log('info', "#{@method} - VDI Hostname check returned <#{result}>") if @debug

  case result
  when 'error'
    $evm.root['ae_result'] = 'error'
    reason = $evm.root['miq_provision'].message
    reason = reason[7..-1] if reason[0..6] == 'Error: '
    $evm.root['ae_reason'] = reason
  when 'retry'
    prov.vm.start unless prov.vm.power_state == 'on'
    prov.vm.refresh
    $evm.root['ae_result']         = 'retry'
    $evm.root['ae_retry_interval'] = '60.seconds'
  when 'ok'
    # Bump State
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="CheckPoweredOff">
      <MiqAeField name="execute">
check_powered_off      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CheckProvisioned">
      <MiqAeField name="execute">
check_provisioned      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CheckUnregisteredFromVC">
      <MiqAeField name="execute">
check_unregistered_from_vc      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CustomizeRequest">
      <MiqAeField name="execute">
CustomizeRequest      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="DeleteFromVC">
      <MiqAeField name="execute">
delete_from_vc      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="DeleteFromVMDB">
      <MiqAeField name="execute">
delete_from_vmdb      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PostProvision">
      <MiqAeField name="execute">
PostProvision      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PostProvision_Clone_to_VM">
      <MiqAeField name="execute">
PostProvision_Clone_to_VM      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PowerOff">
      <MiqAeField name="execute">
power_off      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PreDeleteFromVC">
      <MiqAeField name="execute">
PreDeleteFromVC      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PreProvision">
      <MiqAeField name="execute">
PreProvision      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PreProvision_Clone_to_Template">
      <MiqAeField name="execute">
PreProvision_Clone_to_Template      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PreProvision_Clone_to_VM">
      <MiqAeField name="execute">
PreProvision_Clone_to_VM      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Provision">
      <MiqAeField name="execute">
provision      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="UnregisterFromVC">
      <MiqAeField name="execute">
unregister_from_vc      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VdiAddVmToDesktopPool">
      <MiqAeField name="execute">
vdi_add_vm_to_desktop_pool      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VdiWaitForHostname">
      <MiqAeField name="execute">
vdi_wait_for_hostname      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VMMigrate" namespace="Factory" display_name="VM Migrate">
    <MiqAeMethod name="BestHost" language="ruby" scope="instance" location="inline"><![CDATA[#
#            EVM Automate Method
#
$evm.log("info", "EVM Automate Method Started")
#
#            Method Code Goes here
#

#
#
#
$evm.log("info", "EVM Automate Method Ended")
exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="BestStorage" language="ruby" scope="instance" location="inline"><![CDATA[#
#            EVM Automate Method
#
$evm.log("info", "EVM Automate Method Started")
#
#            Method Code Goes here
#

#
#
#
$evm.log("info", "EVM Automate Method Ended")
exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="CheckMigration" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: CheckMigration
#
# Notes: This method checks to see if the VM has been migrated
#
###################################
begin
  @method = 'CheckMigration'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Get current provisioning status
  result = $evm.root["vm_migrate_task"].status

  $evm.log('info', "#{@method} returned <#{result}>")

  case result
  when 'error'
    $evm.root['ae_result'] = 'error'
    reason = $evm.root['miq_provision'].message
    reason = reason[7..-1] if reason[0..6] == 'Error: '
    $evm.root['ae_reason'] = reason
  when 'retry'
    $evm.root['ae_result']      = 'retry'
    $evm.root['ae_retry_interval'] = '1.minute'
  when 'ok'
    # Bump State
    $evm.root['ae_result'] = 'ok'
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Migrate" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Migrate
#
# Notes: This method launches the migration job
#
###################################
begin
  @method = 'Migrate'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")


  $evm.root["vm_migrate_task"].execute


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PostMigration" language="ruby" scope="instance" location="inline"><![CDATA[#
#            EVM Automate Method
#
$evm.log("info", "EVM Automate Method Started")
#
#            Method Code Goes here
#

#
#
#
$evm.log("info", "EVM Automate Method Ended")
exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="PreMigration" language="ruby" scope="instance" location="inline"><![CDATA[#
#            EVM Automate Method
#
$evm.log("info", "EVM Automate Method Started")
#
#            Method Code Goes here
#

#
#
#
$evm.log("info", "EVM Automate Method Ended")
exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="BestHost">
      <MiqAeField name="execute">
BestHost      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="BestStorage">
      <MiqAeField name="execute">
BestStorage      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CheckMigration">
      <MiqAeField name="execute">
CheckMigration      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Migrate">
      <MiqAeField name="execute">
Migrate      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PostMigration">
      <MiqAeField name="execute">
PostMigration      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PreMigration">
      <MiqAeField name="execute">
PreMigration      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="CMDB" namespace="Integration" description="CMDB" display_name="Configuration Management Database">
    <MiqAeSchema>
      <MiqAeField name="database" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="username" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="password" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="procedure_name" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="before_execute" substitute="true" aetype="relationship" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="6" message="create" collect="result">
      </MiqAeField>
      <MiqAeField name="after_execute" substitute="true" aetype="method" datatype="string" priority="7" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing" display_name="Called when Specified Instance is Missing">
    </MiqAeInstance>
    <MiqAeInstance name="Activate" display_name="Activate CI" description="Interface to Activate a CMDB Entry">
    </MiqAeInstance>
    <MiqAeInstance name="Deactivate" display_name="Deactivate CI">
    </MiqAeInstance>
    <MiqAeInstance name="Register" display_name="Register CI">
    </MiqAeInstance>
    <MiqAeInstance name="Unregister" display_name="Unregister CI">
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Event" namespace="Integration" description="Event" display_name="Event">
    <MiqAeMethod name="EVMSNMP" language="ruby" scope="class" location="inline"><![CDATA[]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="EVMOid" substitute="true" aetype="attribute" datatype="string" priority="1" message="create" description="Enterprise Number for ManageIQ EVM">
1.3.6.1.4.1.33482      </MiqAeField>
      <MiqAeField name="Severity" substitute="true" aetype="attribute" datatype="string" priority="2" message="create" description="Information, Warning or Error">
Information      </MiqAeField>
      <MiqAeField name="Platform" substitute="true" aetype="attribute" datatype="string" priority="3" message="create" description="Platform">
EVM      </MiqAeField>
      <MiqAeField name="Url" substitute="true" aetype="attribute" datatype="string" priority="4" message="create" description="EVM URL">
URL      </MiqAeField>
      <MiqAeField name="Source" substitute="true" aetype="attribute" datatype="string" priority="5" message="create" description="Source of Event">
Source      </MiqAeField>
      <MiqAeField name="Description" substitute="true" aetype="attribute" datatype="string" priority="6" message="create" description="Description of Alert">
Description      </MiqAeField>
      <MiqAeField name="Category" substitute="true" aetype="attribute" datatype="string" priority="7" message="create" description="Category">
Category      </MiqAeField>
      <MiqAeField name="Message" substitute="true" aetype="attribute" datatype="string" priority="8" message="create" description="Message Text">
Message      </MiqAeField>
      <MiqAeField name="Location" substitute="true" aetype="attribute" datatype="string" priority="9" message="create" description="Location">
Location      </MiqAeField>
      <MiqAeField name="Custom1" substitute="true" aetype="attribute" datatype="string" priority="10" message="create" description="Custom Field 1">
Custom Field 1      </MiqAeField>
      <MiqAeField name="Custom2" substitute="true" aetype="attribute" datatype="string" priority="11" message="create" description="Custom Field 2">
Custom Field 2      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Error" display_name="Event - Error">
      <MiqAeField name="Severity">
3      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Information" display_name="Event - Information">
      <MiqAeField name="Severity">
1      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Warning" display_name="Event - Warning">
      <MiqAeField name="Severity">
2      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="HPOM" namespace="Integration" display_name="HP Operations Manager">
    <MiqAeMethod name="HPOM_EMS_Cluster_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: HPOM_EMS_Cluster_Alert
#
# This method is used to send HPOM Alerts based on Cluster
#
###################################
begin
  @method = 'HPOM_EMS_Cluster_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body which map to opcmsg_msg_grp and opcmsg_msg_text
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(ems_cluster)

    # Build options Hash
    options = {}

    options[:object] = "Cluster - #{ems_cluster.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | Cluster: [#{ems_cluster.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>Cluster <b>#{ems_cluster.name}</b> Properties:"
    body += "<br>Cluster URL: <a href='https://#{appliance}/ems_cluster/show/#{ems_cluster.id}'>https://#{appliance}/ems_cluster/show/#{ems_cluster.id}</a>"    
    body += "<br>Total Host CPU Resources: #{ems_cluster.aggregate_cpu_speed}"
    body += "<br>Total Host Memory: #{ems_cluster.aggregate_memory}"
    body += "<br>Total Host CPUs: #{ems_cluster.aggregate_physical_cpus}"
    body += "<br>Total Host CPU Cores: #{ems_cluster.aggregate_logical_cpus}"
    body += "<br>Total Configured VM Memory: #{ems_cluster.aggregate_vm_memory}"
    body += "<br>Total Configured VM CPUs: #{ems_cluster.aggregate_vm_cpus}"
    body += "<br><br>"


    body += "<br>Configuration:"
    body += "<br>HA Enabled: #{ems_cluster.ha_enabled}"
    body += "<br>HA Admit Control: #{ems_cluster.ha_admit_control}"
    body += "<br>DRS Enabled: #{ems_cluster.drs_enabled}"
    body += "<br>DRS Automation Level: #{ems_cluster.drs_automation_level}"
    body += "<br>DRS Migration Threshold: #{ems_cluster.drs_migration_threshold}"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Datacenter: #{ems_cluster.v_parent_datacenter}"
    body += "<br>Hosts: #{ems_cluster.total_hosts}"
    body += "<br>VM(s): #{ems_cluster.total_vms}"
    body += "<br><br>"

    body += "<br>Cluster Tags:"
    body += "<br>#{ems_cluster.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: call_opcmsg
  #
  # Notes: Run opcmsg to send an event to HP Operations Manager
  #
  ###################################
  def call_opcmsg(options)
    opcmsg_path = "/opt/OV/bin/opcmsg"
    raise "#{@method} - File '#{opcmsg_path}' does not exist" unless File.exist?(opcmsg_path)
    $evm.log("info","#{@method} - Found opcmsg_path:<#{opcmsg_path}>") if @debug

    cmd  = "#{opcmsg_path}"
    cmd += " application=\"#{$evm.object['opcmsg_application']}\""
    cmd += " object=\"#{options[:object]}\""
    cmd += " msg_text=\"#{options[:body]}\""
    cmd += " severity=\"#{$evm.object['opcmsg_severity']}\""
    cmd += " msg_grp=\"#{options[:alert]}\""

    $evm.log("info","#{@method} - Calling:<#{cmd}>") if @debug
    require 'open4'
    pid = nil
    stderr = nil
    results = Open4.popen4(cmd) do |pid, stdin, stdout, stderr|
      stderr.each_line { |msg| $evm.log("error","#{@method} - Method STDERR:<#{msg.strip}>") }
      stdout.each_line { |msg| $evm.log("info","#{@method} - Method STDOUT:<#{msg.strip}>") }
    end
    $evm.log("info","#{@method} - Inspecting Results:<#{results.inspect}>") if @debug
  end


  ems_cluster = $evm.root['ems_cluster']

  unless ems_cluster.nil?
    $evm.log("info", "#{@method} - Detected Cluster:<#{ems_cluster.name}>") if @debug

    # If email is set to true in the model
    options = buildDetails(ems_cluster)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

    call_opcmsg(options)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="HPOM_Ext_Management_System_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: HPOM_Ext_Management_System_Alert
#
# This method is used to send HPOM Alerts based on vCenter
#
###################################
begin
  @method = 'HPOM_Ext_Management_System_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body which map to opcmsg_msg_grp and opcmsg_msg_text
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(ext_management_system)

    # Build options Hash
    options = {}

    options[:object] = "vCenter - #{ext_management_system.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | vCenter: [#{ext_management_system.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>vCenter <b>#{ext_management_system.name}</b> Properties:"
    body += "<br>Hostname: #{ext_management_system.hostname}"
    body += "<br>IP Address(es): #{ext_management_system.ipaddress}"
    body += "<br>Host Information:"
    body += "<br>Aggregate Host CPU Speed: #{ext_management_system.aggregate_cpu_speed.to_i / 1000} Ghz"
    body += "<br>Aggregate Host CPU Cores: #{ext_management_system.aggregate_logical_cpus}"
    body += "<br>Aggregate Host CPUs: #{ext_management_system.hardware.aggregate_physical_cpus}"
    body += "<br>Aggregate Host Memory: #{ext_management_system.aggregate_memory}"
    body += "<br>SSH Permit Root: #{ext_management_system.aggregate_vm_cpus}"
    body += "<br><br>"


    body += "<br>VM Information:"
    body += "<br>Aggregate VM Memory: #{ext_management_system.aggregate_vm_memory} bytes"
    body += "<br>Aggregate VM CPUs: #{ext_management_system.aggregate_vm_cpus} bytes"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Hosts: #{ext_management_system.total_hosts}"
    body += "<br>Datastores: #{ext_management_system.total_storages}"
    body += "<br>VM(s): #{ext_management_system.total_vms}"
    body += "<br><br>"

    body += "<br>Host Tags:"
    body += "<br>#{ext_management_system.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: call_opcmsg
  #
  # Notes: Run opcmsg to send an event to HP Operations Manager
  #
  ###################################
  def call_opcmsg(options)
    opcmsg_path = "/opt/OV/bin/opcmsg"
    raise "#{@method} - File '#{opcmsg_path}' does not exist" unless File.exist?(opcmsg_path)
    $evm.log("info","#{@method} - Found opcmsg_path:<#{opcmsg_path}>") if @debug

    cmd  = "#{opcmsg_path}"
    cmd += " application=\"#{$evm.object['opcmsg_application']}\""
    cmd += " object=\"#{options[:object]}\""
    cmd += " msg_text=\"#{options[:body]}\""
    cmd += " severity=\"#{$evm.object['opcmsg_severity']}\""
    cmd += " msg_grp=\"#{options[:alert]}\""

    $evm.log("info","#{@method} - Calling:<#{cmd}>") if @debug
    require 'open4'
    pid = nil
    stderr = nil
    results = Open4.popen4(cmd) do |pid, stdin, stdout, stderr|
      stderr.each_line { |msg| $evm.log("error","#{@method} - Method STDERR:<#{msg.strip}>") }
      stdout.each_line { |msg| $evm.log("info","#{@method} - Method STDOUT:<#{msg.strip}>") }
    end
    $evm.log("info","#{@method} - Inspecting Results:<#{results.inspect}>") if @debug
  end


  ext_management_system = $evm.root['ext_management_system']

  unless ext_management_system.nil?
    $evm.log("info", "#{@method} - Detected Host:<#{host.name}>") if @debug

    # If email is set to true in the model
    options = buildDetails(ext_management_system)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

    call_opcmsg(options)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="HPOM_Host_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: HPOM_Host_Alert
#
# This method is used to send HPOM Alerts based on Host
#
###################################
begin
  @method = 'HPOM_Host_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body which map to opcmsg_msg_grp and opcmsg_msg_text
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(host)

    # Build options Hash
    options = {}

    options[:object] = "Host - #{host.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | Host: [#{host.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>Host <b>#{host.name}</b> Properties:"
    body += "<br>Host URL: <a href='https://#{appliance}/host/show/#{host.id}'>https://#{appliance}/host/show/#{host.id}</a>"
    body += "<br>Hostname: #{host.hostname}"
    body += "<br>IP Address(es): #{host.ipaddress}"
    body += "<br>CPU Type: #{host.hardware.cpu_type}"
    body += "<br>Cores per Socket: #{host.hardware.logical_cpus}"
    body += "<br>vRAM: #{host.hardware.memory_cpu.to_i / 1024} GB"
    body += "<br>Operating System: #{host.vmm_product} #{host.vmm_version} Build #{host.vmm_buildnumber}"
    body += "<br>SSH Permit Root: #{host.ssh_permit_root_login}"
    body += "<br><br>"


    body += "<br>Power Maangement:"
    body += "<br>Power State: #{host.power_state}"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Datacenter: #{host.v_owning_datacenter}"
    body += "<br>Cluster: #{host.v_owning_cluster}"
    body += "<br>Datastores: #{host.v_total_storages}"
    body += "<br>VM(s): #{host.v_total_vms}"
    body += "<br><br>"

    body += "<br>Host Tags:"
    body += "<br>#{host.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: call_opcmsg
  #
  # Notes: Run opcmsg to send an event to HP Operations Manager
  #
  ###################################
  def call_opcmsg(options)
    opcmsg_path = "/opt/OV/bin/opcmsg"
    raise "#{@method} - File '#{opcmsg_path}' does not exist" unless File.exist?(opcmsg_path)
    $evm.log("info","#{@method} - Found opcmsg_path:<#{opcmsg_path}>") if @debug

    cmd  = "#{opcmsg_path}"
    cmd += " application=\"#{$evm.object['opcmsg_application']}\""
    cmd += " object=\"#{options[:object]}\""
    cmd += " msg_text=\"#{options[:body]}\""
    cmd += " severity=\"#{$evm.object['opcmsg_severity']}\""
    cmd += " msg_grp=\"#{options[:alert]}\""

    $evm.log("info","#{@method} - Calling:<#{cmd}>") if @debug
    require 'open4'
    pid = nil
    stderr = nil
    results = Open4.popen4(cmd) do |pid, stdin, stdout, stderr|
      stderr.each_line { |msg| $evm.log("error","#{@method} - Method STDERR:<#{msg.strip}>") }
      stdout.each_line { |msg| $evm.log("info","#{@method} - Method STDOUT:<#{msg.strip}>") }
    end
    $evm.log("info","Inspecting Results:<#{results.inspect}>") if @debug
  end


  host = $evm.root['host']

  unless host.nil?
    $evm.log("info", "#{@method} - Detected Host:<#{host.name}>") if @debug

    # If email is set to true in the model
    options = buildDetails(host)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

    call_opcmsg(options)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="HPOM_MIQ_Server_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: HPOM_MIQ_Server_Alert
#
# This method is used to send HPOM Alerts based on EVM Server
#
###################################
begin
  @method = 'HPOM_MIQ_Server_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body which map to opcmsg_msg_grp and opcmsg_msg_text
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(miq_server)

    # Build options Hash
    options = {}

    options[:object] = "EVM Server - #{miq_server.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | EVM Server: [#{miq_server.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>EVM Server <b>#{miq_server.name}</b> Properties:"
    body += "<br>EVM Server URL: <a href='https://#{miq_server.ipaddress}'>https://#{miq_server.ipaddress}</a>"
    body += "<br>Hostname: #{miq_server.hostname}"
    body += "<br>IP Address: #{miq_server.ipaddress}"
    body += "<br>MAC Address: #{miq_server.mac_address}"
    body += "<br>Last Heartbeat: #{miq_server.last_heartbeat}"
    body += "<br>Master: #{miq_server.is_master}"
    body += "<br>Status: #{miq_server.status}"
    body += "<br>Started On: #{miq_server.started_on}"
    body += "<br>Stopped On: #{miq_server.stopped_on}"
    body += "<br>Version: #{miq_server.version}"
    body += "<br>Zone: #{miq_server.zone}"
    body += "<br>Id: #{miq_server.id}"
    body += "<br><br>"

    body += "<br>Details:"
    body += "<br>Memory Percentage: #{miq_server.percent_memory}"
    body += "<br>Memory Usage: #{miq_server.memory_usage}"
    body += "<br>Memory Size: #{miq_server.memory_size}"
    body += "<br>CPU Percent: #{miq_server.percent_cpu}"
    body += "<br>CPU Time: #{miq_server.cpu_time}"
    body += "<br>Capabilities: #{miq_server.capabilities.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: call_opcmsg
  #
  # Notes: Run opcmsg to send an event to HP Operations Manager
  #
  ###################################
  def call_opcmsg(options)
    opcmsg_path = "/opt/OV/bin/opcmsg"
    raise "#{@method} - File '#{opcmsg_path}' does not exist" unless File.exist?(opcmsg_path)
    $evm.log("info","#{@method} - Found opcmsg_path:<#{opcmsg_path}>") if @debug

    cmd  = "#{opcmsg_path}"
    cmd += " application=\"#{$evm.object['opcmsg_application']}\""
    cmd += " object=\"#{options[:object]}\""
    cmd += " msg_text=\"#{options[:body]}\""
    cmd += " severity=\"#{$evm.object['opcmsg_severity']}\""
    cmd += " msg_grp=\"#{options[:alert]}\""

    $evm.log("info","#{@method} - Calling:<#{cmd}>") if @debug
    require 'open4'
    pid = nil
    stderr = nil
    results = Open4.popen4(cmd) do |pid, stdin, stdout, stderr|
      stderr.each_line { |msg| $evm.log("error","#{@method} - Method STDERR:<#{msg.strip}>") }
      stdout.each_line { |msg| $evm.log("info","#{@method} - Method STDOUT:<#{msg.strip}>") }
    end
    $evm.log("info","#{@method} - Inspecting Results:<#{results.inspect}>") if @debug
  end


  miq_server = $evm.root['miq_server']

  unless miq_server.nil?
    $evm.log("info", "#{@method} - Detected EVM Server:<#{miq_server.name}>") if @debug

    # If email is set to true in the model
    options = buildDetails(miq_server)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

    call_opcmsg(options)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="HPOM_Storage_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: HPOM_Storage_Alert
#
# This method is used to send HPOM Alerts based on Datastore
#
###################################
begin
  @method = 'HPOM_Storage_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body which map to opcmsg_msg_grp and opcmsg_msg_text
  # 
  # Returns: options Hash
  #
  ###################################
  def buildDetails(storage)

    # Build options Hash
    options = {}

    options[:object] = "Datastore - #{storage.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | Datastore: [#{storage.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention, "
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>Storage <b>#{storage.name}</b> Properties:"
    body += "<br>Storage URL: <a href='https://#{appliance}/Storage/show/#{storage.id}'>https://#{appliance}/Storage/show/#{storage.id}</a>"
    body += "<br>Type: #{storage.store_type}"
    body += "<br>Free Space: #{storage.free_space.to_i / (1024**3)} GB (#{storage.v_free_space_percent_of_total}%)"
    body += "<br>Used Space: #{storage.v_used_space.to_i / (1024**3)} GB (#{storage.v_used_space_percent_of_total}%)"
    body += "<br>Total Space: #{storage.total_space.to_i / (1024**3)} GB"
    body += "<br><br>"

    body += "<br>Information for Registered VMs:"
    body += "<br>Used + Uncommitted Space: #{storage.v_total_provisioned.to_i / (1024**3)} GB (#{storage.v_provisioned_percent_of_total}%)"
    body += "<br><br>"

    body += "<br>Content:"
    body += "<br>VM Provisioned Disk Files: #{storage.disk_size.to_i / (1024**3)} GB (#{storage.v_disk_percent_of_used}%)"
    body += "<br>VM Snapshot Files: #{storage.snapshot_size.to_i / (1024**3)} GB (#{storage.v_snapshot_percent_of_used}%)"
    body += "<br>VM Memory Files: #{storage.v_total_memory_size.to_i / (1024**3)} GB (#{storage.v_memory_percent_of_used}%)"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Number of Hosts attached: #{storage.v_total_hosts}"
    body += "<br>Total Number of VMs: #{storage.v_total_vms}"
    body += "<br><br>"

    body += "<br>Datastore Tags:"
    body += "<br>#{storage.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: call_opcmsg
  #
  # Notes: Run opcmsg to send an event to HP Operations Manager
  #
  ###################################
  def call_opcmsg(options)
    opcmsg_path = "/opt/OV/bin/opcmsg"
    raise "#{@method} - File '#{opcmsg_path}' does not exist" unless File.exist?(opcmsg_path)
    $evm.log("info","#{@method} - Found opcmsg_path:<#{opcmsg_path}>") if @debug

    cmd  = "#{opcmsg_path}"
    cmd += " application=\"#{$evm.object['opcmsg_application']}\""
    cmd += " object=\"#{options[:object]}\""
    cmd += " msg_text=\"#{options[:body]}\""
    cmd += " severity=\"#{$evm.object['opcmsg_severity']}\""
    cmd += " msg_grp=\"#{options[:alert]}\""

    $evm.log("info","#{@method} - Calling:<#{cmd}>") if @debug
    require 'open4'
    pid = nil
    stderr = nil
    results = Open4.popen4(cmd) do |pid, stdin, stdout, stderr|
      stderr.each_line { |msg| $evm.log("error","#{@method} - Method STDERR:<#{msg.strip}>") }
      stdout.each_line { |msg| $evm.log("info","#{@method} - Method STDOUT:<#{msg.strip}>") }
    end
    $evm.log("info","#{@method} - Inspecting Results:<#{results.inspect}>") if @debug
  end


  storage = $evm.root['storage']

  unless storage.nil?
    # If email is set to true in the model
    options = buildDetails(storage)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

    call_opcmsg(options)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="HPOM_VM_Alert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: HPOM_VM_Alert
#
# This method is used to send HPOM Alerts based on VM
#
###################################
begin
  @method = 'HPOM_VM_Alert'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###################################
  #
  # Method: buildDetails
  #
  # Notes: Build email subject and body which map to opcmsg_msg_grp and opcmsg_msg_text
  #
  # Returns: options Hash
  #
  ###################################
  def buildDetails(vm)

    # Build options Hash
    options = {}

    options[:object] = "VM - #{vm.name}"

    # Set alert to alert description
    options[:alert] = $evm.root['miq_alert_description']

    # Get Appliance name from model unless specified below
    appliance = nil
    #appliance ||= $evm.object['appliance']
    appliance ||= $evm.root['miq_server'].ipaddress

    # Get signature from model unless specified below
    signature = nil
    signature ||= $evm.object['signature']

    # Build Email Subject
    subject = "#{options[:alert]} | VM: [#{vm.name}]"
    options[:subject] = subject

    # Build Email Body
    body = "Attention,"
    body += "<br>EVM Appliance: #{$evm.root['miq_server'].hostname}"
    body += "<br>EVM Region: #{$evm.root['miq_server'].region_number}"
    body += "<br>Alert: #{options[:alert]}"
    body += "<br><br>"

    body += "<br>VM <b>#{vm.name}</b> Properties:"
    body += "<br>VM URL: <a href='https://#{appliance}/vm_or_template/show/#{vm.id}'>https://#{appliance}/vm_or_template/show/#{vm.id}</a>"
    body += "<br>Hostname: #{vm.hostnames.inspect}"
    body += "<br>IP Address(es): #{vm.ipaddresses.inspect}"
    body += "<br>vCPU: #{vm.num_cpu}"
    body += "<br>vRAM: #{vm.mem_cpu.to_i} MB"
    body += "<br>Tools Status: #{vm.tools_status}"
    body += "<br>Operating System: #{vm.operating_system['product_name']}"
    body += "<br>Disk Alignment: #{vm.disks_aligned}"
    body += "<br><br>"


    body += "<br>Power Maangement:"
    body += "<br>Power State: #{vm.power_state}"
    body += "<br>Last Boot: #{vm.boot_time}"
    body += "<br><br>"

    body += "<br>Snapshot Information:"
    body += "<br>Total Snapshots: #{vm.v_total_snapshots}"
    body += "<br>Total Snapshots: #{vm.v_total_snapshots}"
    body += "<br><br>"

    body += "<br>Relationships:"
    body += "<br>Datacenter: #{vm.v_owning_datacenter}"
    body += "<br>Cluster: #{vm.ems_cluster_name}"
    body += "<br>Host: #{vm.host_name}"
    body += "<br>Datastore Path: #{vm.v_datastore_path}"
    body += "<br>Resource Pool: #{vm.v_owning_resource_pool}"
    body += "<br><br>"

    body += "<br>VM Tags:"
    body += "<br>#{vm.tags.inspect}"
    body += "<br><br>"

    body += "<br>Regards,"
    body += "<br>#{signature}"
    options[:body] = body

    # Return options Hash with subject, body, alert
    return options
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end


  ###################################
  #
  # Method: emailStorageAlert
  #
  # Build Alert email
  #
  ###################################
  def emailAlert(options )
    # Get to_email_address from model unless specified below
    to = nil
    to  ||= $evm.object['to_email_address']

    # Get from_email_address from model unless specified below
    from = nil
    from ||= $evm.object['from_email_address']

    # Get subject from options Hash
    subject = options[:subject]

    # Get body from options Hash
    body = options[:body]

    $evm.log("info", "#{@method} - Sending email To:<#{to}> From:<#{from}> subject:<#{subject}>") if @debug
    $evm.execute(:send_email, to, from, subject, body)
  end


  ###################################
  #
  # Method: call_opcmsg
  #
  # Notes: Run opcmsg to send an event to HP Operations Manager
  #
  ###################################
  def call_opcmsg(options)
    opcmsg_path = "/opt/OV/bin/opcmsg"
    raise "#{@method} - File '#{opcmsg_path}' does not exist" unless File.exist?(opcmsg_path)
    $evm.log("info","#{@method} - Found opcmsg_path:<#{opcmsg_path}>") if @debug

    cmd  = "#{opcmsg_path}"
    cmd += " application=\"#{$evm.object['opcmsg_application']}\""
    cmd += " object=\"#{options[:object]}\""
    cmd += " msg_text=\"#{options[:body]}\""
    cmd += " severity=\"#{$evm.object['opcmsg_severity']}\""
    cmd += " msg_grp=\"#{options[:alert]}\""


    $evm.log("info","#{@method} - Calling:<#{cmd}>") if @debug
    require 'open4'
    pid = nil
    stderr = nil
    results = Open4.popen4(cmd) do |pid, stdin, stdout, stderr|
      stderr.each_line { |msg| $evm.log("error","#{@method} - Method STDERR:<#{msg.strip}>")  }
      stdout.each_line { |msg| $evm.log("info","#{@method} - Method STDOUT:<#{msg.strip}>")  }
    end
    $evm.log("info","#{@method} - Inspecting Results:<#{results.inspect}>") if @debug
  end


  vm = $evm.root['vm']

  unless vm.nil?
    $evm.log("info", "#{@method} - Detected VM:<#{vm.name}>") if @debug

    # If email is set to true in the model
    options = buildDetails(vm)

    # Get email from model
    email = $evm.object['email']

    if boolean(email)
      emailAlert(options)
    end

    call_opcmsg(options)
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Parse_HPOM_Alerts" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Parse_HPOM_Alerts
#
# Notes: This method is used to parse incoming HPOM Alerts
#
###################################
begin
  @method = 'Parse_HPOM_Alerts'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Dump in-storage objects to the log
  def dumpObjects()
    return unless @debug
    # List all of the objects in the root object
    $evm.log("info", "#{@method} ===========================================") if @debug
    $evm.log("info", "#{@method} In-storage ROOT Objects:") if @debug
    $evm.root.attributes.sort.each { |k, v|
      $evm.log("info", "#{@method} -- \t#{k}: #{v}") if @debug

      #$evm.log("info", "#{@method} Inspecting #{v}: #{v.inspect}") if @debug
    }
    $evm.log("info", "#{@method} ===========================================") if @debug

  end

  # List the types of object we will try to detect
  obj_types = %w{ vm host storage ems_cluster ext_management_system }
  obj_type = $evm.root.attributes.detect { |k,v| obj_types.include?(k)}



  # If obj_type is NOT nil else assume miq_server
  unless obj_type.nil?
    rootobj = obj_type.first
  else
    rootobj = 'miq_server'
  end

  $evm.log("info", "#{@method} - Root Object:<#{rootobj}> Detected") if @debug

  $evm.root['object_type'] = rootobj

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="appliance" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="to_email_address" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="from_email_address" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
evmadmin@company.com      </MiqAeField>
      <MiqAeField name="signature" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
EVM Operations Team      </MiqAeField>
      <MiqAeField name="email" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
false      </MiqAeField>
      <MiqAeField name="opcmsg_object" substitute="true" aetype="attribute" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="opcmsg_application" substitute="true" aetype="attribute" datatype="string" priority="7" message="create">
ManageIQ      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext" substitute="true" aetype="attribute" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="opcmsg_severity" substitute="true" aetype="attribute" datatype="string" priority="9" message="create">
normal      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp" substitute="true" aetype="attribute" datatype="string" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="11" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="HPOM_EMS_Cluster_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_object">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_application">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_severity">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
HPOM_EMS_Cluster_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="HPOM_Ext_Management_System_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_object">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_application">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_severity">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
HPOM_Ext_Management_System_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="HPOM_Host_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_object">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_application">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_severity">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
HPOM_Host_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="HPOM_MIQ_Server_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_object">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_application">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_severity">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
HPOM_MIQ_Server_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="HPOM_Storage_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_object">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_application">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_severity">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
HPOM_Storage_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="HPOM_VM_Alert">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_object">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_application">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msgtext">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_severity">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="opcmsg_msggrp">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
HPOM_VM_Alert      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Parse_HPOM_Alerts">
      <MiqAeField name="appliance">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="to_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="from_email_address">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="signature">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="email">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
Parse_HPOM_Alerts      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="IPAM" namespace="Integration" display_name="IP Address Management">
    <MiqAeMethod name="acquire_ip_address" language="ruby" scope="instance" location="inline" display_name="Acquire IP Address"><![CDATA[###################################
#
# EVM Automate Method: acquire_ip_address
#
# Notes: This method is used to acquire an IP Address from an IPAM Server
#
###################################
begin
  @method = 'acquire_ip_address'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")


  miq_provision = $evm.root['miq_provision']
  $evm.root['ae_result'] = 'ok'


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="acquire_mac_address" language="ruby" scope="instance" location="inline" display_name="Acquire MAC Address"><![CDATA[###################################
#
# EVM Automate Method: acquire_mac_address
#
# Notes: This method is used to acquire a MAC Address
#
###################################
begin
  @method = 'acquire_mac_address'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  miq_provision = $evm.root['miq_provision']
  $evm.root['ae_result'] = 'ok'


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ipam_release_ip_from_file" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ipam_release_ip_from_file
#
# Notes: This method is used to release an IP Address from an ASCII file living on an appliance
#
###################################
begin
  @method = 'ipam_release_ip_from_file'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Find the VM
  #
  vm = $evm.root['vm']
  raise "VM not found" if vm.nil?


  vm_hostname = vm.name.to_s.gsub(/\W/, '_')
  $evm.log("info", "VM Hostname : <#{vm_hostname}>")
  raise "VM Hostname not found" if vm_hostname.nil?


  # Specify filename to read
  # File must contain the following construct
  # VLAN Name  IP Addr    Gateway       Router  hostname | free
  ###########  #########  ############, ####### ######
  # VM Network,10.1.1.10,255.255.255.0,10.1.1.1,[evm1234, free]
  fname = "/var/www/miq/iplist.csv"
  raise "File '#{fname}' does not exist" unless File.exist?(fname)


  # Regular Expression to match the following construct:
  # VLAN Name ,IP Addr  Subnet Mask  ,Gateway , [used,free]
  # VM Network,10.1.1.1,255.255.255.0,10.1.1.1,used
  regex_line = /^(vlan.*|vm\snet.*|VM2.*),(\d*).(\d*).(\d*).(\d*),(\d*).(\d*).(\d*).(\d*),(\d*).(\d*).(\d*).(\d*),(\w*)/i
  $evm.log("info", "regex_line: <#{regex_line}>") if @debug

  File.open(fname) do |file|
    file.each do |line|
      # convert everything to lowercase and strip all leading/trailing whitespaces
      line = line.strip

      # if the regular expression successfully matches else skip the line
      if regex_line =~ line
        vlan    = $1
        octet1  = $2
        octet2  = $3
        octet3  = $4
        octet4  = $5
        mask1   = $6
        mask2   = $7
        mask3   = $8
        mask4   = $9
        gate1   = $10
        gate2   = $11
        gate3   = $12
        gate4   = $13
        tmp_name  = $14
        ipaddr  = "#{octet1}.#{octet2}.#{octet3}.#{octet4}"
        submask = "#{mask1}.#{mask2}.#{mask3}.#{mask4}"
        gateway = "#{gate1}.#{gate2}.#{gate3}.#{gate4}"

        $evm.log("info", "Processing Line: <#{line}> VLAN: #{vlan} IP: <#{ipaddr}> Mask: <#{submask}> Gateway: <#{gateway}> Name: <#{tmp_name}>") if @debug

        # if the VM hostname matches the line then set status to free
        if tmp_name.eql?(vm_hostname)
          newline = "#{vlan},#{ipaddr},#{submask},#{gateway},free"
          $evm.log("info", "Replacing Line: <#{line},> with : <#{newline}> in file: <#{fname}")

          # Use sed to do an in-place subtitution
          `sed -i 's/#{vlan},#{octet1}\.#{octet2}\.#{octet3}\.#{octet4},#{mask1}\.#{mask2}\.#{mask3}\.#{mask4},#{gate1}\.#{gate2}\.#{gate3}\.#{gate4},#{tmp_name}/#{vlan},#{octet1}\.#{octet2}\.#{octet3}\.#{octet4},#{mask1}\.#{mask2}\.#{mask3}\.#{mask4},#{gate1}\.#{gate2}\.#{gate3}\.#{gate4},free/' #{fname}`
          exit_method(begin_time)
        else
          $evm.log("info", "Cannot replace line: <#{line}> Name: <#{tmp_name}> VM Name: <#{vm_hostname}>") if @debug
        end #if tmp_name
      else
        $evm.log("info", "Skipping Line: <#{line}> does not match criteria") if @debug
      end # if regex_line
    end # file.each do
  end # file open do

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="register_ad" language="ruby" scope="instance" location="inline" display_name="Register ActiveDirectory"><![CDATA[###################################
#
# EVM Automate Method: register_ad
#
# Notes: This method is used to register a VM in Active Directory
#
###################################
begin
  @method = 'register_ad'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  miq_provision = $evm.root['miq_provision']

  $evm.root['ae_result'] = 'ok'

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="register_dhcp" language="ruby" scope="instance" location="inline" display_name="Register DHCP"><![CDATA[###################################
#
# EVM Automate Method: register_dhcp
#
# Notes: This method is used to register a VM in DHCP
#
###################################
begin
  @method = 'register_dhcp'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  miq_provision = $evm.root['miq_provision']

  $evm.root['ae_result'] = 'ok'

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="register_dns" language="ruby" scope="instance" location="inline" display_name="Register DNS"><![CDATA[###################################
#
# EVM Automate Method: register_dns
#
# Notes: This method is used to register a VM in DNS
#
###################################
begin
  @method = 'register_dns'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  miq_provision = $evm.root['miq_provision']

  $evm.root['ae_result'] = 'ok'

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="release_dhcp" language="ruby" scope="instance" location="inline" display_name="Release DHCP"><![CDATA[###################################
#
# EVM Automate Method: release_dhcp
#
# Notes: This method is used to release IP Address from DHCP
#
###################################
begin
  @method = 'release_dhcp'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  miq_provision = $evm.root['miq_provision']

  $evm.root['ae_result'] = 'ok'

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="unregister_dhcp" language="ruby" scope="instance" location="inline" display_name="Unregister DHCP"><![CDATA[###################################
#
# EVM Automate Method: unregister_dhcp
#
# Notes: This method is used to unregister a VM from DHCP
#
###################################
begin
  @method = 'unregister_dhcp'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Get provisioning object
  miq_provision = $evm.root['miq_provision']

  $evm.root['ae_result'] = 'ok'


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="Method" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing" display_name="Called when Specified Instance is Missing">
    </MiqAeInstance>
    <MiqAeInstance name="AcquireIPAddress" display_name="Acquire IP Address">
      <MiqAeField name="Method">
acquire_ip_address      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="AcquireMacAddress" display_name="Acquire MAC Address">
      <MiqAeField name="Method">
acquire_mac_address      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="RegisterAD" display_name="Register ActiveDirectory">
      <MiqAeField name="Method">
register_ad      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="RegisterDHCP" display_name="Register DHCP">
      <MiqAeField name="Method">
register_dhcp      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="RegisterDNS" display_name="Register DNS">
      <MiqAeField name="Method">
register_dns      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ReleaseDHCP" display_name="Release DHCP">
      <MiqAeField name="Method">
release_dhcp      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ReleaseIPAddress" display_name="Release IP Address">
      <MiqAeField name="Method">
release_ip_address      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ReleaseMacAddress" display_name="Release MAC Address">
    </MiqAeInstance>
    <MiqAeInstance name="ipam_release_ip_from_file">
      <MiqAeField name="Method">
ipam_release_ip_from_file      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="MIQ_API" namespace="Integration" display_name="API Methods">
    <MiqAeMethod name="createCategory" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: createCategory
#
# This method is used to create a tag category via web service API
#
# Inputs: category, [single_value=true|false category_description]
#
###################################
begin
  @method = 'createCategory'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Debug logging mode
  @debug = true

  ##################################
  #
  # Method: Create Tag Category
  # Inputs: category-name, [single_value=[true|false], description]
  # Returns: true/false
  #
  ##################################
  def createCategory?(category, single_value=true, description=category)
    # Convert to lower case and replace all non-word characters with underscores
    category_name = category.downcase.gsub(/\W/, '_')
    $evm.log("info", "#{@method} - Converted category name: <#{category_name}>") if @debug

    # if the category does not exist create it
    unless $evm.execute('category_exists?', category_name)
      $evm.log("info", "#{@method} - Category:<#{category_name}> doesn't exist, creating category") if @debug
      $evm.execute('category_create', :name => category_name, :single_value => single_value, :description => description)
    end

    # Double-check Category Creation
    if $evm.execute('category_exists?', category_name)
      $evm.log("info", "#{@method} - Category:<#{category_name}> exists") if @debug
      return true
    else
      return false
    end
  end


  # Get category
  category                = $evm.root['category']
  # Optional category parameters
  single_value            = $evm.root['single_value']
  category_description    = $evm.root['category_description']

  # Exit if either the category or tag is missing from the call
  raise "#{@method} - Category parameter:<#{category}> not specified" if category.nil?

  unless createCategory?(category, single_value, category_description)
    raise "#{@method} - Could not create category:<#{category}>"
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="createSnapshot" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: createSnapshot
#
# Notes: This method creates a snapshot on a given VM via web service API
#
# Inputs: GUID, [snap_name, snap_description]
#
###################################
begin
  @method = 'createSnapshot'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  ####################
  #
  # Method: createSnapshot
  #
  ####################
  def createSnapshot(vm, snap_name, snap_desc=snap_name)
    $evm.log("info","#{@method} - VM:<#{vm.name}> Creating Snapshot:<#{snap_name}> Description:<#{snap_desc}>")
    vm.create_snapshot(snap_name, snap_desc)
  end

  #$evm.root.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug

  # Get VM object from the root object
  vm = $evm.root['vm']

  # If VM is nil then assume web service call and look for GUID from root object
  if vm.nil?
    $evm.log("info","Execution of method:<#{@method}> via API detected") if @debug
    # Get GUID from foot object
    guid = $evm.root['guid']

    # Lookup VM by GUID
    vm = $evm.vmdb('vm').find_by_guid(guid)
    # Bail out if VM is not found
    raise "#{@method} - VM with GUID:<#{guid}> not found" if vm.nil?
    $evm.log("info","#{@method} - Assigning VM:<#{vm.name}> to root object") if @debug
    $evm.root['vm'] = vm
    $evm.log("info","#{@method} - Found VM:<#{vm.name}> via GUID:<#{guid}>") if @debug
  end

  snap_name = $evm.root['snap_name'] || "Snapshot #{Time.now.strftime('%C%y%m%d-%H%M%S')}"
  snap_desc = $evm.root['snap_desc'] || "Snapshot:<#{snap_name}> for #{vm.name}"

  # Call createSnapshot method
  createSnapshot(vm, snap_name, snap_desc)

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK


  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="createTag" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: createTag
#
# This method is used to create a tag via web service API
#
# Inputs: category, tag, [tag_description]
#
###################################
begin
  @method = 'createTag'
  $evm.log("info", "#{@method} - EVM Automate Method Started")


  ##################################
  #
  # Method: categoryExists
  # Inputs: category
  # Returns: true/false
  #
  ##################################
  def categoryExists?(category)
    # Convert to lower case and replace all non-word characters with underscores
    category_name = category.downcase.gsub(/\W/, '_')
    $evm.log("info", "#{@method} - Converted category name:<#{category_name}>") if @debug

    # Double-check Category Creation
    if $evm.execute('category_exists?', category_name)
      $evm.log("info", "#{@method} - Category:<#{category_name}> exists") if @debug
      return true
    else
      return false
    end
  end


  ##################################
  #
  # Method: Create Tag
  # Inputs: category-name, tag-name, [description]
  # Returns: true|false
  #
  ##################################
  def createTag?(category, tag, description=tag)
    # Convert to lower case and replace all non-word characters with underscores
    category_name = category.downcase.gsub(/\W/, '_')
    tag_name = tag.downcase.gsub(/\W/, '_')
    $evm.log("info", "#{@method} - Converted category name: <#{category_name}>") if @debug
    $evm.log("info", "#{@method} - Converted tag name: <#{tag_name}>") if @debug


    # if the category does not exist exit
    return false unless categoryExists?(category)

    # if the tag does not exists create it
    unless $evm.execute('tag_exists?', category_name, tag_name)
      $evm.log("info", "#{@method} - Adding new Tag:<#{tag_name}> in Category:<#{category_name}>") if @debug
      $evm.execute('tag_create', category_name, :name => tag_name, :description => description)
    end

    # Double-check Category Creation
    if $evm.execute('tag_exists?', category_name, tag_name)
      $evm.log("info", "#{@method} - Tag:<#{tag_name}> exists in Category:<#{category_name}>") if @debug
      return true
    else
      return false
    end
  end


  # Get required category and tag parameters
  category                = $evm.root['category']
  tag                     = $evm.root['tag']
  # Optional tag parameter - defaults to tag
  tag_description         = $evm.root['tag_description']

  # Exit if either the category or tag is missing from the call
  raise "#{@method} - Category parameter:<#{category}> not specified" if category.nil?
  raise "#{@method} - Tag parameter:<#{tag}> not specified" if tag.nil?

  if createTag?(category, tag, tag_description)
    $evm.log("info","#{@method} - Tag:<#{tag}> creation successful")
  else
    raise "#{@method} - Tag:<#{tag}>  creation failed"
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="removeSnapshot" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: removeSnapshot
#
# Notes: This method will remove snapshot(s) on a given VM via web service API
#
# Inputs: GUID, [snap_name=current|all|<snapshot-name>]
#
###################################
begin
  @method = 'removeSnapshot'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  # Assume script executing from button
  vm = $evm.root['vm']


  # Get Snapshot Name from root object else use the current snapshot to remove
  snap_name = $evm.root['snap_name'] || 'current'
  $evm.log("info","#{@method} - Snapshot Name:<#{snap_name}>")


  # If VM is nil then look for GUID from root object
  if vm.nil?
    $evm.log("info","#{@method} - Execution of method:<#{@method}> via API detected")
    # Get GUID from root object
    guid = $evm.root['guid']

    # Lookup VM by GUID
    vm = $evm.vmdb('vm').find_by_guid(guid)
    # Bail out if VM is not found
    raise "#{@method} - VM with GUID:<#{guid}> not found" if vm.nil?
    $evm.log("info","#{@method} - Found VM:<#{vm.name}> via GUID:<#{guid}>")
  end
  $evm.log("info","#{@method} - VM GUID:<#{guid}>")

  # Get all snapshots on current VM
  snapshots = vm.snapshots
  if snapshots.nil?
    $evm.log("info","#{@method} - VM:<#{vm.name}> has no snapshots")
    exit_MIQ_OK
  end

  case snap_name
  when 'current'
    # Find the current snapshot and remove it
    snapshot = snapshots.detect {|ss| ss.current?}
    unless snapshot.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Removing snapshot:<#{snapshot.name}>")
      snapshot.remove
    end
  when 'all'
    # Remove all snapshots from the VM
    $evm.log("info","#{@method} - VM:<#{vm.name}> removing all snapshots:<#{snapshots.inspect}>")
    vm.remove_all_snapshots
  else
    # Remove a specific snapshot
    snapshot =  snapshots.detect {|ss| ss.name == snap_name}
    $evm.log("info","#{@method} - VM:<#{vm.name}> removing snapshot:<#{snapshot.name}>")
    snapshot.remove
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK


  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="retireVM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: retireVM
#
# This method is called via web services to have a VM enter retirement
#
# Inputs: VM GUID
#
###################################
begin
  @method = 'retireVM'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug

  # Get VM object from the root object
  vm = $evm.root['vm']

  # If VM is nil then look for GUID from root object
  if vm.nil?
    $evm.log("info","Execution of method:<#{@method}> via API detected") if @debug
    # Get GUID from foot object
    guid = $evm.root['guid']

    # Lookup VM by GUID
    vm = $evm.vmdb('vm').find_by_guid(guid)
    # Bail out if VM is not found
    raise "VM with GUID:<#{guid}> not found" if vm.nil?
    $evm.log("info","Assigning VM:<#{vm.name}> to root object") if @debug
    $evm.root['vm'] = vm
    $evm.log("info","Found VM:<#{vm.name}> via GUID:<#{guid}>") if @debug
  end

  $evm.log("info","Retiring VM:<#{vm.name}> at:<#{Time.now}>") if @debug
  vm.retire_now

  #$evm.log("info","Inspecting VM:<#{vm.name}> object:<#{$evm.root['vm'].inspect}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="revertSnapshot" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: revertSnapshot
#
# Notes: This method reverts to a snapshot on a given VM via web service API
#
# Inputs: GUID, [snap_name=current|<snapshot_name>]
#
###################################
begin
  @method = 'revertSnapshot'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  # Get VM form root object
  vm = $evm.root['vm']

  # Get Snapshot Name from root object
  snap_name = $evm.root['snap_name'] || 'current'
  $evm.log("info","#{@method} - Snapshot Name:<#{snap_name}>")

  # If VM is nil then assume web service call and look for GUID from root object
  if vm.nil?
    $evm.log("info","#{@method} - Execution via API detected")
    # Get GUID from foot object
    guid = $evm.root['guid']

    # Lookup VM by GUID
    vm = $evm.vmdb('vm').find_by_guid(guid)
    # Bail out if VM is not found
    raise "#{@method} - VM with GUID:<#{guid}> not found" if vm.nil?
    $evm.log("info","#{@method} - Found VM:<#{vm.name}> via GUID:<#{guid}>")
  end
  $evm.log("info","#{@method} - VM GUID:<#{guid}>")


    # Get all snapshots on current VM
  snapshots = vm.snapshots
  if snapshots.nil?
    $evm.log("info","#{@method} - VM:<#{vm.name}> has no snapshots")
    exit_MIQ_OK
  end

  case snap_name
  when 'current'
    # Find the current snapshot and remove it
    snapshot = snapshots.detect {|ss| ss.current?}
    unless snapshot.nil?
  $evm.log("info","#{@method} - Reverting Snapshot:<#{snapshot.name}> Description:<#{snapshot.description}> Date:<#{snapshot.updated_on}> for VM:<#{vm.name}>")
      snapshot.revert_to
    end
  else
    # Remove a specific snapshot
    snapshot =  snapshots.detect {|ss| ss.name == snap_name}
  $evm.log("info","#{@method} - Reverting Snapshot:<#{snapshot.name}> Description:<#{snapshot.description}> Date:<#{snapshot.updated_on}> for VM:<#{vm.name}>")
    snapshot.revert_to
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK


  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="createCategory">
      <MiqAeField name="execute">
createCategory      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="createSnapshot">
      <MiqAeField name="execute">
createSnapshot      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="createTag">
      <MiqAeField name="execute">
createTag      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="removeSnapshot">
      <MiqAeField name="execute">
removeSnapshot      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="retireVM">
      <MiqAeField name="execute">
retireVM      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="revertSnapshot">
      <MiqAeField name="execute">
revertSnapshot      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="IPAM_DB" namespace="Integration/MIQ_IPAM" display_name="IPAM Database">
    <MiqAeSchema>
      <MiqAeField name="vlan" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="hostname" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="ipaddr" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="submask" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="gateway" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="inuse" substitute="true" aetype="attribute" datatype="string" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="date_released" substitute="true" aetype="attribute" datatype="string" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="date_acquired" substitute="true" aetype="attribute" datatype="string" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="9" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="sample-10.0.0.10">
      <MiqAeField name="vlan">
External      </MiqAeField>
      <MiqAeField name="hostname">
evm0000      </MiqAeField>
      <MiqAeField name="ipaddr">
10.0.0.10      </MiqAeField>
      <MiqAeField name="submask">
255.0.0.0      </MiqAeField>
      <MiqAeField name="gateway">
10.0.0.1      </MiqAeField>
      <MiqAeField name="inuse">
true      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="IPAM_Methods" namespace="Integration/MIQ_IPAM">
    <MiqAeMethod name="IPAM_Acquire_from_MIQ" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: IPAM_Acquire_from_MIQ
#
# Notes: EVM Automate method to acquire IP Address information from EVM Automate Model
#
###################################
begin
  @method = 'IPAM_Acquire_from_MIQ'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  ############################
  #
  # Method: instance_find
  # Notes: Returns hash
  #
  ############################
  def instance_find(path)
    result =   $evm.instance_find(path)
    # Returns Hash
    #$evm.log('info',"Instance:<#{path}> properties:<#{result.inspect}>") if @debug
    return result
  end


  ############################
  #
  # Method: instance_exists
  # Notes: Returns string: true/false
  #
  ############################
  def instance_exists(path)
    result = $evm.instance_exists(path)
    if result
      $evm.log('info',"Instance:<#{path}> exists. Result:<#{result.inspect}>") if @debug
    else
      $evm.log('info',"Instance:<#{path}> does not exist. Result:<#{result.inspect}>") if @debug
    end
    return result
  end


  ############################
  #
  # Method: instance_update
  # Notes: Returns string: true/false
  #
  ############################
  def instance_update(path, hash)
    result = $evm.instance_update(path, hash)
    if result
      $evm.log('info',"Instance: <#{path}> updated. Result:<#{result.inspect}>") if @debug
    else
      $evm.log('info',"Instance: <#{path}> not updated. Result:<#{result.inspect}>") if @debug
    end
    return result
  end


  ############################
  #
  # Method: validate_ipaddr
  # Notes: This method uses a regular expression to validate the ipaddr and gateway
  # Returns: Returns string: true/false
  #
  ############################
  def validate_ipaddr(ip)
    ip_regex = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/
    if ip_regex =~ ip
      $evm.log("info","IP Address:<#{ip}> passed validation") if @debug
      return true
    else
      $evm.log("error","IP Address:<#{ip}> failed validation") if @debug
      return false
    end
  end


  ############################
  #
  # Method: validate_gateway
  # Notes: This method uses a regular expression to validate the gateway
  # Returns: Returns string: true/false
  #
  ############################
  def validate_gateway(ip)
    ip_regex = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/
    if ip_regex =~ ip
      $evm.log("info","Default Gateway:<#{ip}> passed validation") if @debug
      return true
    else
      $evm.log("error","Default Gateway:<#{ip}> failed validation") if @debug
      return false
    end
  end

  ############################
  #
  # Method: validate_submask
  # Notes: This method uses a regular expression to validate the submask
  # Returns: Returns string: true/false
  #
  ############################
  def validate_submask(submask)
    mask_regex = /^(0|128|192|224|240|248|252|254|255).(0|128|192|224|240|248|252|254|255).(0|128|192|224|240|248|252|254|255).(0|128|192|224|240|248|252|254|255)$/
    if mask_regex =~ submask
      $evm.log("info","Subnet Mask:<#{submask}> passed validation") if @debug
      return true
    else
      $evm.log("error","Subnet Mask:<#{submask}> failed validation") if @debug
      return false
    end
  end

  ############################
  #
  # Method: set_displayname
  # Notes: This method set an instance DisplayName
  # Returns: Returns: true/false
  #
  ############################
  def set_displayname(path,display_name)
    result = $evm.instance_set_display_name(path, display_name)
    return result
  end


  ###################################
  #
  # Method: boolean
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end

  # Set value to true to use hostname in IPAMDB, else set to false
  get_hostname = nil
  get_hostname ||= $evm.object['get_hostname'] || false

  # Set value to true to use vlan in IPAMDB, else set to false
  get_vlan = nil
  get_vlan ||= $evm.object['get_vlan'] || false

  # Set value to true to use IP information in IPAM DB, else set to false
  get_ipaddr = nil
  get_ipaddr ||= $evm.object['get_ipaddr'] || true


  # Get Provisioning Object
  prov = $evm.root["miq_provision"]

  # Get template from Provisioning Object
  template = prov.vm_template
  #$evm.log("info","Inspecting Template Cluster: <#{template.ems_cluster.inspect}>") if @debug

  # Set path to IPAM DB in automate or retrieve from model
  path_to_db = nil
  path_to_db ||= $evm.object['path_to_db']
  path_to_db = path_to_db.chomp('/') unless path_to_db.nil?

  search_path = "#{path_to_db}/*"

  # Call instance_find to pull back a hash of instances
  instance_hash = instance_find("#{search_path}")
  raise "No instances found in <#{search_path.inspect}>" if instance_hash.empty?


  # Remove hash elements where inuse = true
  instance_hash.delete_if {|k,v| v['inuse'] == 'true' || v['inuse'] == 'TRUE' }
  raise "No IP Addresses are free" if instance_hash.empty?
  #$evm.log("info","Inspecting instance_hash:<#{instance_hash.inspect}>") if @debug

  # This section is commented out until i figure out the sorting of IP Addresses
  # Sort the hashes by hash value ipaddr
  #instance_array = instance_hash.sort_by {|key,val| val['ipaddr'].split('.').map{ |digits| digits.to_i }}


  # Look for IP Address candidate that validates ipaddr, gateway and submask
  ip_candidate = instance_hash.find {|k,v| validate_ipaddr(v['ipaddr']) && validate_gateway(v['gateway']) && validate_submask(v['submask'])}
  raise "No available IP Addresses found:<#{ip_candidate.inspect}>" if ip_candidate.nil?

  # Update provisioning object with ip_candidate information
  class_instance = ip_candidate.first
  location = "#{path_to_db}/#{class_instance}"

  new_hash = ip_candidate.last
  $evm.log("info","Found instance:<#{location}> with Values:<#{new_hash.inspect}>") if @debug

  # Set inuse to true
  new_hash['inuse'] = 'true'

  
  # Override Customization Specification
  prov.set_option(:sysprep_spec_override, [true, 1])

  # Use VLAN information from acquired VLAN
  if boolean(get_vlan)
    prov.set_vlan(new_hash['vlan'])
    $evm.log("info","Provision object updated: [:vlan=>#{prov.options[:vlan].last}]")
  end

  # Use vm_name information from acquired hostname
  if boolean(get_hostname)
    prov.set_option(:vm_target_name, new_hash['hostname'])
    prov.set_option(:linux_host_name, new_hash['hostname'])
    prov.set_option(:vm_target_hostname, new_hash['hostname'])
    prov.set_option(:host_name, new_hash['hostname'])
    $evm.log("info","Provision object updated: [:vm_target_name=>#{prov.options[:vm_target_name]}]")
  end

  # Use networking information from acquired information
  if boolean(get_ipaddr)
    prov.set_option(:addr_mode, ["static", "Static"])

    prov.set_option(:ip_addr, new_hash['ipaddr'])
    prov.set_option(:subnet_mask, new_hash['submask'])
    prov.set_option(:gateway, new_hash['gateway'])

    #prov.set_nic_settings(0, {:ip_addr=>new_hash['ipaddr'], :subnet_mask=>new_hash['submask'], :gateway=>new_hash['gateway'], :addr_mode=>["static", "Static"]})
    $evm.log("info", "Provision Object Updated: [:ip_addr=>#{prov.options[:ip_addr].inspect},:subnet_mask=>#{prov.options[:subnet_mask].inspect},:gateway=>#{prov.options[:gateway].inspect},:addr_mode=>#{prov.options[:addr_mode].inspect} ]") if @debug
  end

  # Build instance display name
  if boolean(get_hostname)
    displayname = "#{new_hash['ipaddr']}-#{new_hash['hostname']}"
  else
    displayname = "#{new_hash['ipaddr']}-#{prov.get_option(:vm_target_name).to_s.strip}"
    # Update instance hostname
    new_hash['hostname'] = prov.get_option(:vm_target_name).to_s.strip
  end

  # Set date time acquired
  new_hash['date_released'] = nil
  new_hash['date_acquired'] = Time.now.strftime('%a, %b %d, %Y at %H:%M:%S %p')


  # Update instance and displayname
  if instance_update(location, new_hash)
    # Set Displayname of instance to reflect acquired IP Address
    set_displayname(location,displayname)
  else
    raise "Failed to update instance:<#{location}>"
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="IPAM_Import" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: IPAM_Import
#
# Notes: EVM Automate method to import IPAM .csv file into EVM Automate
#
###################################
begin
  @method = 'IPAM_Import'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  ############################
  #
  # Method: instance_create
  # Notes: Returns string: true/false
  #
  ############################
  def instance_create(path, hash)
    result = $evm.instance_create(path, hash)
    if result
      $evm.log('info',"Instance: <#{path}> created. Result:<#{result.inspect}>") if @debug
    else
      $evm.log('info',"Instance: <#{path}> not created. Result:<#{result.inspect}>") if @debug
    end
    return result
  end


  ############################
  #
  # Method: instance_exists
  # Notes: Returns string: true/false
  #
  ############################
  def instance_exists(path)
    result = $evm.instance_exists?(path)
    if result
      $evm.log('info',"Instance:<#{path}> exists. Result:<#{result.inspect}>") if @debug
    else
      $evm.log('info',"Instance:<#{path}> does not exist. Result:<#{result.inspect}>") if @debug
    end
    return result
  end


  def import_file(miqpath,fname)
    ####################################################
    # IP Adress Management
    #
    # Specify filename to read
    # File must contain the following construct
    # VLAN       Hostname    IP Address    Subnet Mask Gateway     Inuse
    ############ ########### ############# ########### ########### #########
    # VM Network,myhostname1,10.233.71.169,255.255.255.0,10.233.71.1,true
    # VM Network,myhostname2,10.233.71.170,255.255.255.0,10.233.71.1,false
    #

    raise "File '#{fname}' does not exist" unless File.exist?(fname)

    # Regular Expression to match the following example
    # myhostname1, 10.233.71.0_24, 10.233.71.169,255.255.255.0,10.233.71.1,[used|free]
    regex_line = /^(\w.*),(\w*),(\d*.\d*.\d*.\d*),(\d*.\d*.\d*.\d*),(\d*.\d*.\d*.\d*),(\w*)/i

    # Open file for reading and iterate through the file looking for a match
    file = File.open(fname)
    file.each_line do |line|
      # convert everything to lowercase and strip all leading/trailing whitespaces
      line = line.strip
      $evm.log("info", "Reading line: <#{line}>") if @debug

      # if the regular expression successfully matches else skip the line
      if regex_line =~ line
        hash = {}
        hash['vlan']     = $1
        hash['hostname'] = $2
        hash['ipaddr']   = $3
        hash['submask']  = $4
        hash['gateway']  = $5
        hash['inuse']    = $6

        location = "#{miqpath}/#{hash['ipaddr']}"
        $evm.log("info", "Instance:<#{location}> Hash:<#{hash.inspect}>") if @debug

        # If instance does not already exist
        unless instance_exists(location)
          # Create instance with hash parameters
          instance_create(location, hash)
        else
          $evm.log("info","Instance:<#{location}> already exists") if @debug
        end

      else
        $evm.log("info", "Line: <#{line}> does not match regular expression") if @debug
      end # if regex
    end # file.each do
    file.close
  end


  # Set path to IPAM DB in automate or retrieve from model
  path_to_db = nil
  path_to_db ||= $evm.object['path_to_db']

  # Set full path to import file or retrieve from model
  import_file = nil
  import_file ||= $evm.object['import_file'] || "/var/www/miq/ipamdb.csv"

  # Call import method
  import_file(path_to_db,import_file)

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="IPAM_Release_from_MIQ" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: IPAM_Release_from_MIQ
#
# Notes: EVM Automate method to release IP Address information from EVM Automate Model
#
###################################
begin
  @method = 'IPAM_Release_from_MIQ'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  ############################
  #
  # Method: instance_get
  # Notes: Returns hash
  #
  ############################
  def instance_get(path)
    result = $evm.instance_get(path)
    # Returns Hash
    $evm.log('info',"Instance:<#{path}> properties:<#{result.inspect}>") if @debug
    return result
  end

  ############################
  #
  # Method: instance_find
  # Notes: Returns hash
  #
  ############################
  def instance_find(path)
    result =   $evm.instance_find(path)
    # Returns Hash
    #$evm.log('info',"Instance:<#{path}> properties:<#{result.inspect}>") if @debug
    return result
  end

  ############################
  #
  # Method: instance_update
  # Notes: Returns string: true/false
  #
  ############################
  def instance_update(path, hash)
    result = $evm.instance_update(path, hash)
    if result
      $evm.log('info',"Instance: <#{path}> updated. Result:<#{result.inspect}>") if @debug
    else
      $evm.log('info',"Instance: <#{path}> not updated. Result:<#{result.inspect}>") if @debug
    end
    return result
  end


  ############################
  #
  # Method: instance_exists
  # Notes: Returns string: true/false
  #
  ############################
  def instance_exists(path)
    result = $evm.instance_exists?(path)
    if result
      $evm.log('info',"Instance:<#{path}> exists. Result:<#{result.inspect}>") if @debug
    else
      $evm.log('info',"Instance:<#{path}> does not exist. Result:<#{result.inspect}>") if @debug
    end
    return result
  end


  ############################
  #
  # Method: set_displayname
  # Notes: This method set an instance DisplayName
  # Returns: Returns: true/false
  #
  ############################
  def set_displayname(path,display_name)
    result = $evm.instance_set_display_name(path, display_name)
    return result
  end


  ############################
  #
  # Method: validate_hostname
  # Notes: This method uses a regular expression to find an instance that contains the hostname
  # Returns: Returns string: true/false
  #
  ############################
  def validate_hostname(hostname)
    hostname_regex = /(hostname)$/
    if hostname_regex =~ hostname
      $evm.log("info","Hostname:<#{hostname}> found") if @debug
      return true
    else
      $evm.log("error","Hostname:<#{hostname}> not found") if @debug
      return false
    end
  end

  # Get current VM object
  vm = $evm.root['vm']
  raise "VM not found" if vm.nil?

  # Set path to IPAM DB in automate or retrieve from model
  path_to_db = nil
  path_to_db ||= $evm.object['path_to_db']
  path_to_db = path_to_db.chomp('/') unless path_to_db.nil?

  search_path = "#{path_to_db}/*"

  # Find an instance that matches the VM's IP Address
  instance_hash = instance_find(search_path)
  raise "No instance found in <#{search_path}>" if instance_hash.nil?
  #$evm.log("info","Found instances in:<#{search_path}> with Values:<#{instance_hash.inspect}>") if @debug

  # Look for IP Address candidate that validates hostname and stuff into an array
  ip_candidate = instance_hash.find {|k,v| v['hostname'] == vm.name.strip}
  raise "Could not find intance for VM:<#{vm.name}>" if ip_candidate.nil?

  # Assign first element in array to the instance name
  class_instance = ip_candidate.first

  # Assign last element to new_hash
  new_hash = ip_candidate.last

  location = "#{path_to_db}/#{class_instance}"
  $evm.log("info","Found instance:<#{location}> with Values:<#{new_hash.inspect}>") if @debug

  # Set the inuse attribute to false
  new_hash['inuse'] = 'false'

  new_hash['date_released'] = Time.now.strftime('%a, %b %d, %Y at %H:%M:%S %p')
  new_hash['date_acquired'] = nil

  # Update instance and display name
  if instance_update(location, new_hash)
    set_displayname(location,nil)
  else
    raise "Failed to update instance:<#{location}>"
  end


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ipamdb_csv" language="ruby" scope="instance" location="inline" display_name="Sample"><![CDATA[# File: ipamdb.csv
# Usage: Make necessary changes to this file and place in the /var/www/miq directory
#
VLAN,Hostname,IP Address,Submask,Gateway,inuse
VM Network,miq0000,192.168.253.200,255.255.254.0,192.168.252.1,false
VM Network,miq0001,192.168.253.201,255.255.254.0,192.168.252.1,false
VM Network,miq0002,192.168.253.202,255.255.254.0,192.168.252.1,false
VM Network,miq0003,192.168.253.203,255.255.254.0,192.168.252.1,false
VM Network,miq0004,192.168.253.204,255.255.254.0,192.168.252.1,false
VM Network,miq0005,192.168.253.205,255.255.254.0,192.168.252.1,false
VM Network,miq0006,192.168.253.206,255.255.254.0,192.168.252.1,false
VM Network,miq0007,192.168.253.207,255.255.254.0,192.168.252.1,false
VM Network,miq0008,192.168.253.208,255.255.254.0,192.168.252.1,false
VM Network,miq0009,192.168.253.209,255.255.254.0,192.168.252.1,false
VM Network,miq0010,192.168.253.210,255.255.254.0,192.168.252.1,false
VM Network,miq0011,192.168.253.211,255.255.254.0,192.168.252.1,false
VM Network,miq0012,192.168.253.212,255.255.254.0,192.168.252.1,false
VM Network,miq0013,192.168.253.213,255.255.254.0,192.168.252.1,false
VM Network,miq0014,192.168.253.214,255.255.254.0,192.168.252.1,false
VM Network,miq0015,192.168.253.215,255.255.254.0,192.168.252.1,false
VM Network,miq0016,192.168.253.216,255.255.254.0,192.168.252.1,false
VM Network,miq0017,192.168.253.217,255.255.254.0,192.168.252.1,false
VM Network,miq0018,192.168.253.218,255.255.254.0,192.168.252.1,false
VM Network,miq0019,192.168.253.219,255.255.254.0,192.168.252.1,false
VM Network,miq0020,192.168.253.220,255.255.254.0,192.168.252.1,false
VM Network,miq0021,192.168.253.221,255.255.254.0,192.168.252.1,false
VM Network,miq0022,192.168.253.222,255.255.254.0,192.168.252.1,false
VM Network,miq0023,192.168.253.223,255.255.254.0,192.168.252.1,false
VM Network,miq0024,192.168.253.224,255.255.254.0,192.168.252.1,false
VM Network,miq0025,192.168.253.225,255.255.254.0,192.168.252.1,false
VM Network,miq0026,192.168.253.226,255.255.254.0,192.168.252.1,false
VM Network,miq0027,192.168.253.227,255.255.254.0,192.168.252.1,false
VM Network,miq0028,192.168.253.228,255.255.254.0,192.168.252.1,false
VM Network,miq0029,192.168.253.229,255.255.254.0,192.168.252.1,false
VM Network,miq0030,192.168.253.230,255.255.254.0,192.168.252.1,false
VM Network,miq0031,192.168.253.231,255.255.254.0,192.168.252.1,false
VM Network,miq0032,192.168.253.232,255.255.254.0,192.168.252.1,false
VM Network,miq0033,192.168.253.233,255.255.254.0,192.168.252.1,false
VM Network,miq0034,192.168.253.234,255.255.254.0,192.168.252.1,false
VM Network,miq0035,192.168.253.235,255.255.254.0,192.168.252.1,false]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="path_to_db" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
/Integration/MIQ_IPAM/IPAM_DB      </MiqAeField>
      <MiqAeField name="import_file" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="get_vlan" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="get_hostname" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="get_ipaddr" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="6" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="IPAM_Acquire_from_MIQ">
      <MiqAeField name="path_to_db">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="import_file">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_vlan">
true      </MiqAeField>
      <MiqAeField name="get_hostname">
true      </MiqAeField>
      <MiqAeField name="get_ipaddr">
true      </MiqAeField>
      <MiqAeField name="execute">
IPAM_Acquire_from_MIQ      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="IPAM_Import">
      <MiqAeField name="path_to_db">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="import_file">
/var/www/miq/ipamdb.csv      </MiqAeField>
      <MiqAeField name="execute">
IPAM_Import      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="IPAM_Release_from_MIQ">
      <MiqAeField name="path_to_db">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="import_file">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_vlan">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_hostname">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="get_ipaddr">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
IPAM_Release_from_MIQ      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="NetScaler" namespace="Integration" display_name="Citrix NetScaler">
    <MiqAeMethod name="NetScaler_BindServiceGroup" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: NetScaler_BindServiceGroup
#
# Notes: This method uses a SOAP/XML call to Citrix Netscaler to add a member to a service group.
#
###################################
# Method for logging
def log(level, message)
  @method = 'NetScaler_BindServiceGroup'
  @debug = true
  $evm.log(level, "#{@method} - #{message}") if @debug
end

begin
  log(:info, "EVM Automate Method Started")


  #################################
  #
  # Method: callNetscaler
  # Notes: Create a SOAP call to Netscaler
  #
  # Inuts: username, password, wsdl_uri, soap_action, soap_body (in hash format)
  #
  #################################
  def callNetscaler(username, password, wsdl_uri, soap_action, body_hash)
    # Require Savon Ruby Gem
    require "rubygems"
    require "savon"
    require 'httpi'

    # Turn off HTTPI logging
    HTTPI.log_level = :debug # changing the log level
    HTTPI.log       = false
    HTTPI.adapter   = :net_http # [:httpclient, :curb, :net_http]

    # Turn off Savon logging
    Savon.configure do |config|
      config.log        = false
      config.log_level  = :debug      # changing the log level
    end


    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl,http|
      wsdl.document = wsdl_uri
      http.auth.basic username, password
    end

    # log(:info,"Namespace: #{client.wsdl.namespace.inspect}")
    # log(:info,"Endpoint: #{client.wsdl.endpoint.inspect}")
    # log(:info,"Actions: #{client.wsdl.soap_actions.inspect}")

    login_response = client.request :login do |soap|
      soap.body = {
        'username' => username,
        'password' => password,
      }
    end

    # Set the HTTP Cookie in the headers for all future calls
    raise "login to Netscaler failed" if login_response.nil?
    client.http.headers["Cookie"] = login_response.http.headers["Set-Cookie"]

    # Call Netscaler with desired soap_action and body_hash
    log(:info, "Calling Netscaler with SOAP action:<#{soap_action}> with parameters:<#{body_hash.inspect}>")
    response = client.request soap_action do
      soap.body = body_hash
    end
    return response.to_hash
  end

  # Get provisioning object from root
  prov = $evm.root['miq_provision']

  # If the provisioning object is not nil
  unless prov.nil?
    log(:info, "Provision:<#{prov.id}> Request:<#{prov.miq_provision_request.id}> Type:<#{prov.type}>")

    # Ensure that the vm, vm ipaddress is not nil and the vm ipaddress is not equal to the template ip address
    if prov.vm.nil? || prov.vm.ipaddresses.first.nil? || prov.vm.ipaddresses.first == prov.vm_template.ipaddresses.first
      $evm.root['ae_result'] = 'retry'
      $evm.root['ae_retry_interval'] = '1.minute'
      log(:info,"Waiting for VM to be available. Retrying in 60 seconds")
      exit MIQ_OK
    end
    ipaddr = prov.vm.ipaddresses.first
    log(:info,"Found VM:<#{prov.vm.name}> IP:<#{ipaddr}> found")

  else
    vm = $evm.root['vm']

    unless vm.nil?
      ipaddr = vm.ipaddresses.first
    end
    log(:info,"Found VM:<#{vm.name}> IP:<#{ipaddr}> found")

  end

  # Get options from model
  username = nil
  username ||= $evm.object['username']

  password = nil
  password ||= $evm.object.decrypt('password')

  wsdl_uri = nil
  wsdl_uri ||= $evm.object['wsdl_uri']

  port = nil
  port ||= $evm.object['port']

  servicegroupname = nil
  servicegroupname ||= $evm.object['servicegroupname']

  bindservicegroup_response = callNetscaler(username, password, wsdl_uri, :bindservicegroup, { 'servicegroupname' => servicegroupname, 'ip' => ipaddr, 'port' => port } )

  unless bindservicegroup_response.nil?
    rc = bindservicegroup_response[:bindservicegroup_response][:return][:rc]
    message = bindservicegroup_response[:bindservicegroup_response][:return][:message]

    if rc == "0"
      log(:info, "Netscaler SOAP action successfully completed with return code:<#{rc}> message:<#{message}>")
    else
      log(:info, "Netscaler SOAP action failed with return code:<#{rc}> message:<#{message}>")
    end
  end

  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:info, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="NetScaler_UnBindServiceGroup" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: NetScaler_UnBindServiceGroup
#
# Notes: This method uses a SOAP/XML call to Citrix Netscaler to remove a member from a service group
#
###################################
# Method for logging
def log(level, message)
  @method = 'NetScaler_UnBindServiceGroup'
  @debug = true
  $evm.log(level, "#{@method} - #{message}") if @debug
end

begin
  log(:info, "EVM Automate Method Started")


  #################################
  #
  # Method: callNetscaler
  # Notes: Create a SOAP call to Netscaler
  #
  # Inuts: soap_action, soap_body (in hash format)
  #
  #################################
  def callNetscaler(soap_action, body_hash)
    # Require Savon Ruby Gem
    require "rubygems"
    require "savon"
    require 'httpi'

    # Turn off HTTPI logging
    HTTPI.log_level = :debug # changing the log level
    HTTPI.log       = false
    HTTPI.adapter   = :net_http # [:httpclient, :curb, :net_http]

    # Setup Savon Configuration to turn off logging
    Savon.configure do |config|
      config.log        = false
      config.log_level  = :debug      # changing the log level
    end

    #log(:info,"Calling #{wsdl_uri} with user:<#{username}> and pass:<#{password}>")
    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl,http|
      wsdl.document = wsdl_uri
      http.auth.basic username, password
    end

    # log(:info,"Namespace: #{client.wsdl.namespace.inspect}")
    # log(:info,"Endpoint: #{client.wsdl.endpoint.inspect}")
    # log(:info,"Actions: #{client.wsdl.soap_actions.inspect}")

    login_response = client.request :login do |soap|
      soap.body = {
        'username' => username,
        'password' => password,
      }
    end

    # Set the HTTP Cookie in the headers for all future calls
    raise "login to Netscaler failed" if login_response.nil?
    client.http.headers["Cookie"] = login_response.http.headers["Set-Cookie"]

    # Call Netscaler with desired soap_action and body_hash
    log(:info, "Calling Netscaler with SOAP action:<#{soap_action}> with parameters:<#{body_hash.inspect}>")
    response = client.request soap_action do
      soap.body = body_hash
    end
    #log(:info,"#{soap_action}_response: #{response.to_hash.inspect}")
    return response.to_hash
  end

  # Get VM from root object
  vm = $evm.root['vm']

  raise "VM object not found" if vm.nil?
  ipaddr = vm.ipaddresses.first
  log(:info,"Found VM:<#{vm.name}> IP:<#{ipaddr}> found")

  # Get options from model
  port = nil
  port ||= $evm.object['port']

  servicegroupname = nil
  servicegroupname ||= $evm.object['servicegroupname']

  username = nil
  username ||= $evm.object['username']

  password = nil
  password ||= $evm.object.decrypt('password')

  wsdl_uri = nil
  wsdl_uri ||= $evm.object['wsdl_uri']

  unbindservicegroup_response = callNetscaler(username, password, wsdl_uri, :unbindservicegroup, { 'servicegroupname' => servicegroupname, 'ip' => ipaddr, 'port' => port } )

  unless unbindservicegroup_response.nil?
    rc = unbindservicegroup_response[:unbindservicegroup_response][:return][:rc]
    message = unbindservicegroup_response[:unbindservicegroup_response][:return][:message]

    if rc == "0"
      log(:info, "Netscaler SOAP action successfully completed with return code:<#{rc}> message:<#{message}>")
    else
      log(:info, "Netscaler SOAP action failed with return code:<#{rc}> message:<#{message}>")
    end
  end


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:info, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="username" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="password" substitute="true" aetype="attribute" datatype="password" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="wsdl_uri" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="servicegroupname" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="port" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="6" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="NetScaler_BindServiceGroup">
      <MiqAeField name="username">
nsroot      </MiqAeField>
      <MiqAeField name="password">
v2:{A3hZQasHXufAejGrE/oLsA==}      </MiqAeField>
      <MiqAeField name="wsdl_uri">
/var/www/miq/netscaler.wsdl      </MiqAeField>
      <MiqAeField name="servicegroupname">
svc-grp      </MiqAeField>
      <MiqAeField name="port">
80      </MiqAeField>
      <MiqAeField name="execute">
NetScaler_BindServiceGroup      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Netscaler_UnBindServiceGroup">
      <MiqAeField name="username">
nsroot      </MiqAeField>
      <MiqAeField name="password">
v2:{A3hZQasHXufAejGrE/oLsA==}      </MiqAeField>
      <MiqAeField name="wsdl_uri">
/var/www/miq/netscaler.wsdl      </MiqAeField>
      <MiqAeField name="servicegroupname">
svc-grp      </MiqAeField>
      <MiqAeField name="port">
80      </MiqAeField>
      <MiqAeField name="execute">
Netscaler_UnBindServiceGroup      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Remedy" namespace="Integration" display_name="BMC Remedy">
    <MiqAeMethod name="Remedy_Change_Query_Service" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Remedy_Change_Query_Service
#
# Notes: Query Remedy Change Management Work Details
#
# Inputs:
#
###################################
begin
  @method = 'Remedy_Change_Query_Service'
  $evm.log("info","#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Method: remedy_ChangeQueryService
  #
  def remedy_ChangeQueryService(wsdl_uri, username, password, change_id)
    # Require Savon Ruby Gem
    require 'savon'
    require 'httpi'

    HTTPI.log_level = :info
    HTTPI.log       = false

    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl|
      wsdl.document = wsdl_uri
    end

    $evm.log("info","#{@method} - Namespace: #{client.wsdl.namespace.inspect}") if @debug
    $evm.log("info","#{@method} - Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    $evm.log("info","#{@method} - Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # Call Remedy
    ars_response = client.request :change_query_service do
      # Build the xml header with credentials
      soap.header  = { 'AuthenticationInfo' => {
                         'userName' => username,
                         'password' => password,
                       :order!    => ['userName', 'password'] }
                       }

      # Build the body of the XML elements using the correct order
      soap.body = {
        # Get value from provisioning object (Mandatory Remedy field)
        'Infrastructure_Change_ID' => change_id
      }
    end
    return ars_response.to_hash
  end


  #
  # Method: build_request
  #
  def build_request(comment_hash)

    # Get the current logged in user
    user = $evm.root['user']
    #$evm.log("info","#{@method} - Inspecting User object:<#{user.inspect}>") if @debug

    if user.nil?
      userid = 'admin'
      user_mail = 'evmadmin@miq.net'
    else
      userid = user.userid
      user_mail = user.email
      # If currently logged in user email is nil assign a default email address
      user_mail ||= 'evmadmin@miq.net'
    end


    # arg1 = version
    args = ['1.1']
    # arg2 = templateFields
    args << "name=#{comment_hash[:template_name]}|request_type=template"
    # arg3 = vmFields
    #args << 'vm_name=automate_test|request_type=template|number_of_vms=1'
    args << "number_of_cpus=#{comment_hash[:number_of_cpus]}|vm_memory=#{comment_hash[:vm_memory]}|number_of_cores=#{comment_hash[:number_of_cores]}"
    # arg4 = requester
    args << "user_name=#{userid}|owner_email=#{user_mail}"
    # arg5 = tags
    args << 'lifecycle=retire_full'
    # arg6 = WS Values
    args << comment_hash.collect{|k,v| "#{k}=#{v}"}.join('|')
    # arg7 = emsCustomAttributes
    args << nil
    # arg8 = miqCustomAttributes
    args << nil

    $evm.log("info","#{@method} - Building provisioning request with the following arguments: <#{args.inspect}>") if @debug
    # exit MIQ_ABORT
    $evm.execute('create_provision_request', *args)
  end

  # Get variables
  #prov   = $evm.root['miq_provision']

  # Set Remedy wsdl loation
  wsdl_uri = nil
  wsdl_uri ||= $evm.object['wsdl_uri']

  # Set Remedy Variables
  username = nil
  username ||= $evm.object['username']

  password = nil
  password ||= $evm.object.decrypt('password')

  change_id = nil
  change_id ||= $evm.root['change_id']

  # Query Remedy Change
  $evm.log("info","#{@method} - Querying Remedy Change Request <#{change_id}>")

  remedy_query_results = remedy_ChangeQueryService(wsdl_uri, username, password, change_id)
  raise "#{@method} - Remedy returned no results" if remedy_query_results.nil?
  $evm.log("info","#{@method} - Inspecting remedy_query_results from Remedy:<#{remedy_query_results.inspect}>") if @debug

  comment_hash = {}

  # Get the notes field from Remedy and stuff it into comment_hash
  notes = remedy_query_results[:change_query_service_response][:notes]
  
  #Inspecting :notes from Remedy:<"OS=CentOS\nDisk=50GB\nRAM=1GB\nCPU=1">
  
  $evm.log("info","#{@method} - Inspecting :notes from Remedy:<#{notes.inspect}>") if @debug

  notes.split("\n").each do |str|
    
    # Strip out all whitespaces and build an array splitting on the '=' sign
    sp    = str.gsub(/\s/,'').split("=").compact
    
    # Assign the first element in the array to key
    key   = sp.first

    # Assign the last element in the array to key
    value = sp.last

    # Strip out the GB from the notes field
    comment_hash[key] = value.gsub(/GB/,'')
  end

  if comment_hash['OperatingSystem'].include?('Windows') 
    comment_hash['OperatingSystem'] = comment_hash['OperatingSystem'].gsub('dows','') 
  end
      
  comment_hash[:template_name] = "#{comment_hash['OperatingSystem']}_#{comment_hash['DiskSpace']}"
  comment_hash[:number_of_cpus] = '1'
  comment_hash[:number_of_cores] = comment_hash['CPU']
  comment_hash[:vm_memory] = comment_hash['Memory']

  # Map incoming vram GB Values to MB values for vm_memory variable
  vram_key = {"1"=>"1024","2"=>"2048","4"=>"4096","8"=>"8192", "16"=>"16384"}
  comment_hash[:vm_memory] = vram_key[comment_hash['Memory']]

  $evm.log("info","#{@method} - Inspecting comment_hash from Remedy:<#{comment_hash.inspect}>") if @debug

  # Initiate VM Provision with comments from Remedy
  build_request(comment_hash)

  # Modify Remedy Change
  #remedy_modify_results = remedy_ChangeModifyService(username, password, change_id)
  #raise "#{@method} - Remedy returned no results" if remedy_modify_results.nil?
  #puts "#{@method} - Inspecting remedy_modify_results from Remedy:<#{remedy_modify_results.inspect}>" if @debug

  # Get all comments from the results
  #remedy_getlistvalues = remedy_results[:change_modify_service_response][:request_id]
  #raise "#{@method} - Unable to get list values from Remedy" if remedy_getlistvalues.nil?
  #$evm.log("info","#{@method} - Inspecting remedy_getlistvalues: #{remedy_getlistvalues.inspect}") if @debug

  #ars_response = call_remedy(comment,subject,submitter,parent_id)
  #$evm.log("info","#{@method} - Inspecting ars_response: <#{ars_response}>")

  #
  # Exit method
  #
  $evm.log("info","#{@method} - EVM Automate Method Ended")


  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("info","#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Remedy_ReassignRFC" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Remedy_ReassignRFC
#
# Notes: Reassign Service Request in Remedy
#
# Inputs: prov
#
###################################
begin
  @method = 'Remedy_ReassignRFC'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  #
  # Method: call_remedy
  #
  def call_remedy(parent_id, group)
    # Require Savon Ruby Gem
    require "savon"

    # Override username from model by entering one below else set it to nil
    username = nil
    username ||= $evm.object['username']

    # Override password from model by entering one below else set it to nil
    password = nil
    password ||= $evm.object.decrypt('password')

    # Override password from model by entering one below else set it to nil
    wsdluri = nil
    wsdluri ||= $evm.object['wsdl_uri']

    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl|
      wsdl.document = wsdluri
    end

    $evm.log("info","#{@method} - Namespace: #{client.wsdl.namespace.inspect}") if @debug
    $evm.log("info","#{@method} - Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    $evm.log("info","#{@method} - Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # Build the body of the xml element
    #body  = {'changeID'=>parent_id, 'group'=>group, :order! => ['changeID', 'group']}

    # Call Remedy
    ars_response = client.request :reassign_sr_rfc do |soap|
      # Build the xml header with credentials
      soap.header  = { 'AuthenticationInfo' => {
          'userName' => username,
          'password' => password,
          :order!    => ['userName', 'password']
        }
      }

      # Build the body of the XML elements using the correct order
      soap.body = {
        'changeID' =>parent_id,
        'group'    =>group,
        :order!    => ['changeID', 'group']
      }
    end
    return ars_response
  end

  # Get provisioning object
  prov = $evm.root["miq_provision"]

  # Get OS Type from the template platform
  product  = prov.vm_template.operating_system['product_name']
  $evm.log("info","#{@method} - Source Product: <#{product}>") if @debug

  if prov.options.has_key?(:ws_values)
    ws_values = prov.options[:ws_values]
    parent_id = ws_values[:parent_id]
    if product.include?("Linux")
      group = 'LNX ADM'
    else
      group = 'REMEDY SUPP'
    end
  end

  # Call remedy with parms
  ars_response = call_remedy(parent_id, group)
  $evm.log("info","#{@method} - Inspecting ars_response: <#{ars_response}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Remedy_SearchCommentByParentId" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Remedy_SearchCommentByParentId
#
# Integration: Remedy Action Request System (ARS)
#
# Notes: Search Remedy Comments by Parent ID
#
# Inputs: $evm.root['parent_id']
#
# Outputs: $evm.root['remedy_comment'], $evm.root['remedy_comment_id']
#
###################################
begin
  @method = 'Remedy_SearchCommentByParentId'
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  #################################
  #
  # Method: call_remedy
  # Notes: Create a SOAP call to Remedy
  # Returns: Array of Remedy Comments
  #
  #################################
  def call_remedy(parent_id)
    # Require Savon Ruby Gem
    require "savon"

    # Setup Savon Configuration
    Savon.configure do |config|
      config.log        = false            # disable logging
      config.log_level  = :info      # changing the log level
    end

    # Override username from model by entering one below else set it to nil
    username = nil
    username ||= $evm.object['username']

    # Override password from model by entering one below else set it to nil
    password = nil
    password ||= $evm.object.decrypt('password')

    # Override password from model by entering one below else set it to nil
    wsdluri = nil
    wsdluri ||= $evm.object['wsdl_uri']

    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl, http|
      wsdl.document = wsdluri
      http.auth.ssl.verify_mode = :none
    end

    $evm.log("info","#{@method} - Namespace: #{client.wsdl.namespace.inspect}") if @debug
    $evm.log("info","#{@method} - Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    $evm.log("info","#{@method} - Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # Call Remedy
    remedy_results = client.request :search_comment_by_parent_id do
      # Build the xml header with credentials
      soap.header  = { 'AuthenticationInfo' => {
          'userName' => username,
          'password' => password,
          :order!    => ['userName', 'password']
        }
      }

      # Build the body of the XML elements using the correct order
      soap.body = {
        'Parent_ID' => parent_id
      }
    end
    # Return Remedy results as a hash
    return remedy_results.to_hash
  end


  # Get inbound payload
  parent_id = $evm.root['parent_id']
  raise "#{@method} - Required parameter 'parent_id' missing: #{parent_id.inspect}" if parent_id.nil?

  # Call Remedy to pull back a list of comments attached to a Parent_ID as a hash
  remedy_results = call_remedy(parent_id)
  raise "Remedy returned no results" if remedy_results.nil?
  $evm.log("info","#{@method} - Inspecting remedy_results from Remedy:<#{remedy_results.inspect}>") if @debug

  # Get all comments from the results
  remedy_getlistvalues = remedy_results[:search_comment_by_parent_id_response][:get_list_values]
  raise "#{@method} - Unable to get list values from Remedy" if remedy_getlistvalues.nil?
  $evm.log("info","#{@method} - Inspecting remedy_getlistvalues: #{remedy_getlistvalues.inspect}") if @debug

  if remedy_getlistvalues.kind_of?(Array)
    # Sort the comment values by comment_id in descending value
    sorted_values = remedy_getlistvalues.sort { |a,b| b[:comment_id].to_i <=> a[:comment_id].to_i }
    $evm.log("info","#{@method} - Inspecting Sorted Values: #{sorted_values.inspect}") if @debug
  else
    # Single Comment found, no sort necessary. Converting to an Array.
    sorted_values = []
    sorted_values << remedy_getlistvalues
  end

  sorted_values.each do |sv|
    comment = sv[:comment].gsub(/\r|\t|\s+|\n?/, "")
    comment_id = sv[:comment_id]

    # Set Regular Express to find matching comments
    regex = /^(###start###).*(###end###)$/i

    # if the regular expression successfully matches
    if regex =~ comment
      $evm.log("info","#{@method} - Processing comment ID: <#{comment_id}> with comment: <#{comment}>")

      # Stuff the remedy comment and comment_id strings into the root object
      $evm.root['remedy_comment'] = comment.to_s
      $evm.root['remedy_comment_id'] = comment_id.to_s
      $evm.log("info","#{@method} - Successfully processed remedy_comment_id:<#{$evm.root['remedy_comment_id']}> with remedy_comment: <#{$evm.root['remedy_comment']}>")
      break
    else
      #$evm.log("info","#{@method} - Skipping comment ID: <#{comment_id}> with comment: <#{comment}>") if @debug
    end
  end

  # Bail out if no comments are found to match regular expression
  raise "#{@method} - No Remedy comments matched regular expression" if $evm.root['remedy_comment'].nil?


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Remedy_SubmitComment" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Remedy_SubmitComment
#
# Notes: Submit Comments to Remedy
#
# Inputs: prov, prov[:submitComments]
#
###################################
begin
  @method = 'Remedy_SubmitComment'
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Method: call_remedy
  #
  def call_remedy(comment, subject, submitter_name, parent_id)
    # Require Savon Ruby Gem
    require 'savon'
    require 'httpi'
    
    HTTPI.log_level = :info
    HTTPI.log       = false

    username = nil
    username ||= $evm.object['username']

    password = nil
    password ||= $evm.object.decrypt('password')

    #$evm.log("info","Username: #{username}  Password: #{password}")
    #credentials   = { "wsdl:userName" => username, "wsdl:password" => password }

    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl|
      wsdl.document = nil
      wsdl.document ||= $evm.object['wsdl_uri']
    end

    $evm.log("info","#{@method} - Namespace: #{client.wsdl.namespace.inspect}") if @debug
    $evm.log("info","#{@method} - Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    $evm.log("info","#{@method} - Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # Call Remedy
    ars_response = client.request :submit_comment do
      # Build the xml header with credentials
      soap.header  = { 'AuthenticationInfo' => {
          'userName' => username,
          'password' => password,
          :order!    => ['userName', 'password']
        }
      }

      # Build the body of the XML elements using the correct order
      soap.body = {
        'Comment'         => comment,
        'Comment_Subject' => subject,
        'Submitter_Name'  => submitter_name,
        'Parent_ID'       => parent_id,
        :order!           => ['Comment', 'Comment_Subject', 'Submitter_Name', 'Parent_ID']
      }
    end
    return ars_response
  end


  # Get variables
  prov   = $evm.root['miq_provision']

  # Set Remedy Variables
  submitComments = prov['submit_comments']
  comment = submitComments[:comment]
  subject = submitComments[:subject]
  submitter = submitComments[:submitter]
  parent_id = submitComments[:parent_id]

  # Call remedy with parms
  ars_response = call_remedy(comment,subject,submitter,parent_id)
  $evm.log("info","#{@method} - Inspecting ars_response: <#{ars_response}>")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="wsdl_uri" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="username" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="password" substitute="true" aetype="attribute" datatype="password" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="4" message="create">
Remedy_SubmitComment      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Remedy_Change_Query_Service">
      <MiqAeField name="wsdl_uri">
http://remedyweb.miq.net:9085/arsys/WSDL/public/remedyqa.miq.net/CHG_ChangeInterface_WS      </MiqAeField>
      <MiqAeField name="username">
remedy_user      </MiqAeField>
      <MiqAeField name="password">
v2:{I2SQ5PdmGPwN7t5goRiyaQ==}      </MiqAeField>
      <MiqAeField name="execute">
Remedy_Change_Query_Service      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Remedy_ReassignRFC">
      <MiqAeField name="wsdl_uri">
http://remedyweb.miq.net:9085/arsys/WSDL/public/remedyqa.miq.net/CHG_Change_Modify_SR_RFC      </MiqAeField>
      <MiqAeField name="username">
remedy_user      </MiqAeField>
      <MiqAeField name="password">
v2:{I2SQ5PdmGPwN7t5goRiyaQ==}      </MiqAeField>
      <MiqAeField name="execute">
Remedy_ReassignRFC      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Remedy_SearchCommentByParentId">
      <MiqAeField name="wsdl_uri">
http://remedyweb.miq.net:9085/arsys/WSDL/public/remedyqa.miq.net/Comments_Change_Info      </MiqAeField>
      <MiqAeField name="username">
remedy_user      </MiqAeField>
      <MiqAeField name="password">
v2:{I2SQ5PdmGPwN7t5goRiyaQ==}      </MiqAeField>
      <MiqAeField name="execute">
Remedy_SearchCommentByParentId      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Remedy_SubmitComment">
      <MiqAeField name="wsdl_uri">
http://remedyweb.miq.net:9085/arsys/WSDL/public/remedyqa.miq.net/Comments_Change_Info      </MiqAeField>
      <MiqAeField name="username">
remedy_user      </MiqAeField>
      <MiqAeField name="password">
v2:{I2SQ5PdmGPwN7t5goRiyaQ==}      </MiqAeField>
      <MiqAeField name="execute">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="SRM" namespace="Integration" display_name="VMware SRM">
    <MiqAeMethod name="querySRM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: querySRM
#
# Notes: Calls VMware SRM to query protected group information for a VM and then dynamically 
#  tags the vm based SRM information
# Inputs: $evm.root['vm']
#
###################################
begin
  @method = 'querySRM'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  #################################
  #
  # Method: callSRM
  # Notes: Create a SOAP call to VMware SRM
  #
  #################################
  def callSRM(soap_action, body_hash)
    # Require Savon Ruby Gem
    require "savon"
    require 'httpi'

    HTTPI.log_level = :debug # changing the log level
    HTTPI.log       = false
    HTTPI.adapter   = :net_http # [:httpclient, :curb, :net_http]

    # Setup Savon Configuration
    Savon.configure do |config|
      config.log        = false
      config.log_level  = :debug      # changing the log level
    end

    # Set username name below else use input from model
    username = nil
    username ||= $evm.object['username']

    # Set username name below else use input from model
    password = nil
    password ||= $evm.object.decrypt('password')

    # Set wsdluri below else use input from model
    srmserver = nil
    srmserver ||= $evm.object['srmserver']

    # Set srm_port below else use input from model
    srm_port = nil
    srm_port ||= $evm.object['srm_port']

    # Set srm_apiport below else use input from model
    srm_apiport = nil
    srm_apiport ||= $evm.object['srm_apiport']

    # Set up Savon client
    client = Savon::Client.new do |wsdl, http, wsse|
      wsdl.document = "https://#{srmserver}:#{srm_port}/srm.wsdl"
      wsdl.endpoint = "https://#{srmserver}:#{srm_apiport}/sdk/srm"
      http.auth.ssl.verify_mode = :none
    end

    #$evm.log("info","#{@method} - Namespace: #{client.wsdl.namespace.inspect}") if @debug
    #$evm.log("info","#{@method} - Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    #$evm.log("info","#{@method} - Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # SRM login
    login_response = client.request :srm_login_locale do
      soap.body = { '_this' => 'SrmServiceInstance', 'username' => username, 'password' => password }
    end
    raise "Failed to login to SRM Server:<#{srmserver}> error:<#{login_response.inspect}>" unless login_response.success?

    # Set the HTTP Cookie in the headers for all future calls
    client.http.headers["Cookie"] = login_response.http.headers["Set-Cookie"]
    $evm.log("info","#{@method} - Login to SRM Server:<#{srmserver}> successful")  if @debug


    # Call SRM with desired soap_action and body_hash
    $evm.log("info","#{@method} - Calling SRM:<#{srmserver}> SOAP action:<#{soap_action}> with parameters:<#{body_hash.inspect}>") if @debug
    srm_response = client.request soap_action do
      soap.body = body_hash
    end

    # SRM logout
    logout_response = client.request :srm_logout_locale do
      soap.body = { '_this' => 'SrmServiceInstance' }
    end
    $evm.log("info","#{@method} - Logout of SRM Server:<#{srmserver}> successful:#{logout_response.to_hash.inspect}")  if @debug
    return srm_response.to_hash
  end


  ######################################
  #
  # Method: tagVM
  #
  ######################################
  def tagVM( vm, category, single_value=true, tag )

    # Convert to lower case and replace all non-word characters with underscores
    category_name = category.downcase.gsub(/\W/, '_')
    tag_name = tag.downcase.gsub(/\W/, '_')
    $evm.log("info", "#{@method} - Converted category name:<#{category_name}> Converted tag name: <#{tag_name}>") if @debug

    # if the category exists else create it
    unless $evm.execute('category_exists?', category_name)
      $evm.log("info", "#{@method} - Category <#{category_name}> doesn't exist, creating category") if @debug
      $evm.execute('category_create', :name => category_name, :single_value => single_value, :description => "#{category}")
    end

    # if the tag exists else create it
    unless $evm.execute('tag_exists?', category_name, tag_name)
      $evm.log("info", "#{@method} - Adding new tag <#{tag_name}> in Category <#{category_name}>") if @debug
      $evm.execute('tag_create', category_name, :name => tag_name, :description => "#{tag}")
    end

    # Tag VM with category/tag information
    unless vm.tagged_with?(category_name,tag_name)
      $evm.log("info", "#{@method} - Tagging VM with new <#{tag_name}> tag in Category <#{category_name}>") if @debug
      vm.tag_assign("#{category_name}/#{tag_name}")
    end
  end


  # Get a hash list of SRM Protection Groups
  list_protection_groups = callSRM(:list_protection_groups, { '_this' => 'SrmProtection' } )
  srm_protection_groups = list_protection_groups[:list_protection_groups_response][:returnval]

  # Setup Array of Protection Groups if only one is found
  srm_protection_groups = srm_protection_groups.to_a unless srm_protection_groups.kind_of?(Array)

  # Loop through each SRM Protection Group
  srm_protection_groups.each do |pg|
    $evm.log("info", "#{@method} - Processing Protection Group:<#{pg.inspect}>")
    list_associated_vms = callSRM(:list_associated_vms, { '_this' => pg } )
    pg_associated_vms = list_associated_vms[:list_associated_vms_response][:returnval]

    # Create Array of Protection Group's VMs if only one is found
    pg_associated_vms = pg_associated_vms.split unless pg_associated_vms.kind_of?(Array)

    pg_associated_vms.each do |pg_vm|
      vm_candidate = $evm.root['ext_management_system'].vms.detect { |v| v.ems_ref == pg_vm }
      next unless vm_candidate
      $evm.log("info","#{@method} - Found VM:<#{vm_candidate.name}> ems_ref:<#{vm_candidate.ems_ref}> Protection Group VM:<#{pg}")  if @debug

      get_vm_group = callSRM(:protection_group_query_vm_protection, { '_this' => pg, 'vms' =>  vm_candidate.ems_ref } )
      query_vm_protection = get_vm_group[:protection_group_query_vm_protection_response][:returnval]
      $evm.log("info","#{@method} - Query VM Protection:<#{query_vm_protection.inspect}>")  if @debug

      # List tag categories to process
      valid_tag_categories = [ :protection_group_name, :peer_state, :status, :state, :recovery_plan_names ]

      # Loop through all valid tag categories to fine a matching key in the query_vm_protection hash
      valid_tag_categories.each do |category|
        value       = query_vm_protection[category]
        next if value.nil?
        $evm.log("info","#{@method} - Processing Category:<#{category.to_s.inspect}> value(s):<#{value.inspect}>")  if @debug

        # If values is an array, create a multi-tag category
        if value.kind_of?(Array)
          value.each { |tagval| tagVM( vm_candidate, "srm_#{category.to_s}", false, tagval.to_s ) }
        else
          tagVM( vm_candidate, "srm_#{category.to_s}", true, value.to_s )
        end
      end # end valid_tag_categories.each do
    end # end pg_associated_vms.each do
  end # srm_protection_groups.each do


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="username" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="password" substitute="true" aetype="attribute" datatype="password" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="srmserver" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="srm_port" substitute="true" aetype="attribute" datatype="string" priority="4" message="create">
8095      </MiqAeField>
      <MiqAeField name="srm_apiport" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
9007      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="6" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="querySRM">
      <MiqAeField name="username">
manageiq\evm_demo      </MiqAeField>
      <MiqAeField name="password">
v2:{SBuI+kc7W5nXa7aDnt0m8w==}      </MiqAeField>
      <MiqAeField name="srmserver">
192.168.252.16      </MiqAeField>
      <MiqAeField name="srm_port">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="srm_apiport">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
querySRM      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VCLI" namespace="Integration" display_name="VMware vCLI">
    <MiqAeMethod name="Reconfigure_CDROM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Reconfigure_CDROM
#
# This method is used mount/unmount CD/DVD ISOs on a VM
#
# perl cloudforms-mountiso.pl --url https://192.168.252.24:443/sdk/webservice --username Administrator --password mypassword --operation mount --vmname DHCP --datastore NFS-ISO --filename e1000.iso
# perl cloudforms-mountiso.pl --url https://192.168.252.24:443/sdk/webservice --username Administrator --password mypassword --operation umount --vmname DHCP
###################################
begin
  @method = 'Reconfigure_CDROM'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of debugging
  @debug = true


  ###################################
  #
  # Method: reconfigure_cdrom
  #
  ###################################
  def reconfigure_cdrom( vm, operation, datastore, filename )
    # Build the Perl command using the VMDB information
    cmd = "perl /usr/lib/vmware-vcli/apps/vm/CloudForms_Reconfigure_CDROM.pl"
    cmd += " --url https://#{vm.ext_management_system.ipaddress}:443/sdk/webservice"
    cmd += " --username \"#{vm.ext_management_system.authentication_userid}\""
    cmd += " --password \"#{vm.ext_management_system.authentication_password}\""
    cmd += " --vmname \"#{vm.name}\""
    cmd += " --operation \"#{operation}\""
    if operation == 'mount'
      cmd += " --datastore \"#{datastore}\""
      cmd += " --filename \"#{filename}\""
    end
    $evm.log("info", "Running: #{cmd}")
    results = system(cmd)
    return results
  end

  ###################################
  #
  # Method: boolean
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)
  end

  # Dump all root attributes to the automation.log
  #$evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Root:<$evm.root> Attributes - #{k}: #{v}")} if @debug


  # Get vm from root object
  vm = $evm.root['vm']
  raise "#{@method} - VM object not found" if vm.nil?

  # Get root attributes passed in from the service dialog
  operation = $evm.root['operation'] || 'umount'
  datastore = $evm.root['datastore'] || nil
  filename  = $evm.root['filename']  || nil

  $evm.log("info", "#{@method} - Detected Operation:<#{operation}> for VM:<#{vm.name}> Datastore:<#{datastore}> Filename:<#{filename}>")

  results = reconfigure_cdrom( vm, operation, datastore, filename )
  if results
    $evm.log("info", "#{@method} - VM Reconfigure of CD/DVD Successful:<#{results.inspect}>")
    if operation == 'mount'
      vm.custom_set(:DVDROM, filename)
    else
      vm.custom_set(:DVDROM, nil)
    end
  else
    raise "#{@method} - VM Reconfigure of CD/DVD Failed:<#{results.inspect}>"
  end


  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Reconfigure_CPU" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Reconfigure_CPU
#
# This method is used modify a VMs vCPU count
#
# Inputs: $evm.root['vm'], vcpu, $evm.object['hotadd_vcpu']
#
###################################
begin
  @method = 'Reconfigure_CPU'

  # Turn of debugging
  @debug = true


  ###################################
  #
  # Method: reconfigure_cpu
  #
  ###################################
    def reconfigure_vcpu(vm, vcpu )
    # Build the Perl command using the VMDB information
    cmd = "perl /usr/lib/vmware-vcli/apps/vm/CloudForms_Reconfigure_CPU.pl"
    cmd += " --url https://#{vm.ext_management_system.ipaddress}:443/sdk/webservice"
    cmd += " --username \"#{vm.ext_management_system.authentication_userid}\""
    cmd += " --password \"#{vm.ext_management_system.authentication_password}\""
    cmd += " --vmname \"#{vm.name}\""
    cmd += " --vcpu \"#{vcpu}\""
    $evm.log("info", "#{@method} - Running: #{cmd}")
    results = system(cmd)
    return results
  end


  ###################################
  #
  # Method: boolean
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)
  end


  # Get vm from root object
  vm = $evm.root['vm']
  raise "#{@method} - VM object not found" if vm.nil?

  # Get root attributes passed in from the service dialog
  vcpu   = $evm.root['vcpu'].to_i

  # Get hotadd_vcpu attribute from model
  hotadd = $evm.object['hotadd_vcpu']

  # Get current vcpu from VM
  vm_vcpu = vm.num_cpu.to_i

  unless vcpu.zero? || vcpu == vm_vcpu

    if vcpu < vm_vcpu

      if vm.power_state == 'off'
        $evm.log("info", "#{@method} - Reconfiguring VM:<#{vm.name}> vCPU from #{vm_vcpu} to #{vcpu} with power state:<#{vm.power_state}>")

        results = reconfigure_vcpu(vm, vcpu)
        if results
          $evm.log("info", "#{@method} - VM Reconfigure of vCPU Successful:<#{results.inspect}>")
        else
          raise "#{@method} - VM Reconfigure of vCPU failed:<#{results.inspect}>"
        end
      else
        $evm.log("info", "#{@method} - Cannot reduce VM:<#{vm.name}> vCPU from #{vm_vcpu} to #{vcpu} with power state:<#{vm.power_state}>")
      end
    else
      # vcpu count is greater than vm_vcpu
      if vm.power_state == 'off' || boolean(hotadd)
        $evm.log("info", "#{@method} - Reconfiguring VM:<#{vm.name}> vCPU from #{vm_vcpu} to #{vcpu} with power state:<#{vm.power_state}> and hotadd:<#{hotadd}>")

        results = reconfigure_vcpu( vm, vcpu )
        if results
          $evm.log("info", "#{@method} - VM Reconfigure of vCPU Successful:<#{results.inspect}>")
        else
          raise "#{@method} - VM Reconfigure of vCPU failed:<#{results.inspect}>"
        end
      else
        $evm.log("info", "#{@method} - Cannot increase VM:<#{vm.name}> vCPU count from #{vm_vcpu} to #{vcpu} with power state:<#{vm.power_state}> and hotadd:<#{hotadd}>")
      end
    end
  else
    $evm.log("info", "#{@method} - Skipping vCPU Reconfigure for VM:<#{vm.name}> Currnet vCPU count:<#{vm_vcpu}> Requested vCPU Count:<#{vcpu}> with power state:<#{vm.power_state}> and hotadd:<#{hotadd}>")
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

#
# Set Ruby rescue behavior
#
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Reconfigure_RAM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Reconfigure_RAM
#
# This method is used modify a VMs vRAM count
#
# Inputs: $evm.root['vm'], vram, $evm.object['hotadd_vram']
#
###################################
begin
  @method = 'Reconfigure_RAM'

  # Turn of debugging
  @debug = true


  ###################################
  #
  # Method: reconfigure_vram
  #
  ###################################
    def reconfigure_vram(vm, vram )
    # Build the Perl command using the VMDB information
    cmd = "perl /usr/lib/vmware-vcli/apps/vm/CloudForms_Reconfigure_RAM.pl"
    cmd += " --url https://#{vm.ext_management_system.ipaddress}:443/sdk/webservice"
    cmd += " --username \"#{vm.ext_management_system.authentication_userid}\""
    cmd += " --password \"#{vm.ext_management_system.authentication_password}\""
    cmd += " --vmname \"#{vm.name}\""
    cmd += " --vram \"#{vram}\""
    $evm.log("info", "#{@method} - Running: #{cmd}")
    results = system(cmd)
    return results
  end


  ###################################
  #
  # Method: boolean
  #
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)
  end


  # Get vm from root object
  vm = $evm.root['vm']
  raise "#{@method} - VM object not found" if vm.nil?

  # Get root attributes passed in from the service dialog
  vram   = $evm.root['vram'].to_i
  hotadd = $evm.object['hotadd_vram']

  # Get current ram from VM
  vm_vram = vm.mem_cpu.to_i

  unless vram.zero? || vram == vm_vram

    if vram < vm_vram

      if vm.power_state == 'off'
        $evm.log("info", "#{@method} - Reconfiguring VM:<#{vm.name}> vRAM from #{vm_vram} to #{vram} with power state:<#{vm.power_state}>")

        results = reconfigure_vram(vm, vram)
        if results
          $evm.log("info", "#{@method} - VM Reconfigure of vram Successful:<#{results.inspect}>")
        else
          raise "#{@method} - VM Reconfigure of vRAM failed:<#{results.inspect}>"
        end
      else
        $evm.log("info", "#{@method} - Cannot reduce VM:<#{vm.name}> vRAM from <#{vm_vram}> to <#{vram}> with power state #{vm.power_state}")
      end
    else
      # vram count is greater than vm_vram
      if vm.power_state == 'off' || boolean(hotadd)
        $evm.log("info", "#{@method} - Reconfiguring VM:<#{vm.name}> vRAM from <#{vm_vram}> to <#{vram}> with power state:<#{vm.power_state}> and hotadd:<#{hotadd}>")

        results = reconfigure_vram( vm, vram )
        if results
          $evm.log("info", "#{@method} - VM Reconfigure of vRAM Successful:<#{results.inspect}>")
        else
          raise "#{@method} - VM Reconfigure of vRAM failed:<#{results.inspect}>"
        end
      else
        $evm.log("info", "#{@method} - Cannot increase VM:<#{vm.name}> vRAM from #{vm_vram} to #{vram} with power state:<#{vm.power_state}> and hotadd:<#{hotadd}>")
      end
    end
  else
    $evm.log("info", "#{@method} - Skipping vRAM Reconfigure for VM:<#{vm.name}> Currnet vRAM:<#{vm_vram}> Requested vRAM:<#{vram}> with power state:<#{vm.power_state}> and hotadd:<#{hotadd}>")
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

#
# Set Ruby rescue behavior
#
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="hotadd_vcpu" substitute="true" aetype="attribute" datatype="boolean" priority="1" message="create">
true      </MiqAeField>
      <MiqAeField name="hotadd_vram" substitute="true" aetype="attribute" datatype="boolean" priority="2" message="create">
true      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="3" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Reconfigure_CDROM">
      <MiqAeField name="execute">
Reconfigure_CDROM      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Reconfigure_CPU">
      <MiqAeField name="execute">
Reconfigure_CPU      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Reconfigure_RAM">
      <MiqAeField name="execute">
Reconfigure_RAM      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VIX" namespace="Integration" display_name="VMware VIX">
    <MiqAeMethod name="RunProgramInGuest" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: RunProgramInGuest
#
# Notes: This method will run a program on a guest VM via VIX SDK/API.
# 
# Requirements: 
#   a) The latest VIX SDK can be downloaded from: http://www.vmware.com/support/developer/vix-api
# and must be installed on the EVM Appliance for this script to function
#   b) Guest VM must have VMware Tools running
#
# Model Inputs: vmrun_path,linux_guest_username,linux_guest_password,linux_guest_program,
#  windows_guest_username,windows_guest_password,windows_guest_program
#
###################################
begin
  @method = 'RunProgramInGuest'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of debugging
  @debug = true

  ####################################
  #
  # Method: runProgramInGuest
  # Notes: call vmrun with parameters
  # Returns: true|false
  #
  ####################################
  def runProgramInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
    cmd  = "#{vmrun_path}"
    cmd += " -h https://#{ems.ipaddress}:443/sdk"
    cmd += " -u \"#{ems.authentication_userid}\""
    cmd += " -p \"#{ems.authentication_password}\""
    cmd += " -gu \"#{guest_username}\""
    cmd += " -gp \"#{guest_password}\""
    cmd += " runProgramInGuest"
    cmd += " \"[#{vm.storage_name}]#{vm.location}\""
    cmd += " \"#{guest_program}\""
    #cmd += " <Arguments go here>"

    $evm.log("info","#{@method} - Calling external cmd:<#{cmd}>") if @debug
    results = system(cmd)
    #$evm.log("info","VMrun command <runProgramInGuest> completed with results:<#{results}>")
    return results
  end

  ####################################
  #
  # Method: fileExistsInGuest
  # Notes: call vmrun with parameters
  # Returns: true|false
  #
  ####################################
  def fileExistsInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
    cmd  = "#{vmrun_path}"
    cmd += " -h https://#{ems.ipaddress}:443/sdk"
    cmd += " -u \"#{ems.authentication_userid}\""
    cmd += " -p \"#{ems.authentication_password}\""
    cmd += " -gu \"#{guest_username}\""
    cmd += " -gp \"#{guest_password}\""
    cmd += " fileExistsInGuest"
    cmd += " \"[#{vm.storage_name}]#{vm.location}\""
    cmd += " \"#{guest_program}\""

    $evm.log("info","#{@method} - Calling external cmd:<#{cmd}>") if @debug
    results = system(cmd)
    #$evm.log("info","VMrun command <fileExistsInGuest> completed with results:<#{results}>")
    return results
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    $evm.log("info","#{@method} - Invalid boolean string:<#{string}> detected. Returning false") if @debug
    return false
  end

  # Get Provisioning object
  vm = $evm.root['vm']
  raise "#{@method} - VM object not found" if vm.nil?
  $evm.log("info","#{@method} - VM Found:<#{vm.name}>")

  # Get OS Type from the VM platform
  product  = vm.operating_system['product_name'].downcase
  raise "#{@method} - VM OS product cannot be found" if vm.nil?
  $evm.log("info","#{@method} - VM Source Product:<#{product}>") if @debug

  ems = vm.ext_management_system
  raise "EMS object not found" if ems.nil?
  $evm.log("info","#{@method} - VM Source EMS:<#{ems.name}>") if @debug

  # Set linux_enabled below else get value from model
  linux_enabled = nil
  linux_enabled ||= $evm.object['linux_enabled']

  # Set window_enabled below else get value from model
  windows_enabled = nil
  windows_enabled ||= $evm.object['windows_enabled']


  # Set vmrun_path below or get from model
  #vmrun_path = '/usr/bin/vmrun'
  vmrun_path = nil
  vmrun_path ||= $evm.object['vmrun_path']
  raise "#{@method} - File '#{vmrun_path}' does not exist" unless File.exist?(vmrun_path)


  # Set guest_user and guest_password and guest_program
  if product.include?("linux") && boolean(linux_enabled)
    guest_username = $evm.object['linux_guest_username']
    guest_password = $evm.object.decrypt('linux_guest_password')
    guest_program  = $evm.object['linux_guest_program']
    $evm.log("info","#{@method} - VIX Processing on Linux detected")
  elsif product.include?("windows") && boolean(windows_enabled)
    guest_username = $evm.object['windows_guest_username']
    guest_password = $evm.object.decrypt('windows_guest_password')
    guest_program  = $evm.object['windows_guest_program']
    $evm.log("info","#{@method} - VIX Processing on Windows detected")
  else
    $evm.log("info","#{@method} - Skipping method")
    exit MIQ_OK
  end
  
  raise "#{@method} - Invalid Guest OS Username:<#{guest_username}>" if guest_username.nil?
  raise "#{@method} - Invalid Guest OS Password:<#{guest_password}>" if guest_password.nil?
  raise "#{@method} - Invalid Guest OS Program:<#{guest_program}>" if guest_program.nil?

  fileExists = fileExistsInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
  # Check to see if guest_program exists
  if fileExists
    $evm.log("info","#{@method} - VMrun command <fileExistsInGuest> completed with results:<#{fileExists}>") if @debug
    # Call runProgramInGuest method
    results = runProgramInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
    if results
      $evm.log("info","#{@method} - VMrun command <runProgramInGuest> completed with results:<#{results}>") if @debug
    else
      $evm.log("info","#{@method} - VMrun command <runProgramInGuest> failed with results:<#{results}>") if @debug
    end
  else
    $evm.log("info","#{@method} - VMrun command <fileExistsInGuest> failed with results:<#{fileExists}>") if @debug
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="RunProgramInGuestViaButton" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: RunProgramInGuestViaButton
#
# Notes: This method will run a program on a guest VM via VIX SDK/API.
# 
# Requirements: 
#   a) The latest VIX SDK can be downloaded from: http://www.vmware.com/support/developer/vix-api
# and must be installed on the EVM Appliance for this script to function
#   b) Guest VM must have VMware Tools running
#   c) Guest VM must already have the script being run
#
# Model Inputs: vm, vmrun_path,linux_guest_username,linux_guest_password,linux_guest_program,
#  windows_guest_username,windows_guest_password,windows_guest_program
#
###################################
# Method for logging
def log(level, message)
  @method = 'RunProgramInGuestViaButton'
  $evm.log(level, "#{@method} - #{message}")
end

begin
  log(:info, "EVM Automate Method Started")


  ####################################
  #
  # Method: runProgramInGuest
  # Notes: call vmrun with parameters
  # Returns: true|false
  #
  ####################################
  def runProgramInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
    cmd  = "#{vmrun_path}"
    cmd += " -h https://#{ems.ipaddress}:443/sdk"
    cmd += " -u \"#{ems.authentication_userid}\""
    cmd += " -p \"#{ems.authentication_password}\""
    cmd += " -gu \"#{guest_username}\""
    cmd += " -gp \"#{guest_password}\""
    cmd += " runProgramInGuest"
    cmd += " \"[#{vm.storage_name}]#{vm.location}\""
    cmd += " \"#{guest_program}\""
    #cmd += " <Arguments go here>"

    log(:info,"Calling external cmd:<#{cmd}>")
    results = system(cmd)
    #log(:info,"VMrun command <runProgramInGuest> completed with results:<#{results}>")
    return results
  end

  ####################################
  #
  # Method: fileExistsInGuest
  # Notes: call vmrun with parameters
  # Returns: true|false
  #
  ####################################
  def fileExistsInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
    cmd  = "#{vmrun_path}"
    cmd += " -h https://#{ems.ipaddress}:443/sdk"
    cmd += " -u \"#{ems.authentication_userid}\""
    cmd += " -p \"#{ems.authentication_password}\""
    cmd += " -gu \"#{guest_username}\""
    cmd += " -gp \"#{guest_password}\""
    cmd += " fileExistsInGuest"
    cmd += " \"[#{vm.storage_name}]#{vm.location}\""
    cmd += " \"#{guest_program}\""

    log(:info,"Calling external cmd:<#{cmd}>")
    results = system(cmd)
    #log(:info,"VMrun command <fileExistsInGuest> completed with results:<#{results}>")
    return results
  end


  ###################################
  #
  # Method: boolean
  # Returns: true/false
  ###################################
  def boolean(string)
    return true if string == true || string =~ (/(true|t|yes|y|1)$/i)
    return false if string == false || string.nil? || string =~ (/(false|f|no|n|0)$/i)

    # Return false if string does not match any of the above
    log(:info,"Invalid boolean string:<#{string}> detected. Returning false")
    return false
  end

  # Get Provisioning object
  vm = $evm.root['vm']
  raise "VM object not found" if vm.nil?
  log(:info,"VM Found:<#{vm.name}>")

  # Get OS Type from the VM platform
  product  = vm.operating_system['product_name'].downcase
  raise "VM OS product cannot be found" if vm.nil?
  log(:info,"VM Source Product:<#{product}>")

  ems = vm.ext_management_system
  raise "EMS object not found" if ems.nil?
  log(:info,"VM Source EMS:<#{ems.name}>")

  # Set linux_enabled below else get value from model
  linux_enabled = nil
  linux_enabled ||= $evm.object['linux_enabled']

  # Set window_enabled below else get value from model
  windows_enabled = nil
  windows_enabled ||= $evm.object['windows_enabled']


  # Set vmrun_path below or get from model
  #vmrun_path = '/usr/bin/vmrun'
  vmrun_path = nil
  vmrun_path ||= $evm.object['vmrun_path']
  raise "File '#{vmrun_path}' does not exist" unless File.exist?(vmrun_path)


  # Set guest_user and guest_password and guest_program
  if product.include?("linux") && boolean(linux_enabled)
    guest_username = $evm.object['linux_guest_username']
    guest_password = $evm.object.decrypt('linux_guest_password')
    log(:info,"VIX Processing on Linux detected")
  elsif product.include?("windows") && boolean(windows_enabled)
    guest_username = $evm.object['windows_guest_username']
    guest_password = $evm.object.decrypt('windows_guest_password')
    log(:info,"VIX Processing on Windows detected")
  else
    log(:info,"Skipping method")
    exit MIQ_OK
  end
  
  guest_program  = $evm.root['guest_program']

  raise "Invalid Guest OS Username:<#{guest_username}>" if guest_username.nil?
  raise "Invalid Guest OS Password:<#{guest_password}>" if guest_password.nil?
  raise "Invalid Guest OS Program:<#{guest_program}>" if guest_program.nil?

  fileExists = fileExistsInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
  # Check to see if guest_program exists
  if fileExists
    log(:info,"VMrun command <fileExistsInGuest> completed with results:<#{fileExists}>")
    # Call runProgramInGuest method
    results = runProgramInGuest(vm, vmrun_path, ems, guest_username, guest_password, guest_program)
    if results
      log(:info,"VMrun command <runProgramInGuest> completed with results:<#{results}>")
      vm.custom_set("#{guest_program}", 'Success')
    else
      log(:info,"VMrun command <runProgramInGuest> failed with results:<#{results}>")
      vm.custom_set("#{guest_program}", 'Failed')      
    end
  else
    log(:info,"VMrun command <fileExistsInGuest> failed with results:<#{fileExists}>")
  end


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="vmrun_path" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
/usr/bin/vmrun      </MiqAeField>
      <MiqAeField name="linux_enabled" substitute="true" aetype="attribute" datatype="string" priority="2" message="create">
false      </MiqAeField>
      <MiqAeField name="linux_guest_username" substitute="true" aetype="attribute" datatype="string" priority="3" message="create">
root      </MiqAeField>
      <MiqAeField name="linux_guest_password" substitute="true" aetype="attribute" datatype="password" priority="4" message="create">
v2:{I2SQ5PdmGPwN7t5goRiyaQ==}      </MiqAeField>
      <MiqAeField name="linux_guest_program" substitute="true" aetype="attribute" datatype="string" priority="5" message="create">
/root/vixtest.sh      </MiqAeField>
      <MiqAeField name="windows_enabled" substitute="true" aetype="attribute" datatype="string" priority="6" message="create">
false      </MiqAeField>
      <MiqAeField name="windows_guest_username" substitute="true" aetype="attribute" datatype="string" priority="7" message="create">
Administrator      </MiqAeField>
      <MiqAeField name="windows_guest_password" substitute="true" aetype="attribute" datatype="password" priority="8" message="create">
v2:{I2SQ5PdmGPwN7t5goRiyaQ==}      </MiqAeField>
      <MiqAeField name="windows_guest_program" substitute="true" aetype="attribute" datatype="string" priority="9" message="create">
c:\\temp\\vixtest.cmd      </MiqAeField>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="10" message="create">
RunProgramInGuest      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="RunProgramInGuest">
      <MiqAeField name="vmrun_path">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="linux_enabled">
true      </MiqAeField>
      <MiqAeField name="linux_guest_username">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="linux_guest_password">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="linux_guest_program">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="windows_enabled">
true      </MiqAeField>
      <MiqAeField name="windows_guest_username">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="windows_guest_password">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="windows_guest_program">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="execute">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="VimApi" namespace="Integration" display_name="VMware VimApi">
    <MiqAeMethod name="VMWare_HotResize_Disk" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VMWare_HotResize_Disk
#
# Notes: This method is used to increase the size of the VM's disk
#
# Inputs: $evm.root['vm'], disk_number, size
#
###################################
# Method for logging
def log(level, message)
  @method = 'VMWare_HotResize_Disk'
  $evm.log(level, "#{@method} - #{message}")
end

begin
  log(:info, "EVM Automate Method Started")

  def resizeDisk(vm, disk_number, new_disk_size_in_kb)
    log(:info, "Resize disk functionality currently under review")
  end


  # Get vm object from root
  vm = $evm.root['vm']
  raise "#{@method} - VM object not found" if vm.nil?

  # Get disk_number variable from root if nil convert to zero
  disk_number = $evm.root['disk_number'].to_i

  # Get size variable from root
  size = $evm.root['size'].to_i

  log(:info, "Detected VM:<#{vm.name}> disk_number:<#{disk_number.inspect}> size:<#{size.inspect}>")


  unless size.zero?

    case disk_number

    when 0
      # Convert disk 1 disk size into KB and add the number of GB converted into KB
      new_disk_size_in_kb = (vm.disk_1_size / 1024) + (size * 1024**2)
    when 1
      # Convert disk 2 disk size into KB and add the number of GB converted into KB
      new_disk_size_in_kb = (vm.disk_2_size / 1024) + (size * 1024**2)
    when 2
      # Convert disk 3 disk size into KB and add the number of GB converted into KB
      new_disk_size_in_kb = (vm.disk_3_size / 1024) + (size * 1024**2)
    else
      log(:info, "invalid disk_number detected")
      size = 0
    end

    unless size.zero?
      log(:info, "VM:<#{vm.name}> Increasing Disk #{disk_number} size to #{new_disk_size_in_kb / 1024**2}GB")
      resizeDisk(vm, disk_number, new_disk_size_in_kb)
    end
  end


  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VMware_HotAdd_CPU" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VMware_HotAdd_CPU
#
# This method is used to modify vCPUs to an existing VM running on VMware
#
# Inputs: $evm.root['vm'], cpus
#
###################################
# Method for logging
def log(level, message)
  @method = 'VMware_HotAdd_CPU'
  @debug = true
  $evm.log(level, "#{@method} - #{message}") if @debug
end

begin
  log(:info, 'EVM Automate Method Started')

  # Get vm object from root
  vm = $evm.root['vm']
  raise MissingVMObject, "Missing $evm.root['vm'] object" unless vm.nil?

  # Get the number of cpus from root
  cpus = $evm.root['cpus'].to_i
  log(:info, "Detected cpus:<#{cpus}>")

  # Add disk to a VM
  unless cpus.zero?
    log(:info, "Setting number of vCPUs to #{cpus} on VM:<#{vm.name}>")
    vm.set_number_of_cpus(cpus.to_i, :sync => true)
  end

  #
  # Exit method
  #
  log(:info, 'EVM Automate Method Ended')
  exit MIQ_OK

    #
    # Set Ruby rescue behavior
    #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VMware_HotAdd_Disk" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VMware_HotAdd_Disk
#
# This method is used to add a new disk to an existing VM running on VMware
#
# Inputs: $evm.root['vm'], size
#
###################################
# Method for logging
def log(level, message)
  @method = 'VMware_HotAdd_Disk'
  @debug = true
  $evm.log(level, "#{@method}: #{message}") if @debug
end

begin
  log(:info, "EVM Automate Method Started")

  # Get vm object
  vm = $evm.root['vm']
  raise MissingVMObject, "Missing $evm.root['vm'] object" unless vm

  # Get the size for the new disk from the root object
  size = $evm.root['size'].to_i
  log(:info, "Detected size:<#{size}>")

  # Add disk to a VM
  unless size.zero?
    log(:info, "Creating a new #{size}GB disk on Storage:<#{vm.storage_name}>")
    vm.add_disk("[#{vm.storage_name}]", size * 1024, :sync => true)
  else
    log(:error, "Size:<#{size}> invalid")
  end

  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

    #
    # Set Ruby rescue behavior
    #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VMware_HotAdd_RAM" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: VMware_HotAdd_RAM
#
# This method is used to modify vRAM to an existing VM running on VMware
#
# Inputs: $evm.root['vm'], cpus
#
###################################
# Method for logging
def log(level, message)
  @method = 'VMware_HotAdd_RAM'
  @debug = true
  $evm.log(level, "#{@method}: #{message}") if @debug
end

begin
  log(:info, 'EVM Automate Method Started')

  # Get vm object from root
  vm = $evm.root['vm']
  raise MissingVMObject, "Missing $evm.root['vm'] object" unless vm

  # Get the number of cpus from root
  ram = $evm.root['ram'].to_i
  log(:info, "Detected ram:<#{ram}>")

  unless ram.zero?
    log(:info, "Setting amount of vRAM to #{ram} on VM:<#{vm.name}>")
    vm.set_memory(ram, :sync => true)
  end

  #
  # Exit method
  #
  log(:info, 'EVM Automate Method Ended')
  exit MIQ_OK

    #
    # Set Ruby rescue behavior
    #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="execute" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="VMWare_HotResize_Disk">
      <MiqAeField name="execute">
VMWare_HotResize_Disk      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VMware_HotAdd_CPU">
      <MiqAeField name="execute">
VMware_HotAdd_CPU      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VMware_HotAdd_Disk">
      <MiqAeField name="execute">
VMware_HotAdd_Disk      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VMware_HotAdd_RAM">
      <MiqAeField name="execute">
VMware_HotAdd_RAM      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Methods" namespace="Sample" description="Sample Methods">
    <MiqAeMethod name="CheckMulticast" language="ruby" scope="instance" location="inline"><![CDATA[#
#            EVM Automate Method
#
$evm.log("info", "EVM Check Multicast Starting")


# Change those variables based on desired thresholds and email recipient
max_multicast_vms = "5"
to ||= 'evm_demo@manageiq.com'
from = 'evm_demo@manageiq.com'

#
# Find the VM
vm = $evm.root['vm']
return if vm.nil?

event=$evm.root['ems_event']
$evm.log('info', "Event Dest Host Name: <#{event.dest_host_id}>")


# Only check for powered on VMs
if vm.power_state == "on"

  # Find the Host this VM is running on
  if event.dest_host_id.nil?
    # If it is not a VM relocation set the host to the current host
    host = vm.host
    return if host.nil?
  else
    # If it driven by a VM relocation event set the host to the destination host and the source host to where the VM is coming from
    host = vm.ext_management_system.hosts.detect { |h| h['id'] == event.dest_host_id.to_i }
  end


  # Under this Host, find all VMs tagged with category 'multicast' and tag of 'true' and running
  multicast_vms = host.vms.find_all { |v| v.tagged_with?('multicast', 'true') &&  v.power_state == "on"}

  $evm.log('info', "Host <#{host.name}> has #{multicast_vms.size} Multicast VMs running on this Host already!")

  # Check if over the limit and take appropriate action
  if multicast_vms.size > max_multicast_vms.to_i
    if event.dest_host_id.nil?
      $evm.log('info', "Stopping VM <#{vm.name}> on Host <#{host.name}> because there are #{multicast_vms.size} Multicast VMs running on this Host already!")
      vm.stop
      subject = "VM <#{vm.name}> on Host <#{host.name}> has been stopped because there are #{multicast_vms.size} Multicast VMs running on this Host already!"
    else
      # Get VM's Cluster
      cluster = vm.ems_cluster

      # Stop the VM if NOT in a cluster
      if cluster.nil?
        $evm.log('info', "Stopping VM <#{vm.name}> on Host <#{vm.host.name}> because it is not in a cluster")
        subject = "VM <#{vm.name}> on Host <#{host.name}> has been stopped because there are #{multicast_vms.size} Multicast VMs running on this Host already and this host is not in a cluster!"
        vm.stop
      else
       # Get all the hosts and their count of VMs that are tagged as multicast and powered on
       mhosts_array  = []
       cluster.hosts.each do |target_host|
         multicast_vms = target_host.vms.find_all { |v| v.tagged_with?('multicast', 'true') &&  v.power_state == "on"}.size
         # Do NOT add the VMs host to candidate hosts for vmotion
         next if target_host == host
         # Create a tuple (or tiny array) that we will put onto the mhosts_array
         tuple = [target_host, multicast_vms]
         # Add the tuple to the mhosts_array
         mhosts_array << tuple
       end
       # Make sure that there is at least 1 element in the array
       if mhosts_array.size == 0
         $evm.log('info', "Stopping VM <#{vm.name}> on Host <#{host.name}> because there are no other hosts in the cluster")
         vm.stop
         subject = "VM <#{vm.name}> on Host <#{host.name}> has been stopped because there are #{multicast_vms.size} Multicast VMs running on this Host already and no host to relocate it!"
       else
         # Sort the array by count of VMs that are tagged as multicast and powered on
         mhosts_array.sort! { |a,b| a.last <=> b.last }

         # Get the first tuple of the sorted array
         tuple = mhosts_array.first

         # Break up tuple into target host and count
         target_host  = tuple.first
         count = tuple.last
         $evm.log('info', "Target Host <#{target_host}> has #{count} Multicast VMs running!")
       end

       if count >= max_multicast_vms.to_i
          $evm.log('info', "Stopping VM <#{vm.name}> on Host <#{host.name}> because there is nowhere safe to vmotion it to")
          vm.stop
          subject = "VM <#{vm.name}> on Host <#{host.name}> has been stopped because there are #{multicast_vms.size} Multicast VMs running on this Host already and no host to relocate it!"
       else
          $evm.log('info', "Migrating VM <#{vm.name}> on Host <#{host.name}> to Host <#{target_host.name}>")
          vm.migrate(target_host)
          subject = "VM <#{vm.name}> on Host <#{host.name}> has been migrated Host <#{target_host.name}> because there are #{multicast_vms.size} Multicast VMs running on the Host already."
       end
      end
    end
    # Send email
    body = "VM Information: <br>
    VM: #{vm.name} <br>
    Host: #{host.name} <br>"
    $evm.execute('send_email', to, from, subject, body)
  end
else
$evm.log('info', "This method only apply to power on VMs. #{vm.name} is #{vm.power_state}")
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ConfigureChildDialog" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ConfigureChildDialog
#
# Notes: Sample method to configure/set child dialog values
#
###################################
begin
  @method = 'ConfigureChildDialog'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Method Code Goes here
  $evm.log("info", "#{@method} - ===========================================") if @debug
  $evm.log("info", "#{@method} - Listing ROOT Attributes:") if @debug
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug}
  $evm.log("info", "#{@method} - ===========================================") if @debug

  stp_task = $evm.root["service_template_provision_task"]
  $evm.log("info", "#{@method} - ===========================================") if @debug
  $evm.log("info", "#{@method} - Listing task Attributes:") if @debug
  stp_task.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - \t#{k}: #{v}") if @debug}
  $evm.log("info", "#{@method} - ===========================================") if @debug

  $evm.log("info","#{@method} - No child dialog options have been configured.") if @debug

  dialog_service_type = $evm.root['dialog_service_type']
  $evm.log("info","#{@method} - User selected Dialog option = [#{dialog_service_type}]") if @debug

  stp_miq_request_task = stp_task.miq_request_task
  #$evm.log("info","#{@method} - (parent) miq_request_task:  = [#{stp_miq_request_task}]") if @debug

  stp_miq_request_tasks = stp_task.miq_request_tasks
  #$evm.log("info","#{@method} - (children) miq_request_tasks count:  = [#{stp_miq_request_tasks.count}]") if @debug

  stp_miq_request_tasks.each do |t|
    $evm.log("info"," Setting dialog for: #{t.description}")
    service = t.source
    service_resource = t.service_resource
    #$evm.log("info","#{@method} - Child service resource name: #{service_resource.resource_name}") if @debug
    #$evm.log("info","#{@method} - Child service resource description: #{service_resource.resource_description}") if @debug

    service_tag_array = service.tags(:app_tier)
    service_tag = service_tag_array.first.to_s

    memory_size = nil

    case dialog_service_type
    when "Small"
      case service_tag
      when "app"
        memory_size = 1024
      when "web"
        memory_size = 1024
      when "db"
        memory_size = 4096
      else
        $evm.log("info","#{@method} - Unknown Dialog type") if @debug
      end
    when "Large"
      case service_tag
      when "app"
        memory_size = 4096
      when "web"
        memory_size = 4096
      when "db"
        memory_size = 8192
      else
        $evm.log("info","#{@method} - Unknown Dialog type") if @debug
      end
    else
      $evm.log("info","#{@method} - Unknown Dialog type - setting Dialog options here") if @debug
    end

    t.set_dialog_option('memory',memory_size) unless memory_size.nil?

    $evm.log("info","#{@method} - Set dialog for selection: [#{dialog_service_type}]  Service_Tier: [#{service_tag}] Memory size: [#{memory_size}]") if @debug
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="InspectMe" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: InspectMe
#
# Notes: Dump the objects in storage to the automation.log
#
###################################
begin
  @method = 'InspectMe'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  #########################
  #
  # Method: dumpRoot
  # Description: Dump Root information
  #
  ##########################
  def dumpRoot
    $evm.log("info", "#{@method} - Root:<$evm.root> Begin Attributes")
    $evm.root.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Root:<$evm.root> Attributes - #{k}: #{v}")}
    $evm.log("info", "#{@method} - Root:<$evm.root> End Attributes")
    $evm.log("info", "")
  end


  #########################
  #
  # Method: dumpServer
  # Inputs: $evm.root['miq_server']
  # Description: Dump MIQ Server information
  #
  ##########################
  def dumpServer
    $evm.log("info","#{@method} - Server:<#{$evm.root['miq_server'].name}> Begin Attributes")
    $evm.root['miq_server'].attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Server:<#{$evm.root['miq_server'].name}> Attributes - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - Server:<#{$evm.root['miq_server'].name}> End Attributes")
    $evm.log("info", "")
  end


  #########################
  #
  # Method: dumpUser
  # Inputs: $evm.root['user']
  # Description: Dump User information
  #
  ##########################
  def dumpUser
    user = $evm.root['user']
    unless user.nil?
      $evm.log("info","#{@method} - User:<#{user.name}> Begin Attributes [user.attributes]")
      user.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - User:<#{user.name}> Attributes - #{k}: #{v.inspect}")}
      $evm.log("info","#{@method} - User:<#{user.name}> End Attributes [user.attributes]")
      $evm.log("info", "")

      $evm.log("info","#{@method} - User:<#{user.name}> Begin Associations [user.associations]")
      user.associations.sort.each { |assc| $evm.log("info", "#{@method} - User:<#{user.name}> Associations - #{assc}")}
      $evm.log("info","#{@method} - User:<#{user.name}> End Associations [user.associations]")
      $evm.log("info","")

      unless user.tags.nil?
        $evm.log("info","#{@method} - User:<#{user.name}> Begin Tags [user.tags]")
        user.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - User:<#{user.name}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
        $evm.log("info","#{@method} - User:<#{user.name}> End Tags [user.tags]")
        $evm.log("info","")
      end

      $evm.log("info","#{@method} - User:<#{user.name}> Begin Virtual Columns [user.virtual_column_names]")
      user.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - User:<#{user.name}> Virtual Columns - #{vcn}: #{user.send(vcn).inspect}")}
      $evm.log("info","#{@method} - User:<#{user.name}> End Virtual Columns [user.virtual_column_names]")
      $evm.log("info","")
    end
  end


  #########################
  #
  # Method: dumpGroup
  # Inputs: $evm.root['user'].current_group
  # Description: Dump User's Group information
  #
  ##########################
  def dumpGroup
    user = $evm.root['user']
    unless user.nil?
      miq_group = user.current_group
      unless miq_group.nil?
        $evm.log("info","#{@method} - Group:<#{miq_group.description}> Begin Attributes [miq_group.attributes]")
        miq_group.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Group:<#{miq_group.description}> Attributes - #{k}: #{v.inspect}")} unless $evm.root['user'].current_group.nil?
        $evm.log("info","#{@method} - Group:<#{miq_group.description}> End Attributes [miq_group.attributes]")
        $evm.log("info", "")

        $evm.log("info","#{@method} - Group:<#{miq_group.description}> Begin Associations [miq_group.associations]")
        miq_group.associations.sort.each { |assc| $evm.log("info", "#{@method} - Group:<#{miq_group.description}> Associations - #{assc}")}
        $evm.log("info","#{@method} - Group:<#{miq_group.description}> End Associations [miq_group.associations]")
        $evm.log("info","")

        unless miq_group.tags.nil?
          $evm.log("info","#{@method} - Group:<#{miq_group.description}> Begin Tags [miq_group.tags]")
          miq_group.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - Group:<#{miq_group.description}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
          $evm.log("info","#{@method} - Group:<#{miq_group.description}> End Tags [miq_group.tags]")
          $evm.log("info","")
        end

        $evm.log("info","#{@method} - Group:<#{miq_group.description}> Begin Virtual Columns [miq_group.virtual_column_names]")
        miq_group.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - Group:<#{miq_group.description}> Virtual Columns - #{vcn}: #{miq_group.send(vcn).inspect}")}
        $evm.log("info","#{@method} - Group:<#{miq_group.description}> End Virtual Columns [miq_group.virtual_column_names]")
        $evm.log("info","")
      end
    end
  end

  #########################
  #
  # Method: dumpHost
  # Inputs: $evm.root['host']
  # Description: Dump Host information
  #
  ##########################
  def dumpHost(host)
    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Attributes [host.attributes]")
    host.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Host:<#{host.name}> Attributes - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Attributes [host.attributes]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Associations [host.associations]")
    host.associations.sort.each { |assc| $evm.log("info", "#{@method} - Host:<#{host.name}> Associations - #{assc}")}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Associations [host.associations]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Hardware [host.hardware]")
    host.hardware.attributes.each { |k,v| $evm.log("info", "#{@method} - Host:<#{host.name}> Hardware - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Hardware [host.hardware]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Lans [host.lans]")
    host.lans.each { |lan| lan.attributes.sort.each { |k,v| $evm.log("info", "#{@method} - Host:<#{host.name}> Lan:<#{lan.name}> - #{k}: #{v.inspect}")}}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Lans [host.lans]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Switches [host.switches]")
    host.switches.each { |switch| switch.attributes.sort.each { |k,v| $evm.log("info", "#{@method} - Host:<#{host.name}> Swtich:<#{switch.name}> - #{k}: #{v.inspect}")}}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Switches [host.switches]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Operating System [host.operating_system]")
    host.operating_system.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Host:<#{host.name}> Operating System - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Operating System [host.operating_system]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Guest Applications [host.guest_applications]")
    host.guest_applications.each { |guest_app| guest_app.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Host:<#{host.name}> Guest Application:<#{guest_app.name}> - #{k}: #{v.inspect}")}}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Guest Applications [host.guest_applications]")
    $evm.log("info","")

    unless host.tags.nil?
      $evm.log("info","#{@method} - Host:<#{host.name}> Begin Tags [host.tags]")
      host.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - Host:<#{host.name}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
      $evm.log("info","#{@method} - Host:<#{host.name}> End Tags [host.tags]")
      $evm.log("info","")
    end

    $evm.log("info","#{@method} - Host:<#{host.name}> Begin Virtual Columns [host.virtual_column_names]")
    host.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - Host:<#{host.name}> Virtual Columns - #{vcn}: #{host.send(vcn).inspect}")}
    $evm.log("info","#{@method} - Host:<#{host.name}> End Virtual Columns [host.virtual_column_names]")
    $evm.log("info", "")
  end


  #########################
  #
  # Method: dumpVM
  # Inputs: $evm.root['vm']
  # Description: Dump VM information
  #
  ##########################
  def dumpVM(vm)
    $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Attributes [vm.attributes]")
    vm.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Attributes - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - VM:<#{vm.name}> End Attributes [vm.attributes]")
    $evm.log("info","")

    $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Associations [vm.associations]")
    vm.associations.sort.each { |assc| $evm.log("info", "#{@method} - VM:<#{vm.name}> Associations - #{assc}")}
    $evm.log("info","#{@method} - VM:<#{vm.name}> End Associations [vm.associations]")
    $evm.log("info","")

    $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Hardware Attributes [vm.hardware]")
    vm.hardware.attributes.each { |k,v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Hardware - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - VM:<#{vm.name}> End Hardware Attributes [vm.hardware]")
    $evm.log("info","")

    $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Hardware Associations [vm.hardware.associations]")
    vm.hardware.associations.sort.each { |assc| $evm.log("info", "#{@method} - VM:<#{vm.name}> hardware Associations - #{assc}")}
    $evm.log("info","#{@method} - VM:<#{vm.name}> End hardware Associations [vm.hardware.associations]")
    $evm.log("info","")

    $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Neworks [vm.hardware.nics]")
    vm.hardware.nics.each { |nic| nic.attributes.sort.each { |k,v| $evm.log("info", "#{@method} - VM:<#{vm.name}> VLAN:<#{nic.device_name}> - #{k}: #{v.inspect}")}}
    $evm.log("info","#{@method} - VM:<#{vm.name}> End Networks [vm.hardware.nics]")
    $evm.log("info","")

    unless vm.ext_management_system.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin EMS [vm.ext_management_system]")
      vm.ext_management_system.attributes.sort.each { |ems_k, ems_v| $evm.log("info", "#{@method} - VM:<#{vm.name}> EMS:<#{vm.ext_management_system.name}> #{ems_k} - #{ems_v.inspect}")}
      $evm.log("info","#{@method} - VM:<#{vm.name}> End EMS [vm.ext_management_system]")
      $evm.log("info","")
    end

    unless vm.owner.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Owner [vm.owner]")
      vm.owner.attributes.each { |k,v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Owner - #{k}: #{v.inspect}")}
      $evm.log("info","#{@method} - VM:<#{vm.name}> End Owner [vm.owner]")
      $evm.log("info","")
    end

    unless vm.operating_system.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Operating System [vm.operating_system]")
      vm.operating_system.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Operating System - #{k}: #{v.inspect}")}
      $evm.log("info","#{@method} - VM:<#{vm.name}> End Operating System [vm.operating_system]")
      $evm.log("info","")
    end

    unless vm.guest_applications.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Guest Applications [vm.guest_applications]")
      vm.guest_applications.each { |guest_app| guest_app.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Guest Application:<#{guest_app.name}> - #{k}: #{v.inspect}")}} unless vm.guest_applications.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> End Guest Applications [vm.guest_applications]")
      $evm.log("info","")
    end

    unless vm.snapshots.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Snapshots [vm.snapshots]")
      vm.snapshots.each { |ss| ss.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Snapshot:<#{ss.name}> - #{k}: #{v.inspect}")}} unless vm.snapshots.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> End Snapshots [vm.snapshots]")
      $evm.log("info","")
    end

    unless vm.storage.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin VM Storage [vm.storage]")
      vm.storage.attributes.sort.each { |stor_k, stor_v| $evm.log("info", "#{@method} - VM:<#{vm.name}> Storage:<#{vm.storage.name}> #{stor_k} - #{stor_v.inspect}")}
      $evm.log("info","#{@method} - VM:<#{vm.name}> End VM Storage [vm.storage]")
      $evm.log("info","")
    end

    unless vm.tags.nil?
      $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Tags [vm.tags]")
      vm.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - VM:<#{vm.name}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
      $evm.log("info","#{@method} - VM:<#{vm.name}> End Tags [vm.tags]")
      $evm.log("info","")
    end

    $evm.log("info","#{@method} - VM:<#{vm.name}> Begin Virtual Columns [vm.virtual_column_names]")
    vm.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - VM:<#{vm.name}> Virtual Columns - #{vcn}: #{vm.send(vcn).inspect}")}
    $evm.log("info","#{@method} - VM:<#{vm.name}> End Virtual Columns [vm.virtual_column_names]")
    $evm.log("info","")
  end


  #########################
  #
  # Method: dumpCluster
  # Inputs: $evm.root['ems_cluster']
  # Description: Dump Cluster information
  #
  ##########################
  def dumpCluster(cluster)
    $evm.log("info","#{@method} - Cluster:<#{cluster.name}> Begin Attributes [cluster.attributes]")
    cluster.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Cluster:<#{cluster.name}> Attributes - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - Cluster:<#{cluster.name}> End Attributes [cluster.attributes]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Cluster:<#{cluster.name}> Begin Associations [cluster.associations]")
    cluster.associations.sort.each { |assc| $evm.log("info", "#{@method} - Cluster:<#{cluster.name}> Associations - #{assc}")}
    $evm.log("info","#{@method} - Cluster:<#{cluster.name}> End Associations [cluster.associations]")
    $evm.log("info","")

    unless cluster.tags.nil?
      $evm.log("info","#{@method} - Cluster:<#{cluster.name}> Begin Tags [cluster.tags]")
      cluster.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - Cluster:<#{cluster.name}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
      $evm.log("info","#{@method} - Cluster:<#{cluster.name}> End Tags [cluster.tags]")
      $evm.log("info","")
    end

    $evm.log("info","#{@method} - Cluster:<#{cluster.name}> Begin Virtual Columns [cluster.virtual_column_names]")
    cluster.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - Cluster:<#{cluster.name}> Virtual Columns - #{vcn}: #{cluster.send(vcn)}")}
    $evm.log("info","#{@method} - Cluster:<#{cluster.name}> End Virtual Columns [cluster.virtual_column_names]")
    $evm.log("info","")
  end


  #########################
  #
  # Method: dumpEMS
  # Inputs: $evm.root['ext_managaement_system']
  # Description: Dump EMS information
  #
  ##########################
  def dumpEMS(ems)
    $evm.log("info","#{@method} - EMS:<#{ems.name}> Begin Attributes [ems.attributes]")
    ems.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - EMS:<#{ems.name}> Attributes - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - EMS:<#{ems.name}> End Attributes [ems.attributes]")
    $evm.log("info","")

    $evm.log("info","#{@method} - EMS:<#{ems.name}> Begin Associations [ems.associations]")
    ems.associations.sort.each { |assc| $evm.log("info", "#{@method} - EMS:<#{ems.name}> Associations - #{assc}")}
    $evm.log("info","#{@method} - EMS:<#{ems.name}> End Associations [ems.associations]")
    $evm.log("info","")

    $evm.log("info","#{@method} - EMS:<#{ems.name}> Begin EMS Folders [ems.ems_folders]")
    ems.ems_folders.each { |ef| ef.attributes.sort.each { |k,v| $evm.log("info", "#{@method} - EMS:<#{ems.name}> EMS Folder:<#{ef.name}> #{k}: #{v.inspect}")}}
    $evm.log("info","#{@method} - EMS:<#{ems.name}> End EMS Folders [ems.ems_folders]")
    $evm.log("info","")

    unless ems.tags.nil?
      $evm.log("info","#{@method} - EMS:<#{ems.name}> Begin Tags [ems.tags]")
      ems.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - EMS:<#{ems.name}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
      $evm.log("info","#{@method} - EMS:<#{ems.name}> End Tags [ems.tags]")
      $evm.log("info","")
    end

    $evm.log("info","#{@method} - EMS:<#{ems.name}> Begin Virtual Columns [ems.virtual_column_names]")
    ems.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - EMS:<#{ems.name}> Virtual Columns - #{vcn}: #{ems.send(vcn)}")}
    $evm.log("info","#{@method} - EMS:<#{ems.name}> End Virtual Columns [ems.virtual_column_names]")
    $evm.log("info","")
  end


  #########################
  #
  # Method: dumpStorage
  # Inputs: $evm.root['storage']
  # Description: Dump Storage information
  #
  ##########################
  def dumpStorage(storage)
    $evm.log("info","#{@method} - Storage:<#{storage.name}> Begin Attributes [storage.attributes]")
    storage.attributes.sort.each { |k, v| $evm.log("info", "#{@method} - Storage:<#{storage.name}> Attributes - #{k}: #{v.inspect}")}
    $evm.log("info","#{@method} - Storage:<#{storage.name}> End Attributes [storage.attributes]")
    $evm.log("info","")

    $evm.log("info","#{@method} - Storage:<#{storage.name}> Begin Associations [storage.associations]")
    storage.associations.sort.each { |assc| $evm.log("info", "#{@method} - Storage:<#{storage.name}> Associations - #{assc}")}
    $evm.log("info","#{@method} - Storage:<#{storage.name}> End Associations [storage.associations]")
    $evm.log("info","")

    unless storage.tags.nil?
      $evm.log("info","#{@method} - Storage:<#{storage.name}> Begin Tags [storage.tags]")
      storage.tags.sort.each { |tag_element| tag_text = tag_element.split('/'); $evm.log("info", "#{@method} - Storage:<#{storage.name}> Category:<#{tag_text.first.inspect}> Tag:<#{tag_text.last.inspect}>")}
      $evm.log("info","#{@method} - Storage:<#{storage.name}> End Tags [storage.tags]")
      $evm.log("info","")
    end

    $evm.log("info","#{@method} - Storage:<#{storage.name}> Begin Virtual Columns [storage.virtual_column_names]")
    storage.virtual_column_names.sort.each { |vcn| $evm.log("info", "#{@method} - Storage:<#{storage.name}> Virtual Columns - #{vcn}: #{storage.send(vcn)}")}
    $evm.log("info","#{@method} - Storage:<#{storage.name}> End Virtual Columns [storage.virtual_column_names]")
    $evm.log("info","")
  end


  # List the types of object we will try to detect
  obj_types = %w{ vm host storage ems_cluster ext_management_system }
  obj_type = $evm.root.attributes.detect { |k,v| obj_types.include?(k)}

  # dump root object attributes
  dumpRoot

  # dump miq_server object attributes
  dumpServer

  # dump user attributes
  dumpUser

  # dump miq_group attributes
  dumpGroup


  # If obj_type is NOT nil
  unless obj_type.nil?
    rootobj = obj_type.first
    obj = obj_type.second
    $evm.log("info", "#{@method} - Detected Object:<#{rootobj}>")
    $evm.log("info","")

    case rootobj
    when 'host' then dumpHost(obj)
    when 'vm' then dumpVM(obj)
    when 'ems_cluster' then dumpCluster(obj)
    when 'ext_management_system' then dumpEMS(obj)
    when 'storage' then dumpStorage(obj)
    end
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PowerOn_DHOB" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PowerOn_DHOB
#
# Notes: PowerOn During Hours of Business is triggered via a Custom Button
# and allows VM's to be powered on only during business hours
#
#
###################################
begin
  @method = 'PowerOn_DHOB'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  # Set Business Hour here using 24 hour clock
  after_hours = 17

  #
  # Initialize variables
  #

  # Get VM object
  #vm = $evm.object["vm"]
  vm = $evm.root['vm']

  unless Time.now.hour > after_hours
    $evm.log("info","Powering on VM: <#{vm.name}>")
    vm.start
  else
    $evm.log("info","Cannot power on VM: <#{vm.name.downcase}> due to Business Hours <#{after_hours}> Violation.")
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="PreProvision_sample1" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: PreProvision_sample1
#
# Notes: This method is used to customize the provisioning object prior to provisioning
#
###################################
begin
  @method = 'PreProvision_sample1'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  #
  # Get Variables
  #
  miq_provision = $evm.root["miq_provision"] || $evm.root['miq_provision']
  prov = $evm.root["miq_provision"]
  user = prov.miq_request.requester
  raise "User not specified" if user.nil?


  ###################################
  # Process Intake/RFC Number and set VM Summary Description
  ###################################
  intake = prov.get_option(:vm_description)
  intake = "Intake/RFC Number: #{intake}"
  prov.set_option(:vm_description,intake)


  ###################################
  # Set the customization spec here
  # If one selected in dialog it will be used,
  # else it will map template to customization spec based on template name
  ###################################
  if prov.get_option(:sysprep_custom_spec).nil?
    $evm.log("info", "Forcing the custom spec to match template name")
    customization_spec = miq_provision.vm_template.name # to match the template name
    miq_provision.set_customization_spec(customization_spec)
  end



  ###################################
  # Set the VLAN as follows:
  # miq_provision.set_vlan('default')  # Straight vLAN
  # miq_provision.set_dvs('vlan220')   # Distributed Virtual Switch
  ###################################
  template = miq_provision.vm_template
  virtual_center = template.ext_management_system


  ###################################
  # Was a VLAN selected in dialog?
  # If not you can set one here.
  ###################################
  if prov.get_option(:vlan).nil?
    # Set the Distributed Virtual Switch based on the VC
    if virtual_center.name.downcase.include?('vlab')
      #     miq_provision.set_vlan('vlan22')
      miq_provision.set_dvs('portgroup1')
    else
      #      miq_provision.set_vlan('VLAN207-VMs')
      miq_provision.set_dvs('portgroup2')
    end
  end


  ###################################
  # Set the VM Notes as follows:
  ###################################
  vm_notes = "#{intake}"
  vm_notes +=  "\nOwner: #{miq_provision.get_option(:owner_first_name)} #{miq_provision.get_option(:owner_last_name)}"
  vm_notes += "\nEmail: #{miq_provision.get_option(:owner_email)}"
  vm_notes += "\nSource Template: #{miq_provision.vm_template.name}"

  miq_provision.set_vm_notes(vm_notes)


  ###################################
  # Drop the VM in the targeted folder
  # In VC a folder must exist that matches the LDAP Group
  # VM will be placed in the Folder
  ###################################
  begin

    if prov.get_option(:placement_folder_name).nil?
      ###################################
      # If you want to use a Default folder, set folder = below to the default
      ###################################
      #    folder = "22F DC/LAB FARM/GSE/Intel/Infrastructure/ManageIQ/SelfServiceVMs"
      folder = "DC1/Infrastructure/ManageIQ/SelfService"
      $evm.log("info", "Placing VM in VC folder: <#{folder}")
      $evm.log("info", "Set_folder called with [#{folder.inspect}]")

      miq_provision.set_folder(folder)
    end

  rescue => err
    $evm.log("info", "Set_folder err [#{err}]\n#{err.backtrace.join("\n")}")
  end


  ###################################
  # Set the VM tags based on folder
  ###################################
  if miq_provision.get_tags.empty?

    ###################################
    # Below example is to set Tags based on VC selected
    ###################################
    if virtual_center.name.downcase.include?('prod')
      miq_provision.add_tag(:environment, 'prod')
    else
      miq_provision.add_tag(:environment, 'lab')
    end
    ###################################
    # Below example is to set Tags based on VC folder path
    # This needs to be mapped to how deep the Folder path is from section above
    ###################################
    #  if folder.kind_of?(Array)
    #    paths = folder.last.split('/')
    #    dept, group = paths[-2], paths[-1]
    #    miq_provision.add_tag(:department, dept)
    #    miq_provision.add_tag(:group, group)
    #  end
  end


  ####################################################
  # IP Adress Management
  #
  # Specify filename to read
  # File must contain the following construct
  # VLAN Name  IP Addr    Gateway       Router  status
  ############ #########  ############, ####### ######
  # VM Network,10.1.1.10,255.255.255.0,10.1.1.1,[used, free]
  $evm.log("info", "IP Address Management Starting")
  fname = "/var/www/miq/iplist.csv"
  raise "File '#{fname}' does not exist" unless File.exist?(fname)

  # Get VM Name to be provisioned
  vm_hostname = prov.get_option(:vm_target_name).strip.gsub(/\W/, '_')
  vm_vlan = prov.get_option(:vlan)
  $evm.log("info", "VM VLAN: <#{vm_vlan}>")
  $evm.log("info", "VM Name: <#{vm_hostname}>")


  # Regular Expression to match the following construct:
  # VLAN Name ,IP Addr  Subnet Mask  ,Gateway , [used,free]
  # VM Network,10.1.1.1,255.255.255.0,10.1.1.1,used
  regex_line = /^(vlan.*|vm\snet.*|VM2.*),(\d*).(\d*).(\d*).(\d*),(\d*).(\d*).(\d*).(\d*),(\d*).(\d*).(\d*).(\d*),(\w*)/i
  $evm.log("info", "regex_line: <#{regex_line}>")

  # Open file for reading and iterate through the file looking for a match
  File.open(fname) do |file|
    file.each do |line|
      # convert everything to lowercase and strip all leading/trailing whitespaces
      line = line.strip

      # if the regular expression successfully matches else skip the line
      if regex_line =~ line
        vlan    = $1
        octet1  = $2
        octet2  = $3
        octet3  = $4
        octet4  = $5
        mask1   = $6
        mask2   = $7
        mask3   = $8
        mask4   = $9
        gate1   = $10
        gate2   = $11
        gate3   = $12
        gate4   = $13
        tmp_name  = $14
        ipaddr  = "#{octet1}.#{octet2}.#{octet3}.#{octet4}"
        submask = "#{mask1}.#{mask2}.#{mask3}.#{mask4}"
        gateway = "#{gate1}.#{gate2}.#{gate3}.#{gate4}"

        $evm.log("info", "Processing Line: <#{line}> VLAN: <#{vlan}> IP: <#{ipaddr}> Mask: <#{submask}> Gateway: <#{gateway}> Name: <#{tmp_name}>")

        # If a the VLAN's match and there is a free slot found then switch it to the VM's hostname
        if vm_vlan == vlan && tmp_name == "free"
          newline = "#{vlan},#{ipaddr},#{submask},#{gateway},#{vm_hostname}"
          $evm.log("info", "Replacing Line: <#{line},> with : <#{newline}> in file: <#{fname}")

          # Use sed to do an in-place subtitution
          `sed -i 's/#{vlan},#{octet1}\.#{octet2}\.#{octet3}\.#{octet4},#{mask1}\.#{mask2}\.#{mask3}\.#{mask4},#{gate1}\.#{gate2}\.#{gate3}\.#{gate4},#{tmp_name}/#{vlan},#{octet1}\.#{octet2}\.#{octet3}\.#{octet4},#{mask1}\.#{mask2}\.#{mask3}\.#{mask4},#{gate1}\.#{gate2}\.#{gate3}\.#{gate4},#{vm_hostname}/' #{fname}`

          # Set provisioning options to override options
          prov.set_option(:sysprep_spec_override, [true, 1])
          # prov.set_option(:sysprep_timezone, "020")
          prov.set_option(:addr_mode, ["static", "Static"])
          prov.set_option(:ip_addr, ipaddr)
          prov.set_option(:subnet_mask, submask)
          prov.set_option(:gateway, gateway)
          $evm.log("info", "Provision Options: #{prov.options.inspect}")
          exit MIQ_OK
        else
          $evm.log("info", "Skipping Line: <#{line}>. Dialog VLAN: <#{vm_vlan}> File VLAN: <#{vlan}> and VM Name: <#{tmp_name}>")
        end #if status
      else
        $evm.log("info", "Line: <#{line}> does not match criteria in file: <#{fname}>")
      end
    end # file.each do
  end # file open do

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Retrieve_attachment" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: Retrieve_attachment
#
# This method is used to pull attachment from email and place in a directory
#
# ManageIQ: Bill Helgeson
###################################
begin
  @method = 'Retrieve_attachment'
  $evm.log("info", "Inline Method: <#{@method}>  EVM Automate Method Started")

  # Turn on verbose logging
  @debug = true

  # Load required ruby gem
  require 'mail'

  # Get values from class object
  mailhost = $evm.object['mailhost']
  mailuser = $evm.object['mailuser']
  mailpass = $evm.object['mailpass'].decrypt
  mailport = $evm.object['mailport']
  mailssl = $evm.object['mailssl']
  remoteDir = $evm.object['remoteDir']

  # Log into account pop3
  Mail.defaults do
    retriever_method :pop3, :address => mailhost,
                     :port => mailport,
                     :user_name => mailuser,
                     :password => mailpass,
                     :enable_ssl => mailssl
  end

  # Get all the emails
  emails = Mail.all

  # Do we have mail
  if emails.empty?
    $evm.log("info", "Inline Method: <#{@method}> - No Emails") if @debug
  end

  unless emails.empty?
    # We have Emails to process
    # Process Emails
    emails.each do |m|
      # Make sure email subject is for our report
      if m.subject == "Report From EVM"
        $evm.log("info", "Inline Method: <#{@method}> - Processing email from #{m.from} for report #{m.subject}") if @debug
        # Process all attachments for this email
        m.attachments.each do |attachment|
          filename = attachment.filename
          # Place the attachment on the remote share
          File.open("#{remoteDir}/#{filename}", "w+b", 0644) { |f| f.write attachment.body.decoded }
          $evm.log("info", "Inline Method: <#{@method}> - Report #{filename} retrieved") if @debug
        end
        # Mark processed email for delete
        m.mark_for_delete = true
      else
        $evm.log("info", "Inline Method: <#{@method}> - Report #{m.subject} does not qualify") if @debug
        next
      end
    end
    # Clean up emails
    Mail.find_and_delete
    $evm.log("info", "Inline Method: <#{@method}> - Reports delivered") if @debug
  end

  ############
  # Exit method
  #
  $evm.log("info", "Inline Method: <#{@method}>  EVM Automate Method Ended")
  exit MIQ_OK

#
# Set Ruby rescue behavior
#
rescue => err
  $evm.log("error", "Inline Method: <#{@method}> - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="auto_tag" language="ruby" scope="instance" location="inline"><![CDATA[#
# EVM Automate Method: Auto_Tag
#
# Notes: This method is used to Auto Tag VMs based on ASCII file content
# extracted from VM Analysis
#
#
###################################
begin
  @method = 'Auto_Tag'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  #
  # Method: Process Categories & Tags
  #
  def process_categories( vm, category, tag )

    # Convert to lower case and replace all non-word characters with underscores
    category_name = category.downcase.gsub(/\W/, '_')
    tag_name = tag.downcase.gsub(/\W/, '_')
    $evm.log("info", "Converted category name: <#{category_name}>")
    $evm.log("info", "Converted tag name: <#{tag_name}>")

    # if the category exists else create it
    if $evm.execute('category_exists?', category_name)
      $evm.log("info", "Category <#{category_name}> exists")
    else
      $evm.log("info", "Category <#{category_name}> doesn't exist, creating category")
      $evm.execute('category_create', :name => category_name, :single_value => true, :description => "#{category}")
    end

    # if the tag exists else create it
    if $evm.execute('tag_exists?', category_name, tag_name)
      $evm.log("info", "Tag <#{tag_name}> exists")
    else
      $evm.log("info", "Adding new tag <#{tag_name}> in Category <#{category_name}>")
      $evm.execute('tag_create', category_name, :name => tag_name, :description => "#{tag}")
    end

    # Tag VM with category/tag information
    if vm.tagged_with?(category_name,tag_name)
      $evm.log("info", "VM already tagged with <#{tag_name}> in Category <#{category_name}>")
    else
      $evm.log("info", "Tagging VM with new <#{tag_name}> tag in Category <#{category_name}>")
      vm.tag_assign("#{category_name}/#{tag_name}")
    end
  end


  #
  # Method: Update VC Custom Attributes
  #
  def process_customattributes( vm, category, tag )
    custom_value = vm.ems_custom_get(category)

    # Only apply EMS custom attributes if they are different or do not exist
    unless custom_value == tag
      $evm.log("info", "Updating EMS Custom Attribute <#{category}> with <#{tag}>")
      vm.ems_custom_set(category, tag)
    else
      $evm.log("info", "Skipping Update of EMS Custom Attribute <#{category}> with <#{tag}>")
    end
  end


  #
  # Find the VM
  #
  vm = $evm.root['vm']
  return if vm.nil?


  # Regular Expression to match the following construct:
  # 000A0500Business Unit|CORE
  # 1) ^\w{8} - match the 1st 8 word characters
  # 2) (\D.*) - match the next alpha character and up to the pipe
  # 3) (.*) - match everything after the pipe
  reg_ex = /^\w{8}(\D.*)\|(.*)/

  # Log the current custom attributes on the VM
  custom_keys = vm.ems_custom_keys
  custom_keys.each do |ck|
    ck_val = vm.ems_custom_get(ck)
    $evm.log("info", "Found EMS Custom Attribute: <#{ck}> with value: <#{ck_val}>") if @debug
  end

  # Loop and display file content only for targeted file
  vm_files = vm.files
  vm_files.each do |f|
    # if the file name "computer.mnv" collected in the analysis profile exists
    # note: you can also specify a absolute path as well i.e. "c:/progra~1/CA/computer.mnv"
    if f.name.downcase.include?("computer.mnv")
      contents = f.contents
      lines = contents.split("\n")

      $evm.log("info", "File Name: <#{f.name}>")
      $evm.log("info", "File Size: <#{f.size}>")
      $evm.log("info", "File lines: <#{lines.length}>")
      lines.each_with_index do |line, idx|
        # if the regular expression successfully matches else skip the line
        if reg_ex =~ line.chomp
          category = $1
          tag = $2
          $evm.log("info", "Processing Line#: <#{idx+1}> Line: <#{line}> Category: <#{category}> Tag: <#{tag}>")
          process_categories(vm, category, tag)
          process_customattributes(vm, category, tag)
        else
          $evm.log("info", "Skipping Line#: <#{idx+1}> Line: <#{line}>")
        end
      end
    end
  end


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="clone" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: clone
#
# Notes: This method is run from "VM Lifecycle - Clone (vm_clone)"
#
###################################
begin
  @method = 'clone'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Log the inbound object
  $evm.log("info", "===========================================")
  process = $evm.object("process")
  $evm.log("info", "Listing Process Attributes:")
  process.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")}
  $evm.log("info", "===========================================")

  # start working
  current = $evm.object
  $evm.log("info", "Got current object")

  vm        = current["vm"]
  $evm.log("info", "Got VM from current object")
  ems       = vm.ext_management_system
  $evm.log("info", "Got EMS from VM")
  host      = vm.host
  $evm.log("info", "Got Host from VM")

  #Find the tagged host(s) with the least number of vms
  tag       = "/managed/function/citrix"
  hosts     = $evm.vmdb(:host).find_tagged_with(:all => tag, :ns => "*")
  $evm.log("info", "Got #{hosts.length} Hosts tagged with #{tag}")
  dest_host = hosts.sort{|a,b| a.vms.length <=> b.vms.length}.first
  $evm.log("info", "Sorted Hosts")
  dest_host = dest_host.name
  $evm.log("info", "Selected Host = #{dest_host}")

  # Find tagged storage(s) with least number of VMs
  storages     = $evm.vmdb(:storage).find_tagged_with(:all=>tag, :ns=>"*")
  $evm.log("info", "Got #{storages.length} Storages tagged with #{tag}")
  dest_storage = storages.sort{|a,b| a.vms.length <=> b.vms.length}.first
  $evm.log("info", "Sorted Storages")
  dest_storage = dest_storage.name
  $evm.log("info", "Selected Storage = #{dest_storage}")

  vm_finder = $evm.vmdb(:vm)
  $evm.log("info", "Got VMFinder Object")
  # Name the VM, takes the vm name passed and adds 1 thru 99 till name does not exist in vmdb
  vm2 = nil
  99.times do |i|
    vm2 = vm.name + "_#{i+1}"
    $evm.log("info", "Trying #{vm2}")
    break unless vm_finder.find_by_name(vm2)
  end
  $evm.log("info", "Selected VM2 = #{vm2}")

  # Build the Perl command using the VMDB information
  cmd  = "nohup perl /usr/lib/vmware-viperl/apps/vm/vmclone.pl"
  cmd += " --url https://#{ems.ipaddress}:443/sdk/vimservice"
  cmd += " --username \"#{ems.authentication_userid}\""
  cmd += " --password \"#{ems.authentication_password}\""
  cmd += " --vmname \"#{vm.name}\""
  cmd += " --vmname_destination \"#{vm2}\""
  cmd += " --datastore \"#{dest_storage}\""
  cmd += " --vmhost \"#{dest_host}\""
  cmd += " &"
  $evm.log("info", "Running: #{cmd}")
  #results = `#{cmd}`
  results = system(cmd)
  #Continue the Trap error

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="cluster_cpu_utilization" language="ruby" scope="instance" location="inline"><![CDATA[##################################
#
# EVM Automate Method: cluster_cpu_utilization
#
# Notes:  This method will attempt to power on or off Grid Application VM based on an alert
#         It is called in three ways; high cpu utilization, low cpu utilization, and hourly for business hours check
#  The criteria is:
#                      Not business hours: (currently for testing between the hours of 5 and 17)
#                      Cluster is tagged with tag category: eligible tag:  true
#                      Vms within the cluster are tagged with category:  application:  tag: grid
#                      Check for power state
#  Code changed and consolidated based on updated logic flow:
#                      1. Is cluster eligible?
#                      2. Are any VMs tagged as grid?
#                      3. Is it a weekend?
#                       if so, is weekend processing allowed?
#                       if not, is it during business hours?
#                      4. how did we get here?  utilization values? - high, low , periodic
#                       periodic means that we are here as a result of a business hours hourly alert
#                       and that means that we are trying to shut down grid vms when they shouldnt be running.
###################################
begin
  @method = 'cluster_cpu_utilization'

  $evm.log("info", "GRIDPROCESSING ===== EVM Automate Method: <#{@method}> Started")
  # Turn on verbose logging
  debug = true
  def get_eligible_vms(ems_cluster, current_power_state)
    grid_vms = nil
    hosts = ems_cluster.hosts
    hosts.each  do  |h|
      vms = h.vms
      if current_power_state == "all"
        $evm.log("info","GRIDPROCESSING Searching for eligible grid VMs." )
        grid_vms = h.vms.find_all { |v| v.tagged_with?('application', 'grid') }
        $evm.log("info","GRIDPROCESSING Found <#{grid_vms.length}> eligible grid VMs.  Power state not checked. " )
      else
        $evm.log("info","GRIDPROCESSING Searching for eligible grid VMs that are currently powered #{current_power_state}" )
        grid_vms = h.vms.find_all { |v| v.tagged_with?('application', 'grid') &&  v.power_state == current_power_state}
        $evm.log("info","GRIDPROCESSING Found <#{grid_vms.length}> eligible grid VMs that are currently powered #{current_power_state}" )
      end
    end
    return grid_vms
  end
  def power_on_vms(grid_vms, number_of_vms)
    count = 0
    $evm.log("info","GRIDPROCESSING Powering on <#{number_of_vms}> VMs")
    grid_vms.each  do  |g|
      if count < number_of_vms
        $evm.log("info","GRIDPROCESSING Found eligible grid vm: <#{g.name}>")
        $evm.log("info","GRIDPROCESSING Powering on Grid Application workload vm: <#{g.name}> ")
        g.start
        $evm.log("info","GRIDPROCESSING Powered on Grid Application workload vm: <#{g.name}> ")
      end
      count += 1
    end
    return count
  end

  def power_off_vms(grid_vms, number_of_vms)
    count = 0
    return if grid_vms.length == 0
    $evm.log("info","GRIDPROCESSING Powering off <#{number_of_vms}> VMs")
    grid_vms.each  do  |g|
      if count < number_of_vms
        $evm.log("info","GRIDPROCESSING Found eligible grid vm: <#{g.name}>")
        $evm.log("info","GRIDPROCESSING Powering off Grid Application workload vm: <#{g.name}> ")
        g.stop
        $evm.log("info","GRIDPROCESSING Powered off Grid Application workload vm: <#{g.name}> ")
        count += 1
      end
    end
    return count
  end
  def get_grid_options
    params = {}
    $evm.log("info", "GRIDPROCESSING Listing Object Attributes:")
    obj = $evm.object
    obj.attributes.sort.each { |k, v| $evm.log("info", "GRIDPROCESSING \t#{k}: #{v}")}
    $evm.log("info", "GRIDPROCESSING ===========================================")

    params[:number_of_vms] = obj['number_of_vms'].to_i
    # get the number of vms and business hours from the instance
    if params[:number_of_vms].nil?
      $evm.log("info", "GRIDPROCESSING Number of vms not specified in instance - default is 1 VM")
      number_of_vms = 1
    else
      $evm.log("info", "GRIDPROCESSING Instance specified number of vms is : #{params[:number_of_vms]}")
    end
    params[:start_business_hour] = obj['start_business_hour'].to_i
    if params[:start_business_hour].nil?
      $evm.log("info", "GRIDPROCESSING Business hour start not specified in instance - defaulting to 9 am")
      start_business_hour = 9
    else
      $evm.log("info", "GRIDPROCESSING Business hour start specified is : #{params[:start_business_hour]}")
    end
    params[:end_business_hour] = obj['end_business_hour'].to_i
    if params[:end_business_hour].nil?
      $evm.log("info", "GRIDPROCESSING Business hour end not specified in instance - defaulting to 5 pm")
      end_business_hour = 17
    else
      $evm.log("info", "GRIDPROCESSING Business hour end specified is : #{params[:end_business_hour]}")
    end
    params[:weekend_processing] = obj['weekend_processing']
    if params[:weekend_processing].nil?
      $evm.log("info", "GRIDPROCESSING Weekend Processing not specified in instance - defaulting to weekend processing")
      weekend_processing = true
    else
      $evm.log("info", "GRIDPROCESSING Weekend Processing specified is : #{params[:weekend_processing]}")
    end
    # get the utilization type (high, low, periodic)
    params[:utilization_type] = obj['utilization_type'].downcase
    if params[:utilization_type].nil?
      $evm.log("info", "GRIDPROCESSING Utilization type not specified in instance")
    else
      $evm.log("info", "GRIDPROCESSING Utilization type specified is : #{params[:utilization_type]}")
    end
    return params
  end
  ### start here
  options = {}
  options = get_grid_options
  $evm.log("info","GRIDPROCESSING get_grid_options params: #{options.inspect}")
  # 1. Only check for eligible grid cluster on low utilization.  We still want to shut down grid VMs in any case.
  # need the cluster information to check for tag
  ems_cluster = $evm.root['ems_cluster']
  if options[:utilization_type] == 'low'
    unless ems_cluster.tagged_with?('eligible', 'true')
      $evm.log("info","GRIDPROCESSING Attempt to start a Grid Application workload on an ineligible Cluster: <#{ems_cluster.name}>")
      exit MIQ_OK
    end
  end
  # 2. Are any VMs tagged as grid?   Note - no check for current power state here
  grid_vms = get_eligible_vms(ems_cluster,"all")
  eligible_vm_count = grid_vms.length
  if eligible_vm_count == 0
    $evm.log("info","GRIDPROCESSING No Grid VMS found on Cluster: <#{ems_cluster.name}> .")
    exit MIQ_OK
  else
    $evm.log("info","GRIDPROCESSING Found : <#{eligible_vm_count}> VMs.")
  end
  t = Time.now
  $evm.log("info","GRIDPROCESSING The day of the week is : #{t.wday}")
  $evm.log("info","GRIDPROCESSING The hour of the day is : #{t.hour}")
  # 3. Is it the weekend, and if so, is weekend processing allowed?
  if t.wday == 0 || t.wday == 6
    if options[:weekend_processing] == false
      $evm.log("info", "GRIDPROCESSING It is the weekend. Not performing Grid Application processing during weekends.")
      $evm.log("info", "GRIDPROCESSING Find ALL Grid VMs that are powered on and power them off here.")
      grid_vms = get_eligible_vms(ems_cluster,'on')
      eligible_vm_count = grid_vms.length
      $evm.log("info", "GRIDPROCESSING Found <#{eligible_vm_count}> VMs to be powered off.")
      count = power_off_vms(grid_vms, eligible_vm_count)
      exit MIQ_OK
    else
      $evm.log("info", "GRIDPROCESSING It is the weekend, but weekend processing has been specified.")
    end
  else 
    # not the weekend, is it during business hours?
    if t.hour >= options[:start_business_hour] && t.hour <= options[:end_business_hour]-1
      $evm.log("info", "GRIDPROCESSING Current time falls within the business hours specified. Not Performing Grid Application processing during business hours.")
      $evm.log("info", "GRIDPROCESSING Find ALL Grid VMs that are powered on and power them off here.")
      grid_vms = get_eligible_vms(ems_cluster,'on')
      eligible_vm_count = grid_vms.length
      $evm.log("info", "GRIDPROCESSING Found <#{eligible_vm_count}> VMs to be powered off.")
      count = power_off_vms(grid_vms, eligible_vm_count)
      exit MIQ_OK
    end
  end

  # 4. How did we get called?  high util, low util, or periodic business hours/weekend check?
  case options[:utilization_type]
  when 'periodic'
    $evm.log("info", "GRIDPROCESSING Utilization type periodic specified specified - no more work to do: #{options[:utilization_type]}")
    exit MIQ_OK
  when 'high'
    $evm.log("info", "GRIDPROCESSING High Threshold processing  ")
    # Commented by bucklast 19/7/2011
    # $evm.log("info", "GRIDPROCESSING High Threshold processing - number of vms set to 1 ")
    # options[:number_of_vms] = 1
    # End comment block bucklast 19/7/2011
    grid_vms = get_eligible_vms(ems_cluster,'on')
    power_off_vms(grid_vms, options[:number_of_vms])   unless grid_vms.length == 0
  when 'low'
    $evm.log("info", "GRIDPROCESSING Low Threshold processing  ")
    grid_vms = get_eligible_vms(ems_cluster,'off')
    power_on_vms(grid_vms, options[:number_of_vms])    unless grid_vms.length == 0
  else
    $evm.log("info", "GRIDPROCESSING Cannot continue without Utilization type of high, low or periodic")
    exit MIQ_OK
  end

  #
  # Exit method
  #
  $evm.log("info", "GRIDPROCESSING ===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK
  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="extend_retirement_date" language="ruby" scope="instance" location="inline"><![CDATA[######################################################################################################
  # EVM Extend Retirement Date method
  ######################################################################################################
  #
  #        Description: Add 14 days to retirement date when target VM has a retires_on value and is not already retired
  #        Version    : 1.0
  #        Last Update: 09102010
  #        Author:    : ManageIQ
  #
  #        1-setting "debug = true" will enable full visualizatoin of objects "process", "VM" and "user"
  #        2- default but dormant date threshold is 14 days
  #        3- threshold activation achieved by setting "activate_date_threshold" to true
  #            when threshold is active, then VMs with a retires_on value more than "future_threshold_in_days" value
  #             in the future will be logged but not changed.
  #
  #        Objects Referenced:
  #         - evm.root              -   default automation object
  #         - evm.object["process'] -           -   job object
  #         - evm.root["vm"]        -   vm to be processed
  #         - evm.root["user"]      -   information about operator requesting retirement extension

begin_time = Time.now             # used for timing of method & logging at method end
$evm.log("info", "===== EVM Automate Method 'extend_retirement_date' Started")
$evm.log("info", "created 9/10/2010 by tch (manageiq)")

def exit_method( begin_time)
$evm.log("info", "===== EVM Automate Method 'extend_retirement_date' Ended -> duration #{Time.now - begin_time} seconds")
exit MIQ_OK
end

debug = false
# if debug is true then the user and VM objects will be fully exposed, otherwise
# these sections of code will be skipped (tch 2010-09-09)

activate_date_threshold = false
# if activate_date_threshold = true then VMs with a retirement date greater than
# that threshold will not be modified.  the threshold is a count of the number of days
# between the current date and the date set as vm.retires_on.  If the count exceeds the
# threshold and the threshold is active, then no change to the retirement date will occur

# *  * * * * * * * * * * * * *  ***
future_threshold_in_days = 14

# future_threshold_in_days is provided as a limit as to how far into the future a retirement
# may be set and still allow for the retirement action to be performed.
# the code is in place to use this threshold, but is commented out since no threshold
# has as yet been requested.
# *  * * * * * * * * * * * * *  ***




$evm.log("info","current date info '#{DateTime.now}' - '#{Time.now()}'")
work_datetime = Time.at(Time.now.to_f + (future_threshold_in_days * 24 * 3600))
$evm.log("info","value of proposed future threshold date is '#{work_datetime}'")

future_limit = Date.new(work_datetime.year, work_datetime.month, work_datetime.day)

#future_limit is being constructed as a Date type field so that comparison with vm.retires_on is
# a like-for-like comparison and we can do differencing on the dates.

#if retirement > future_threshold_in_days days in future, don't retire - warning only
# it still will update the retirment date


if debug then
     $evm.log("info","future_limit is of type '#{future_limit.class.to_s}' with value of '#{future_limit}'")
end

#
#            Method Code Goes here
#
evm = $evm.object
if debug then
     $evm.log("info","evaluating and displaying 'evm.object' object")
     $evm.log("info"," evm.object is of type '#{evm.class.to_s}'")
     evm.attributes.sort.each { |k,v| $evm.log("info", "\t#{k}: \(#{k.class.to_s}\) -> #{v}") }
     $evm.log("info","===== end of evm.object elements =====\n")
end

obj = $evm.object("process")
if debug then
     $evm.log("info", "evaluating and displaying 'process' object")
     $evm.log("info"," evm.object\(\"process\"\) is of type '#{obj.class.to_s}'")
     obj.attributes.sort.each { |k, v|  $evm.log("info", "\t#{k}: \(#{k.class.to_s}\)->#{v}") }
end


vm = obj["vm"]
if debug then
     $evm.log("info", "evaluating and displaying obj[vm] object try 1")
     $evm.log("info", "display 'vm' object info -> 'vm' is of type #{vm.class.to_s}" )
end

vm = $evm.object["vm"]
if debug then
     $evm.log("info", "evaluating and displaying 'vm' object try 2")
     $evm.log("info", "display 'vm' object info -> 'vm' is of type #{vm.class.to_s}" )
end

vm = $evm.root["vm"]
if debug then
     $evm.log("info", "===== begin evaluating and displaying 'vm' object try 3 =====")
     $evm.log("info", "display 'vm' object info -> 'vm' is of type #{vm.class.to_s}" )
     vm.attributes.sort.each { |k,v| $evm.log("info", "\t#{k}: of type '#{k.class.to_s}' has value '#{v}'") }
     # $evm.log("info","vm.inspect yields ->'#{vm.inspect}' ")
     $evm.log("info", "===== end evaluating and displaying 'vm' object try 3 =====")
end
case vm.retires_on
    when nil then
          $evm.log("info","VM '#{vm.name}' has no retirement date - extension bypassed")
          exit_method(begin_time)
     when "" then
          $evm.log("info","VM '#{vm.name}' has no retirement date - extension bypassed")
          exit_method(begin_time)

end

# since the vm.retired attribute is not exposed for alteration in the automate code, we cannot unretire
# a VM, so we will also not allow the retirement date to be altered on a VM that is already retired.
if vm.retired then
     $evm.log("info", "vm '#{vm.name}' is already marked as retired. vm.retires_on date value is  #{vm.retires_on}. No Action taken")
     exit_method(begin_time)
end

if debug then
     $evm.log("info","value of vm.retires_on is '#{vm.retires_on}'")
end

#if debug then
#     $evm.log("info", "expose local variable pool")
#     local_variables.each { |k| $evm.log("info", "\t#{k} -> #{eval(k.class.to_s)} ->#{eval(k)} ") }
#     eval("local_variables").each { |k| $evm.log("info", "local variable ->\t#{k}") }
#end

if debug then
     $evm.log("info", "expose vm attributes and values")
     # vm.attributes.sort.each { |k,v| $evm.log("info", "\t#{k}: of type '#{k.class.to_s}' with value of '#{v}'" ) }
     $evm.log("info","#{vm.inspect}")
end

$evm.log("info", "vm retirement date is #{vm.retires_on}")

#if vm.retires_on.to_i > future_limit.to_i then # DateTime can't handle .to_f method
$evm.log("info","date delta calculation #{future_limit - vm.retires_on} days") if debug
if (future_limit - vm.retires_on) < 0 then
     $evm.log("info","VM '#{vm.name}' retirement date '#{vm.retires_on}' more than #{future_threshold_in_days} days in future ")
     if activate_date_threshold then
          $evm.log("info","VM '#{vm.name}' retirement date not changed")
          exit_method(begin_time)
      end
end



user = $evm.root["user"]
$evm.log("info","vm name '#{vm.name}' retirement date being altered by userid '#{user.userid}' role-> '#{user.name}'. ")

if debug then
    $evm.log("info"," ===== attempt to expose entire user object =====\n")
     user.attributes.sort.each { |k,v| $evm.log("info", "\t#{k}: #{v}") }
     $evm.log("info","===== end attempt to expose entire user object =====\n")
end


unless vm.retires_on.nil?
  # Set new retirement date here
  vm.retires_on = vm.retires_on + 14

  $evm.log("info", "vm new retirement date is #{vm.retires_on}")


  # Save
  #vm.save
end
#
#
#
exit_method(begin_time)
#$evm.log("info", "===== EVM Automate Method 'extend_retirement_date' Ended -> duration #{end_time - begin_time} seconds")
#exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="group_specific_quotas" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: group_specific_quotas
#
# Notes: This method allows for specific quotas based on ldap group membership
#
###################################
begin
  @method = 'group_specific_quotas'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Get ldap Group
  $evm.log("info", "Starting check for Individual Team Quotas")
  group = $evm.root['miq_request'].requester.ldap_group rescue nil

  # max_group_cpu = total cpu count
  # max_group_memory = total memory allocated to group in MBs
  # max_group_storage = total memory allocated to group in GBs

  $evm.log("info", "Checking for specific quota for group: <#{group}>")

  if group == "poc"
    $evm.log("info", "Setting Quota Thresholds for Group <#{group}>")
    #    $evm.current['max_group_cpu'] = '0'
    #    $evm.log("info", "Max CPU allowed for Group: <#{$evm.current['max_group_cpu']}>")
    #   $evm.current['max_group_memory'] = '4080'
    #   $evm.log("info", "Max Memory allowed for Group: <#{$evm.current['max_group_memory']}>")
    #   $evm.current['max_group_storage'] = '0'
    #   $evm.log("info", "Max Storage allowed for Group: <#{$evm.current['max_group_storage']}>")
    exit(MIQ_OK)
  end

  if group == "demo-test"
    $evm.log("info", "Setting Quota Thresholds for Group <#{group}>")
    $evm.current['max_group_cpu'] = '10'
    $evm.log("info", "Max CPU allowed for Group: <#{$evm.current['max_group_cpu']}>")
    $evm.current['max_group_memory'] = '40960'
    $evm.log("info", "Max Memory allowed for Group: <#{$evm.current['max_group_memory']}>")
    $evm.current['max_group_storage'] = '1500'
    $evm.log("info", "Max Storage allowed for Group: <#{$evm.current['max_group_storage']}>")
    exit(MIQ_OK)
  end

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="print_profiles" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: print_profiles
#
# Notes: This method is launched from "VM Lifecycle - Created (vm_created)"
#
###################################
begin
  @method = 'print_profiles'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  disc = $evm.object.children('rel3')
  $evm.log("info", "XXXXX Discovery Object = [#{disc.inspect}]")
  $evm.log("info", "Discovery Results: [#{disc['name']}] - #{$evm.object.attributes['profiles'].inspect}")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="servicename_sample" language="ruby" scope="instance" location="inline" display_name="servicename_sample"><![CDATA[#
  #            EVM Automate Method
  #
  $evm.log("info", "EVM Automate Method Servicename_sample Started")
  #
  #
  $evm.log("info", "===========================================")  
  $evm.log("info", "Listing ROOT Attributes:")
  $evm.root.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")}
  $evm.log("info", "===========================================")

  dialog_service_name = $evm.root['dialog_service_name']
  if dialog_service_name.blank?
    $evm.log("info","Dialog service name not specified. Service will not be renamed.")
    exit MIQ_OK
  end
    
  $evm.log("info","Set service name to Dialog option = [#{dialog_service_name}]")
   
  # Get destination service object
  service = $evm.root["service_template_provision_task"].destination
  $evm.log("info","#{@method} - Changing service name from: <#{service.name}> to: #{dialog_service_name}") if @debug
  service.name = dialog_service_name
  $evm.log("info","#{@method} - Service object: <#{service.inspect}>") if @debug
  $evm.log("info", "EVM Automate Method Servicename_sample Ended")
  exit MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="vdi_reboot" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vdi_reboot
#
# Notes: This method reboots the VDI endpoint for a VM
#
#
###################################
begin
  @method = 'vdi_reboot'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  $evm.log("info", "===========================================")
  process = $evm.object("process")
  $evm.log("info", "Listing Process Attributes:")
  process.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug

  current = $evm.object
  $evm.log("info", "Listing Current Object Attributes:")
  current.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug

  $evm.log("info", "===========================================")

  vm = current["vm"]
  $evm.log("info", "Inspecting VM: <#{vm.inspect}>") if @debug

  cmd = "snmpset -v1 -c public #{vm.vdi_endpoint_ip_address} SNMPv2-SMI::enterprises.714.1.2.6.1.1.0 i: 0"
  $evm.log("info", "CMD: #{cmd}")
  result = `#{cmd}`
  $evm.log("info", "Command completed: result=#{result}")

  $evm.log("info", "Device ReStarted")


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm2clone" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm2clone
#
# Notes: This method will clone a VM to a new VM using the perl CLI
#
###################################
begin
  @method = 'vm2clone'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of debugging
  @debug = true

  # Log the inbound object
  $evm.log("info", "===========================================")
  process = $evm.object("process")
  $evm.log("info", "Listing Process Attributes:")
  process.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug
  $evm.log("info", "===========================================")

  vm = $evm.root['vm']
  $evm.log("info", "Got VM from root object")
  $evm.log("info","Inspecting vm: #{vm.inspect}") if @debug



  ems       = vm.ext_management_system
  $evm.log("info", "Got EMS <#{ems.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting ems: #{ems.inspect}") if @debug

  host      = vm.host
  $evm.log("info", "Got Host <#{host.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting host: #{host.inspect}") if @debug

  dest_host = host.ipaddress
  $evm.log("info", "Using Destination Host <#{dest_host}>")
  $evm.log("info","Inspecting dest_host: #{dest_host.inspect}") if @debug

  storages = vm.storage
  $evm.log("info", "Got Storages <#{storages.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting storages: #{storages.inspect}") if @debug

  dest_storage = storages.name
  $evm.log("info", "Using Destination Storage <#{dest_storage}>")
  $evm.log("info","Inspecting dest_storage: #{dest_storage.inspect}") if @debug


  #Find the tagged host(s) with the least number of vms
  #tag       = "/managed/function/citrix"
  #hosts     = $evm.vmdb(:host).find_tagged_with(:all => tag, :ns => "*")
  #$evm.log("info", "Got #{hosts.length} Hosts tagged with #{tag}")
  #dest_host = hosts.sort{|a,b| a.vms.length <=> b.vms.length}.first
  #$evm.log("info", "Sorted Hosts")
  #dest_host = dest_host.name
  #$evm.log("info", "Selected Host = #{dest_host}")

  # Find tagged storage(s) with least number of VMs
  #storages     = $evm.vmdb(:storage).find_tagged_with(:all=>tag, :ns=>"*")
  #$evm.log("info", "Got #{storages.length} Storages tagged with #{tag}")
  #dest_storage = storages.sort{|a,b| a.vms.length <=> b.vms.length}.first
  #$evm.log("info", "Sorted Storages")
  #dest_storage = dest_storage.name
  #$evm.log("info", "Selected Storage = #{dest_storage}")

  vm_finder = $evm.vmdb(:vm)
  $evm.log("info", "Got VMFinder Object")
  # Name the VM, takes the vm name passed and adds 1 thru 99 till name does not exist in vmdb
  vm2 = nil
  99.times do |i|
    vm2 = vm.name + "_#{i+1}"
    $evm.log("info", "Trying #{vm2}")
    break unless vm_finder.find_by_name(vm2)
  end
  $evm.log("info", "Selected VM2 = #{vm2}")

  # Build the Perl command using the VMDB information
  cmd  = "nohup perl /usr/lib/vmware-vcli/apps/vm/vmclone.pl"
  cmd += " --url https://#{ems.ipaddress}:443/sdk/vimservice"
  cmd += " --username \"#{ems.authentication_userid}\""
  cmd += " --password \"#{ems.authentication_password}\""
  cmd += " --vmname \"#{vm.name}\""
  cmd += " --vmname_destination \"#{vm2}\""
  cmd += " --datastore \"#{dest_storage}\""
  cmd += " --vmhost \"#{dest_host}\""
  cmd += " &"
  $evm.log("info", "Running: #{cmd}")
  #results = `#{cmd}`
  results = system(cmd)


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vm2template" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm2template
#
# Notes: This method will convert a VM to template using the perl CLI
#
###################################
begin
  @method = 'vm2template'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of debugging
  @debug = true

  # Log the inbound object
  $evm.log("info", "===========================================")
  process = $evm.object("process")
  $evm.log("info", "Listing Process Attributes:")
  process.attributes.sort.each { |k, v| $evm.log("info", "\t#{k}: #{v}")} if @debug
  $evm.log("info", "===========================================")

  vm = $evm.root['vm']
  $evm.log("info", "Got VM from root object")
  $evm.log("info","Inspecting vm: #{vm.inspect}") if @debug


  cluster       = vm.ems_cluster
  $evm.log("info", "Got Cluster <#{cluster.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting cluster: #{cluster.inspect}") if @debug

  ems       = vm.ext_management_system
  $evm.log("info", "Got EMS <#{ems.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting ems: #{ems.inspect}") if @debug

  host      = vm.host
  $evm.log("info", "Got Host <#{host.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting host: #{host.inspect}") if @debug

  dest_host = host.ipaddress
  $evm.log("info", "Using Destination Host <#{dest_host}>")
  $evm.log("info","Inspecting dest_host: #{dest_host.inspect}") if @debug

  storages = vm.storage
  $evm.log("info", "Got Storages <#{storages.name}> from VM <#{vm.name}>")
  $evm.log("info","Inspecting storages: #{storages.inspect}") if @debug

  dest_storage = storages.name
  $evm.log("info", "Using Destination Storage <#{dest_storage}>")
  $evm.log("info","Inspecting dest_storage: #{dest_storage.inspect}") if @debug


  #Find the tagged host(s) with the least number of vms
  #tag       = "/managed/function/citrix"
  #hosts     = $evm.vmdb(:host).find_tagged_with(:all => tag, :ns => "*")
  #$evm.log("info", "Got #{hosts.length} Hosts tagged with #{tag}")
  #dest_host = hosts.sort{|a,b| a.vms.length <=> b.vms.length}.first
  #$evm.log("info", "Sorted Hosts")
  #dest_host = dest_host.name
  #$evm.log("info", "Selected Host = #{dest_host}")

  # Find tagged storage(s) with least number of VMs
  #storages     = $evm.vmdb(:storage).find_tagged_with(:all=>tag, :ns=>"*")
  #$evm.log("info", "Got #{storages.length} Storages tagged with #{tag}")
  #dest_storage = storages.sort{|a,b| a.vms.length <=> b.vms.length}.first
  #$evm.log("info", "Sorted Storages")
  #dest_storage = dest_storage.name
  #$evm.log("info", "Selected Storage = #{dest_storage}")

  vm_finder = $evm.vmdb(:vm)
  $evm.log("info", "Got VMFinder Object")

  # Name the VM, takes the vm name passed and adds 1 thru 99 till name does not exist in vmdb
  vm2 = nil
  99.times do |i|
    vm2 = vm.name + "_#{i+1}"
    $evm.log("info", "Trying #{vm2}")
    break unless vm_finder.find_by_name(vm2)
  end
  $evm.log("info", "Selected VM Name = #{vm2}")

  # Build the Perl command using the VMDB information
  cmd  = "nohup perl /usr/lib/vmware-vcli/apps/vm/vmtemplate.pl"
  cmd += " --url https://#{ems.ipaddress}:443/sdk/vimservice"
  cmd += " --username \"#{ems.authentication_userid}\""
  cmd += " --password \"#{ems.authentication_password}\""
  cmd += " --vmname \"#{vm.name}\""
  cmd += " --operation \"T\""
  cmd += " --pool \"Default for #{cluster.name}\""
  cmd += " --host \"#{dest_host}\""
  cmd += " &"
  $evm.log("info", "Running: #{cmd}")
  results = system(cmd)


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vmname_sample1" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vmname_sample1
#
# Names a VM with the following characteristics:
# XXDC-WOS-INP
# Where:
# XX = static 2 chars that will always be the prefix when naming a VM
# DC = 3 char from Tag Category Datacenter
# W = 1 char from Tag Category Function
# OS = 3 for Win2K3 8 for Win2K8 based on Template
# IN = 3 char user will be required to input from dialog where VM Naming was before. We have renamed and set limits on this dialog field accordingly.
#  $n(2) = 2 digit generated number 01, 02, 03, etc
#
###################################
begin
  @method = 'vmname_sample1'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

    # Turn of verbose logging
  @debug = true

  prov                            = $evm.root['miq_provision_request'] || $evm.root['miq_provision'] || $evm.root['miq_provision_request_template']
  vm_name                         = prov.get_option(:vm_name).to_s.strip
  number_of_vms_being_provisioned = prov.get_option(:number_of_vms)
  template                        = prov.vm_template
  virtual_center                  = template.ext_management_system


  #############################
  # Uncomment line below if tags are needed for VM Name
  tags = prov.get_tags
  $evm.log("info","Tags: #{tags.inspect}") if @debug
  #############################


  #
  # Method: dumpobj
  # Dump object and automation space root attributes
  #
  def dumpobj(obj=self)
    $evm.log("info", "dumpobj - Dumping <#{obj}> object")
    obj.instance_variables.each do |key|
      value = obj.instance_eval(key)
      $evm.log("info", "dumpobj-<#{obj}>---> #{key}: #{value.inspect}") if @debug
    end
    $evm.log("info", "dumpobj - Dumping <root> object") if @debug
    $evm.root.attributes.each { |key, value| $evm.log("info", "dumpobj-<root>---> #{key}: #{value.inspect}") } if @debug
  end


  #############################
  # Example: cb22f-m8-sql01
  #
  # XXDC-WOS-INP
  # XX = static 2 chars that will always be the prefix when naming a VM
  # DC = 3 char from Tag Category Datacenter
  # W = 1 char from Tag Category Function
  # OS = 3 for Win2K3 8 for Win2K8 based on Template
  # IN = 3 char user will be required to input from dialog where VM Naming was before. We have renamed and set limits on this dialog field accordingly.
  #  $n(2) = 2 digit generated number 01, 02, 03, etc
  #
  #############################

  # Prefix vmname with a static prefix
  prefix = 'cb'
  $evm.log("info","Prefix: <#{prefix}>")


  # Get datacenter tag
  dc = tags[:datacenter]
  $evm.log("info","Datacenter (dc) tag: <#{dc}>")

  # Get function/workload tag
  wl = tags[:function]
  $evm.log("info","Workload (wl) tag: <#{wl}>")


  # Get OS Type from the template platform
  product  = template.operating_system['product_name'] rescue ''
  $evm.log("info","Template product name: <#{product}>")

  if product.include?("2003")
    os = "3" # Win2k3
  elsif product.include?("2008")
    os = "8" # Win2k8
  elsif product.include?("Linux")
    os = "w" # unknown windows type
  end
  $evm.log("info","OS product type: <#{os}>")


  # Get 3 char user will be required to input from dialog
  appl = vm_name.downcase
  $evm.log("info","VM input name: <#{appl}>")


  # Octet separator
  sep = "-"
  # First (prefix + datacenter)
  oct1 = "#{prefix}#{dc}"
  # Second (workload + os)
  oct2 = "#{wl}#{os}"
  # third (application)
  oct3 = "#{appl}"

  # construct vmname
  derived_name = "#{oct1}#{sep}#{oct2}#{sep}#{oct3}"

  if number_of_vms_being_provisioned == 1
    derived_name = "#{derived_name}$n{2}"
  else
    derived_name = "#{derived_name}$n{2}"
  end

  # Set the evm object to the vmname
  $evm.object['vmname'] = derived_name

  $evm.log("info", "VM Naming Method Completed: vmname=#{derived_name}")


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vmname_sample2" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vmname_sample2
#
# Notes: This method names the VM using the following:
# #{location}#{os_type}#{domain}$n{4}
#
#
###################################
begin
  @method = 'vmname_sample2'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get variables
  #
  prov = $evm.root['miq_provision_request'] || $evm.root['miq_provision'] || $evm.root['miq_provision_request_template']
  vm_name = prov.get_option(:vm_name).to_s.strip
  number_of_vms_being_provisioned = prov.get_option(:number_of_vms)
  template                        = prov.vm_template
  virtual_center                  = template.ext_management_system


  # Uncomment line below if tags are needed for VM Name
  # tags                            = prov.get_tags

  # Set a prefix called location
  location = 'sd'

  # Set a domain value based on the VC name
  os_type  = template.platform[0,1]
  if virtual_center.name.downcase.include?('vlab')
    domain = 'v'
  else
    domain = 'l'
  end

  # Name VM with location, os type, and domain
  if vm_name.empty?
    derived_name = "#{location}#{os_type}#{domain}$n{4}"
  elsif number_of_vms_being_provisioned == 1
    derived_name = "#{vm_name}"
  else
    derived_name =  "#{vm_name}$n{3}"
  end

  $evm.object['vmname'] = derived_name
  $evm.log("info", "VM Naming Method Completed: vmname=#{derived_name}")


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="vmname_sample3" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vmname_sample3
#
# Notes: This method names the vm based on tag category chosen in dialog
#
###################################
begin
  @method = 'vmname_sample3'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true

  #
  # Get variables
  #
  prov = $evm.root['miq_provision_request'] || $evm.root['miq_provision'] || $evm.root['miq_provision_request_template']
  vm_name = prov.get_option(:vm_name).to_s.strip
  number_of_vms_being_provisioned = prov.get_option(:number_of_vms)


  #
  # Get tags needed for VM Name
  #
  tags = prov.get_tags
  $evm.log("info","Tags: #{tags.inspect}") if @debug


  #
  # Construct vmname
  #

  # Prefix vmname with a static prefix of tag category
  prefix = tags[:environment]
  $evm.log("info","Environment Prefix: <#{prefix}>")

  # Get vm_name from dialog entry
  input_name = vm_name.downcase.strip
  $evm.log("info","VM input name: <#{input_name}>")

  derived_name = "#{prefix}#{input_name}"

  # Set the evm object to the vmname
  $evm.object['vmname'] = derived_name
  $evm.log("info", "VM Naming Method Completed: vmname=#{derived_name}")


  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="workload_manager" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: workload_manager
#
# Notes:
#
#
###################################
begin
  @method = 'workload_manager'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn of verbose logging
  @debug = true


  def emailresults(vm_culprit, host_culprit, host_culprit_type, host_culprit_percent, target_host)
    to = "evmadmin@manageiq.com"
    from = "evmadmin@manageiq.com"
    subject = "Cluster Workload Manager Services"
    signature = "Enterprise Virtualization Team"

    body  = "Hello, "
    body += "<br>"
    body += "EVM has detected high "
    if host_culprit_type == :mem
      body += "memory utilization"
    else
      body += "CPU utilization"
    end
    body += " of (#{host_culprit_percent}%) on host #{host_culprit}."
    body += "<br>"
    body += "<br>"

    body += "Moving VM <b>#{vm_culprit}</b> to target host #{target_host}"
    body += "<br><br>"
    body += "Thank You,"
    body += "<br><br>"
    body += "#{signature}"
    body += "<br>"

    #
    # Send email
    #
    $evm.log("info", "Sending email to <#{to}> from <#{from}> subject: <#{subject}>")
    $evm.execute('send_email', to, from, subject, body)

  end

  def loghost_object(h)
    # Log Host CPU average usage I.e. Host CPU Usage: <1751.69884833285>
    $evm.log("info","Host: <#{h.name}> Average CPU Usage: <#{h.cpu_usagemhz_rate_average_avg_over_time_period}>")

    # Log Host Memory average usage I.e. Host Memory Usage: <9341.15865541251>
    $evm.log("info","Host: <#{h.name}> Average Memory Usage: <#{h.derived_memory_used_avg_over_time_period}>")

    # Log Host CPU Speed I.e. cpu_speed: 2493
    $evm.log("info","Host: <#{h.name}> CPU Speed: <#{h.hardware.cpu_speed}>")

    # Log Host Memory  I.e. memory_cpu: 8190
    $evm.log("info","Host: <#{h.name}> Memory: <#{h.hardware.memory_cpu}>")

    # Log Current Host CPU usage I.e. cpu_usage: 366
    $evm.log("info","Host: <#{h.name}> Current CPU Usage: <#{h.hardware.cpu_usage}>")

    # Log Current Host Memory usage I.e. memory_usage: 4690
    $evm.log("info","Host: <#{h.name}> Memory Usage: <#{h.hardware.memory_usage}>")
  end

  #
  # Initialize variables
  #

  # Set host thresholds
  host_cpu_threshold = 0.6
  host_mem_threshold = 0.6


  # Get Cluster
  ems_cluster = $evm.root['ems_cluster']
  #$evm.log("info","Inspecting ems_cluster: <#{ems_cluster.inspect}>")   if @debug
  raise "EMS Cluster not found" if ems_cluster.nil?

  # Log Cluster CPU usage I.e. Cluster CPU Usage: <3381.90824648164>
  $evm.log("info","Cluster: <#{ems_cluster.name}> CPU Usage: <#{ems_cluster.cpu_usagemhz_rate_average_avg_over_time_period}>")
  # Log Cluster Memory usage I.e. Cluster Memory Usage: <21410.959239421>
  $evm.log("info","Cluster: <#{ems_cluster.name}> Memory Usage: <#{ems_cluster.derived_memory_used_avg_over_time_period}>")

  # Get hosts attached to the cluster
  hosts = ems_cluster.hosts
  raise "No Hosts found on Cluster:<#{ems_cluster.name}> not found" if hosts.nil?

  # Loop through all hosts
  host_suspects = hosts.find_all { |h| h.power_state == 'on' && h.name != 'kmdemo.manageiq.com'}

  host_exceeded = []
  host_all = []

  host_suspects.each do |h|
    loghost_object(h) if @debug

    # Get Host CPU Capacity
    host_cpu_capacity = h.hardware.cpu_speed * h.hardware.logical_cpus
    host_cpu_percent = (h.cpu_usagemhz_rate_average_avg_over_time_period / host_cpu_capacity)
    $evm.log("info","Host:<#{h.name}> CPU Capacity: <#{host_cpu_capacity}> CPU Percent: <#{host_cpu_percent}>")

    host_all << {:id => h.id, :percent => host_cpu_percent, :type => :cpu}
    if host_cpu_percent >= host_cpu_threshold
      $evm.log("info","Host: <#{h.name}> CPU Percent: <#{host_cpu_percent}> has exceeded CPU threshold: <#{host_cpu_threshold}>")
      host_exceeded << {:id => h.id, :percent => host_cpu_percent, :type => :cpu}
    else
      $evm.log("info","Host: <#{h.name}> CPU Percent: <#{host_cpu_percent}> is within CPU threshold: <#{host_cpu_threshold}>")
    end

    host_mem_percent = (h.derived_memory_used_avg_over_time_period / h.hardware.memory_cpu)
    $evm.log("info","Host:<#{h.name}> Memory Capacity: <#{h.hardware.memory_cpu}> CPU Percent: <#{host_mem_percent}>")

    host_all << {:id => h.id, :percent => host_mem_percent, :type => :mem}
    if host_mem_percent >= host_mem_threshold
      $evm.log("info","Host: <#{h.name}> Memory percent: <#{host_mem_percent}> has exceeded Memory threshold: <#{host_mem_threshold}>")
      host_exceeded << {:id => h.id, :percent => host_mem_percent, :type => :mem}
    else
      $evm.log("info","Host: <#{h.name}> Memory percent: <#{host_mem_percent}> is within Memory threshold: <#{host_mem_threshold}>")
    end
  end

  unless host_exceeded.blank?
    host_all.sort! {|a,b| a[:percent] <=> b[:percent]}
    host_exceeded.sort! {|a,b| a[:percent] <=> b[:percent]}
    host_culprit_stats = host_exceeded.pop
    host_culprit = host_suspects.detect {|h| h.id == host_culprit_stats[:id]}

    # Only include VM's that are powered on
    vm_suspects = host_culprit.vms.find_all { |v| v.power_state == 'on'}

    if host_culprit_stats[:type] == :mem
      vm_suspects.sort! {|a,b| a.derived_memory_used_avg_over_time_period <=> b.derived_memory_used_avg_over_time_period}
    else
      vm_suspects.sort! {|a,b| a.cpu_usagemhz_rate_average_avg_over_time_period <=> b.cpu_usagemhz_rate_average_avg_over_time_period}
    end

    vm_culprit = vm_suspects.pop
    target_host_stats = host_all.detect {|h| h[:type] == host_culprit_stats[:type]}
    target_host = host_suspects.detect {|h| h.id == target_host_stats[:id]}

    # Log VM Memory  I.e. mem_cpu: <4096>
    $evm.log("info","VM: <#{vm_culprit.name}> Memory: <#{vm_culprit.mem_cpu}>")
        
    # Log VM CPU Count I.e. CPU Count: <2>
    $evm.log("info","VM: <#{vm_culprit.name}> CPU Count: <#{vm_culprit.num_cpu}>")

    # Log VM CPU average usage I.e. Average CPU Usage: <405.791768303411>
    $evm.log("info","VM: <#{vm_culprit.name}> Average CPU Usage: <#{vm_culprit.cpu_usagemhz_rate_average_avg_over_time_period}>")
        
    # Log VM Memory average usage I.e. Average Memory Usage: <863.462927057142>
    $evm.log("info","VM: <#{vm_culprit.name}> Average Memory Usage: <#{vm_culprit.derived_memory_used_avg_over_time_period}>")

    # Email the results
    host_culprit_percent = (host_culprit_stats[:percent] * 100).to_i
    emailresults(vm_culprit.name.downcase, host_culprit.name, host_culprit_stats[:type], host_culprit_percent, target_host.name)
    
    # Log the culprit VM
    $evm.log("info","Migrating VM: <#{vm_culprit.name}> from Source Host: <#{host_culprit.name}> to Target Host: <#{target_host.name}>")

    # VMotion culprit VM to Target_host
    vm_culprit.migrate(target_host)
  end



  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="method1" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="InspectME">
      <MiqAeField name="method1">
InspectMe      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="servicename_sample" display_name="servicename_sample">
      <MiqAeField name="method1">
servicename_sample      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Service_Now_Methods" namespace="Sample">
    <MiqAeMethod name="Create_CI" language="ruby" scope="instance" location="inline"><![CDATA[#
# EVM Automate Method: Create CMDB CI in Service-now
#
# Notes: This method is used to Create a CMDB in Service-now
#
###################################
begin
  @method = 'Service_now Create/Update CI'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn off verbose logging
  @debug = true

  ##################################################################
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  # No VM Found, exit
  raise "VM not found" if vm.nil?
  ##################################################################

  # Get variables from Server object
  server = $evm.root['miq_server']
  evm_ipaddr    = server.ipaddress
  evm_hostname  = server.hostname
  evm_region    = server.region_number

  vm = $evm.root['vm']
  $evm.log("info", "Got VM from root object")
  $evm.log("info","Inspecting vm: #{vm.inspect}") if @debug
  vm_ipaddr = vm.ipaddresses.first
  vm_name = vm.name
  vm_id = vm['id']

  ems       = vm.ext_management_system
  $evm.log("info", "Got EMS <#{ems.name}> from VM <#{vm_name}>")
  $evm.log("info","Inspecting ems: #{ems.inspect}") if @debug
  ems_name = ems.hostname
  ems_ip = ems.ipaddress


  user = $evm.root['user']
  $evm.log("info","Inspecting User object: <#{user.inspect}>")
  username = user.name
  userid = user.userid

  
  host      = vm.host
  #$evm.log("info","Inspecting host: #{host.inspect}") if @debug
  $evm.log("info", "Got Host <#{host.name}> from VM <#{vm_name}>")
  host_name = host.name
  host_id = host['id']


process  = $evm.object("process")
hardware = vm.hardware
$evm.log("info","Inspecting hardware: #{hardware.inspect}") if @debug
owner               = vm.owner

os = vm.operating_system
$evm.log("info","Inspecting os: #{os.inspect}") if @debug



config_version      = hardware.config_version      #  varchar 255
virtual_hw_version  = hardware.virtual_hw_version  #  varchar 255
guest_os            = hardware.guest_os            #  varchar 255
numvcpus            = hardware.numvcpus            #  int4
bios                = hardware.bios                #  varchar 255
bios_location       = hardware.bios_location       #  varchar 255
time_sync           = hardware.time_sync           #  varchar 255
annotation          = hardware.annotation          #  text
vm_id               = hardware.vm_id               #  int8
memory_cpu          = hardware.memory_cpu          #  int4
host_id             = hardware.host_id             #  int8
cpu_speed           = hardware.cpu_speed           #  int4
cpu_type            = hardware.cpu_type            #  varchar 255
size_on_disk        = hardware.size_on_disk        #  int8
manufacturer        = hardware.manufacturer        #  varchar 255
model               = hardware.model               #  varchar 255
number_of_nics      = hardware.number_of_nics      #  int4
cpu_usage           = hardware.cpu_usage           #  int4
memory_usage        = hardware.memory_usage        #  int4
cores_per_socket    = hardware.cores_per_socket    #  int4
logical_cpus        = hardware.logical_cpus        #  int4
vmotion_enabled     = hardware.vmotion_enabled     #  int4
disk_free_space     = hardware.disk_free_space     #  int8
disk_capacity       = hardware.disk_capacity       #  int8
guest_os_full_name  = hardware.guest_os_full_name  #  varchar 255
memory_console      = hardware.memory_console      #  int4
product_name        = os.product_name
service_pack        = os.service_pack
os_width            = os.bitness
os_version          = os.version
os_type             = os.system_type
host_ipaddress      = host.ipaddress
#host_macaddress     = host.macaddress
host_name           = host.name
ems_name            = ems.name
ems_ipaddress       = ems.ipaddress
#ems_macaddress      = ems.macaddress







  ###################################
  #
  # Call Service-Now
  #
  ###################################



  agent      = "EVM Automate CMDB Server"
  topic      = "Create/Update CI for VM"
  name       = "VM:#{vm_name} | Host:#{host_name} | IP:#{vm_ipaddr}"
  source     = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

  $evm.log("info","Server IP: #{evm_ipaddr}")

  $evm.log("info","VM IP: #{vm_ipaddr}")

  comments   = "EVM Creating/Updating CI for VM: #{vm_name} Host:#{host_name} Host IP:#{evm_ipaddr}"
  vmurl      = "https://#{evm_ipaddr}/vm/show/#{vm_id}"
  hosturl    = "https://#{evm_ipaddr}/host/show/#{host_id}"
  description = "EVM Creating/Updating CI for VM: #{vm_name} Host:#{host_name} Host IP:#{evm_ipaddr}"

  require 'uri'
  args =  "agent=#{agent}&"
  args += "topic=#{topic}&"
  args += "source=#{source}&"
  args += "name=#{name}&"
  args += "comments=#{comments}&"
  args += "vmurl=#{vmurl}&"
  args += "hosturl=#{hosturl}&"
  args += "evm_vmname=#{vm_name}&"
  args += "hostname=#{host_name}&"
  args += "emsname=#{ems_name}&"
  args += "emsip=#{ems_ip}&"
  args += "username=#{username}&"
  args += "userid=#{userid}&"
  args += "config_version=#{config_version}&"
  args += "virtual_hw_version=#{virtual_hw_version}&"
  args += "guest_os=#{guest_os}&"
  args += "numvcpus=#{numvcpus}&"
  args += "bios=#{bios}&"
  args += "bios_location=#{bios_location}&"
  args += "time_sync=#{time_sync}&"
  args += "annotation=#{annotation}&"
  args += "vm_id=#{vm_id}&"
  args += "memory_cpu=#{memory_cpu}&"
  args += "host_id=#{host_id}&"
  args += "cpu_speed=#{cpu_speed}&"
  args += "cpu_type=#{cpu_type}&"
  args += "size_on_disk=#{size_on_disk}&"
  args += "manufacturer=#{manufacturer}&"
  args += "model=#{model}&"
  args += "number_of_nics=#{number_of_nics}&"
  args += "cpu_usage=#{cpu_usage}&"
  args += "memory_usage=#{memory_usage}&"
  args += "cores_per_socket=#{cores_per_socket}&"
  args += "logical_cpus=#{logical_cpus}&"
  args += "vmotion_enabled=#{vmotion_enabled}&"
  args += "disk_free_space=#{disk_free_space}&"
  args += "disk_capacity=#{disk_capacity}&"
  args += "guest_os_full_name=#{guest_os_full_name}&"
  args += "memory_console=#{memory_console}&"
  args += "product_name=#{product_name}&"
  args += "service_pack=#{service_pack}&"
  args += "os_width=#{os_width}&"
  args += "os_type=#{os_type}&"
  args += "ems_name=#{ems_name}&"
  args += "ems_ipaddress=#{ems_ipaddress}&"
  args += "host_ipaddress=#{host_ipaddress}&"
  args += "host_name=#{host_name}&"
  args += "vm_ipaddr=#{vm_ipaddr}&"
  args += "os_version=#{os_version}"

  args = URI.escape(args)

  $evm.log("info","Calling Service-Now with arguments: #{args}")
  $evm.instantiate("/Factory/ServiceNow/create_ci_in_eccq?#{args}")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Create_CI_For_Host" language="ruby" scope="instance" location="inline"><![CDATA[#
# EVM Automate Method: Create CMDB CI in Service-now
#
# Notes: This method is used to Create a CMDB in Service-now
#
###################################
begin
  @method = 'Service_now Create/Update CI'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn off verbose logging
  @debug = true

  ##################################################################
  # Look in the current object for a VM
  #
  host= $evm.object['host']
  if host.nil?
    host_id = $evm.object['host__id'].to_i
    host= $evm.vmdb('host', host_id) unless host_id == 0
  end

  #
  # Look in the Root Object for a host  #
  if host.nil?
    host= $evm.root['host']
    if host.nil?
      host_id = $evm.object['host__id'].to_i
      host= $evm.vmdb('host', host_id) unless host_id == 0
    end
   end

  # No Host Found, exit
  raise "hostnot found" if host.nil?
  ##################################################################

  # Get variables from Server object
  server = $evm.root['miq_server']
  evm_ipaddr    = server.ipaddress
  evm_hostname  = server.hostname
  evm_region    = server.region_number

  #vm = $evm.root['vm']
  #$evm.log("info", "Got VM from root object")
  #$evm.log("info","Inspecting vm: #{vm.inspect}") if @debug
  #vm_ipaddr = vm.ipaddresses.first
  #vm_name = vm.name
  #vm_id = vm['id']

  ems       = host.ext_management_system
  $evm.log("info", "Got EMS <#{ems.name}> from host<#{host.name}>")
  $evm.log("info","Inspecting ems: #{ems.inspect}") if @debug
  ems_name = ems.hostname
  ems_ip = ems.ipaddress


  user = $evm.root['user']
  $evm.log("info","Inspecting User object: <#{user.inspect}>")
  username = user.name
  userid = user.userid

  
  #host      = vm.host
  #$evm.log("info","Inspecting host: #{host.inspect}") if @debug
  #$evm.log("info", "Got Host <#{host.name}> from VM <#{vm_name}>")
  host_name = host.name
  host_id = host['id']


process  = $evm.object("process")
hardware = host.hardware
$evm.log("info","Inspecting hardware: #{hardware.inspect}") if @debug
#owner               = vm.owner

os = host.operating_system
$evm.log("info","Inspecting os: #{os.inspect}") if @debug



config_version      = hardware.config_version      #  varchar 255
virtual_hw_version  = hardware.virtual_hw_version  #  varchar 255
guest_os            = hardware.guest_os            #  varchar 255
numvcpus            = hardware.numvcpus            #  int4
bios                = hardware.bios                #  varchar 255
bios_location       = hardware.bios_location       #  varchar 255
time_sync           = hardware.time_sync           #  varchar 255
annotation          = hardware.annotation          #  text
vm_id               = hardware.vm_id               #  int8
memory_cpu          = hardware.memory_cpu          #  int4
host_id             = hardware.host_id             #  int8
cpu_speed           = hardware.cpu_speed           #  int4
cpu_type            = hardware.cpu_type            #  varchar 255
size_on_disk        = hardware.size_on_disk        #  int8
manufacturer        = hardware.manufacturer        #  varchar 255
model               = hardware.model               #  varchar 255
number_of_nics      = hardware.number_of_nics      #  int4
cpu_usage           = hardware.cpu_usage           #  int4
memory_usage        = hardware.memory_usage        #  int4
cores_per_socket    = hardware.cores_per_socket    #  int4
logical_cpus        = hardware.logical_cpus        #  int4
vmotion_enabled     = hardware.vmotion_enabled     #  int4
disk_free_space     = hardware.disk_free_space     #  int8
disk_capacity       = hardware.disk_capacity       #  int8
guest_os_full_name  = hardware.guest_os_full_name  #  varchar 255
memory_console      = hardware.memory_console      #  int4
product_name        = os.product_name
service_pack        = os.service_pack
os_width            = os.bitness
os_version          = os.version
os_type             = os.system_type

  host_ipaddr = host.ipaddress
  vmurl      = "no vm"
  vm_name    =  host_name
  vm_ipaddr  = "no vm"

  ###################################
  #
  # Call Service-Now
  #
  ###################################


 
  agent      = "EVM Automate CMDB Server"
  topic      = "Create/Update CI for Host"
  name       = "Host:#{host_name} | IP:#{host_ipaddr}"
  source     = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

  $evm.log("info","Server IP: #{evm_ipaddr}")

  $evm.log("info","VM IP: #{vm_ipaddr}")

  comments   = "EVM Creating/Updating CI for VM: #{vm_name} Host:#{host_name} Host IP:#{evm_ipaddr}"

  hosturl    = "https://#{evm_ipaddr}/host/show/#{host_id}"
  description = "EVM Creating/Updating CI for Host:#{host_name} Host IP:#{evm_ipaddr}"

  require 'uri'
  args =  "agent=#{agent}&"
  args += "topic=#{topic}&"
  args += "source=#{source}&"
  args += "name=#{name}&"
  args += "comments=#{comments}&"
  args += "vmurl=#{vmurl}&"
  args += "hosturl=#{hosturl}&"
  args += "evm_vmname=#{vm_name}&"
  args += "hostname=#{host_name}&"
  args += "emsname=#{ems_name}&"
  args += "emsip=#{ems_ip}&"
  args += "username=#{username}&"
  args += "userid=#{userid}&"
  args += "config_version=#{config_version}&"
  args += "virtual_hw_version=#{virtual_hw_version}&"
  args += "guest_os=#{guest_os}&"
  args += "numvcpus=#{numvcpus}&"
  args += "bios=#{bios}&"
  args += "bios_location=#{bios_location}&"
  args += "time_sync=#{time_sync}&"
  args += "annotation=#{annotation}&"
  args += "vm_id=#{vm_id}&"
  args += "memory_cpu=#{memory_cpu}&"
  args += "host_id=#{host_id}&"
  args += "cpu_speed=#{cpu_speed}&"
  args += "cpu_type=#{cpu_type}&"
  args += "size_on_disk=#{size_on_disk}&"
  args += "manufacturer=#{manufacturer}&"
  args += "model=#{model}&"
  args += "number_of_nics=#{number_of_nics}&"
  args += "cpu_usage=#{cpu_usage}&"
  args += "memory_usage=#{memory_usage}&"
  args += "cores_per_socket=#{cores_per_socket}&"
  args += "logical_cpus=#{logical_cpus}&"
  args += "vmotion_enabled=#{vmotion_enabled}&"
  args += "disk_free_space=#{disk_free_space}&"
  args += "disk_capacity=#{disk_capacity}&"
  args += "guest_os_full_name=#{guest_os_full_name}&"
  args += "memory_console=#{memory_console}&"
  args += "product_name=#{product_name}&"
  args += "service_pack=#{service_pack}&"
  args += "os_width=#{os_width}&"
  args += "os_type=#{os_type}&"
  args += "os_version=#{os_version}"

  args = URI.escape(args)

  $evm.log("info","Calling Service-Now with arguments: #{args}")
  $evm.instantiate("/Factory/ServiceNow/create_ci_in_eccq?#{args}")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK
end
  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
endt MIQ_OK]]>    </MiqAeMethod>
    <MiqAeMethod name="Create_Incident" language="ruby" scope="instance" location="inline"><![CDATA[#
# EVM Automate Method: Create Incident in Service-now
#
# Notes: This method is used to Create an Incident in Service-now
#
###################################
begin
  @method = 'Service_now Create Incident'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn off verbose logging
  @debug = true

  ##################################################################
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  # No VM Found, exit
  raise "VM not found" if vm.nil?
  ##################################################################

  # Get variables from Server object
  server = $evm.root['miq_server']
  evm_ipaddr    = server.ipaddress
  evm_hostname  = server.hostname
  evm_region    = server.region_number

  vm = $evm.root['vm']
  $evm.log("info", "Got VM from root object")
  $evm.log("info","Inspecting vm: #{vm.inspect}") if @debug
  vm_ipaddr = vm.ipaddresses.first
  vm_name = vm.name
  vm_id = vm['id']

  ems       = vm.ext_management_system
  $evm.log("info", "Got EMS <#{ems.name}> from VM <#{vm_name}>")
  $evm.log("info","Inspecting ems: #{ems.inspect}") if @debug
  ems_name = ems.hostname
  ems_ip = ems.ipaddress


  user = $evm.root['user']
  $evm.log("info","Inspecting User object: <#{user.inspect}>")
  username = user.name
  userid = user.userid

  
  host      = vm.host
  #$evm.log("info","Inspecting host: #{host.inspect}") if @debug
  $evm.log("info", "Got Host <#{host.name}> from VM <#{vm_name}>")
  host_name = host.name
  host_id = host['id']


  process                = $evm.object("process")
  evm_policy_id          = process.attributes["policy_id"].to_i
  evm_policy_name        = process.attributes["policy_name"] || 'create_incident'
  evm_policy_description = process.attributes["policy_description"] || "User: #{username} requested incident for this object"
  $evm.log("info", "Policy ID:          #{evm_policy_id}")
  $evm.log("info", "Policy Name:        #{evm_policy_name}")
  $evm.log("info", "Policy Description: #{evm_policy_description}")
  #policy    = $evm.vmdb('policy', policy_id)


  ###################################
  #
  # Call Service-Now
  #
  ###################################

  priority = 'low'
  severity = 3

  agent      = "EVM Automate Create Incident"
  topic      = "Violation in VM Policy:#{evm_policy_name}"
  name       = "VM:#{vm_name} | Host:#{host_name} | IP:#{vm_ipaddr}"
  source     = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

  $evm.log("info","Server IP: #{evm_ipaddr}")

  $evm.log("info","VM IP: #{vm_ipaddr}")

  short_desc = evm_policy_description
  comments   = "EVM detected a policy violation for VM: #{vm_name} Policy: #{evm_policy_description} Host:#{host_name} Host IP:#{evm_ipaddr}"
  vmurl      = "https://#{evm_ipaddr}/vm/show/#{vm_id}"
  hosturl    = "https://#{evm_ipaddr}/host/show/#{host_id}"
  description = "EVM detected a policy violation for VM: #{vm_name} \nPolicy: #{evm_policy_description} \nHost:#{host_name} \nHost IP:#{evm_ipaddr}"

  require 'uri'
  args = "agent=#{agent}&topic=#{topic}&source=#{source}&name=#{name}&comments=#{comments}&evm_policy_description=#{short_desc}&vmurl=#{vmurl}&hosturl=#{hosturl}&evm_vmname=#{vm_name}&evm_policy_id=#{evm_policy_id}&evm_policy_name=#{evm_policy_name}&hostname=#{host_name}&priority=#{priority}&severity=#{severity}&emsname=#{ems_name}&emsip=#{ems_ip}&username=#{username}&userid=#{userid}"
  args = URI.escape(args)

  $evm.log("info","Calling Service-Now with arguments: #{args}")
  $evm.instantiate("/Factory/ServiceNow/create_incident_in_eccq?#{args}")

  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ServiceNow_CI_SOAP_Insert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ServiceNow_CI_SOAP_Insert
#
# Notes: This method uses a SOAP/XML call to update a CI in Service-Now
#
###################################
# Method for logging
def log(level, message)
  @method = 'ServiceNow_CI_SOAP_Insert'
  $evm.log(level, "#{@method} - #{message}")
end

begin
  log(:info, "EVM Automate Method Started")
  
  
  ###########################
  #
  # Method: insertCI
  # Inputs: 
  #
  ###########################
  def insertCI()
    # Require Savon Ruby Gem
    require "rubygems"
    require "savon"

    username = nil
    username ||= $evm.object['username']

    password = nil
    password ||= $evm.object.decrypt('password')

    wsdl_uri = nil
    wsdl_uri ||= $evm.object['wsdl_uri']
    
    
    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl,http|
      wsdl.document = wsdl_uri
      http.auth.basic username, password
    end

    log(:info,"Namespace: #{client.wsdl.namespace.inspect}")
    log(:info,"Endpoint: #{client.wsdl.endpoint.inspect}")
    
    # Incident Actions: [:insert, :update, :delete_multiple, :get_keys, :delete_record, :get, :get_records]
    log(:info,"Actions: #{client.wsdl.soap_actions.inspect}")

    # Call Remedy
    response = client.request :insert do |soap|
      # Build the body of the XML elements, Below are some samples
      
      
      soap.body = {
        # Note: DO NOT USE SYMBOLS - USE STRINGS
        'name' => 'vm12345',
        'short_description' => 'vm12345desc'
      }
    end
    
    # Convert xml response to a hash
    # Inspecting Service-Now Response:<{:sys_id=>"455719bbff976c80a19538abb67efe21", :name=>"kevinpc4"}>
        
    hash_response = response.to_hash[:insert_response]
    log(:info,"Inspecting Service-Now Response:<#{hash_response.inspect}>")

    log(:info,"Service-Now CI SOAP Insert sys_id=<#{hash_response[:sys_id]}>")
    log(:info,"Service-Now CI SOAP Insert name=<#{hash_response[:name]}>")
    return hash_response
  end
  
  servicecnowResponse = insertCI()
    
  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ServiceNow_CI_SOAP_Update" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ServiceNow_CI_SOAP_Update
#
# Notes: This method uses a SOAP/XML call to update a CI in Service-Now
#
###################################
# Method for logging
def log(level, message)
  @method = 'ServiceNow_CI_SOAP_Update'
  $evm.log(level, "#{@method} - #{message}")
end

begin
  log(:info, "EVM Automate Method Started")
  
  
  ###########################
  #
  # Method: updateCI
  # Inputs: 
  #
  ###########################
  def updateCI()
    # Require Savon Ruby Gem
    require "rubygems"
    require "savon"

    username = nil
    username ||= $evm.object['username']

    password = nil
    password ||= $evm.object.decrypt('password')

    wsdl_uri = nil
    wsdl_uri ||= $evm.object['wsdl_uri']
    
    
    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl,http|
      wsdl.document = wsdl_uri
      http.auth.basic username, password
    end

    log(:info,"Namespace: #{client.wsdl.namespace.inspect}")
    log(:info,"Endpoint: #{client.wsdl.endpoint.inspect}")
    
    # Incident Actions: [:insert, :update, :delete_multiple, :get_keys, :delete_record, :get, :get_records]
    log(:info,"Actions: #{client.wsdl.soap_actions.inspect}")

    # Call Remedy
    response = client.request :update do |soap|
      # Build the body of the XML elements, Below are some samples
      
      
      soap.body = {
        # Note: DO NOT USE SYMBOLS - USE STRINGS
        'sys_id' => 'f657d17fff976c80a19538abb67efe90',
        'name' => 'vm12345',
        'short_description' => 'vm12345desc'
      }
    end
    
    # Convert xml response to a hash
    # Inspecting Service-Now Response:<{:sys_id=>"f657d17fff976c80a19538abb67efe90"}>
        
    hash_response = response.to_hash[:update_response]
    log(:info,"Inspecting Service-Now Response:<#{hash_response.inspect}>")

    log(:info,"Service-Now CI SOAP Update sys_id=<#{hash_response[:sys_id]}>")
    return hash_response
  end
  
  servicecnowResponse = updateCI()
    
  #
  # Exit method
  #
  log(:info, "EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  log(:error, "[#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ServiceNow_CMDB_CI_Host" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ServiceNow_CMDB_CI_Host
#
# Notes: This method calls Service-Now via SOAP/XML to insert/update
# the manageiq_template table in Service-Now
#
###################################
begin
  @method = 'ServiceNow_CMDB_CI_Host'
  @log_prefix = "[#{@method}]"
  $evm.log("info", "#{@log_prefix} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true


  ###########################
  #
  # Method: callServiceNow
  #
  # inputs: username, password, wsdl_uri, soap_action, body_hash
  #
  ###########################
  def callServiceNow(username, password, wsdl_uri, soap_action, body_hash)
    # Require Savon Ruby Gem
    require "savon"
    require 'httpi'

    HTTPI.log_level = :info # changing the log level
    HTTPI.log       = false # diable HTTPI logging
    HTTPI.adapter   = :net_http # [:httpclient, :curb, :net_http]

    # Setup Savon Configuration
    Savon.configure do |config|
      config.log        = false      # disable Savon logging
      config.log_level  = :fatal      # changing the log level
    end

    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl,http,wsse|
      wsdl.document = wsdl_uri
      http.auth.ssl.verify_mode = :none
      http.auth.basic username, password
    end

    $evm.log("info","#{@log_prefix} - Namespace: #{client.wsdl.namespace.inspect}") if @debug
    $evm.log("info","#{@log_prefix} - Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    $evm.log("info","#{@log_prefix} - Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # Call Service-Now
    # Service-Now SOAP Actions: [:insert, :update, :delete_multiple, :get_keys, :delete_record, :get, :get_records]
    response = client.request soap_action do |soap|
      # Build the body of the XML elements
      soap.body = body_hash
    end

    # Convert xml response to a hash
    hash_response = response.to_hash["#{soap_action}_response".to_sym]
    $evm.log("info","#{@log_prefix} - Inspecting Service-Now #{soap_action} Response:<#{hash_response.inspect}>")
    return hash_response
  end


  vm = $evm.root['host']
  raise "#{@log_prefix} - Host object not found" if vm.nil?
  $evm.log("info","#{@log_prefix} - Detected Host:<#{host.name}>")

  # Get username from model else set below
  username = nil
  username ||= $evm.object['username']

  # Get password from model else set below
  password = nil
  password ||= $evm.object.decrypt('password')

  # Get wsdl_uri from model else set below
  wsdl_uri = nil
  wsdl_uri ||= $evm.object['wsdl_uri']

  get_records_hash = {'u_manageiq_template' => host.name}
  $evm.log("info","#{@log_prefix} - Searching Service-Now with parameters:<#{get_records_hash.inspect}>")
  record_hash = callServiceNow(username, password, wsdl_uri, :get_records, get_records_hash)

  # If a record is found then update the record
  unless record_hash.nil?

    # Strip out the service-now variables that we cannot modify except for :sys_id
    update_hash = record_hash[:get_records_result].dup.delete_if {|k,v| k.to_s[0,2] != 'u_' && k != :sys_id}

    # Convert symbols to strings as Service-Now does not work well with hash symbols
    update_hash = Hash[update_hash.map{ |k, v| [k.to_s, v] }]

    # Update guids for template and EMS
    update_hash['u_ems_guid'] = host.ext_management_system.guid
    update_hash['u_template_guid'] = host.guid
    $evm.log("info","#{@log_prefix} - Updating Service-Now cmdb_ci_esx_server record for ESX Host:<#{host.name}> with <#{update_hash.inspect}>")
    updateCI = callServiceNow(username, password, wsdl_uri, :update, update_hash)
  else
    # If a record is NOT found then insert a new record
    insert_hash = {}
    $evm.log("info","#{@log_prefix} - No Service-Now ESX Host found for Host:<#{host.name}>")

    # Build hash of fields to be inserted here
    insert_hash['discovery_source'] = "ManageIQ EVM"
    insert_hash['name'] = host.name
    insert_hash['url'] = "https://#{host.ipaddress}" unless host.ipaddress.nil?
    insert_hash['asset_tag'] = host.hardware.service_tag unless host.hardware.service_tag.nil?
    insert_hash['ip_address'] = host.ipaddress unless host.ipaddress
    insert_hash['manufacturer'] = host.hardware.manufacturer unless host.hardware.manufacturer.nil?
    insert_hash['model_number'] = host.hardware.model unless host.hardware.model.nil?
    insert_hash['os'] = host.vmm_product unless host.vmm_product.nil?
    insert_hash['os_service_pack'] = host.operating_system.service_pack unless host.operating_system.service_pack.nil?
    insert_hash['os_version'] = host.vmm_version unless host.vmm_version
    insert_hash['cpu_speed'] = host.hardware.cpu_speed unless host.hardware.cpu_speed.nil?
    insert_hash['ram'] = host.hardware.memory_cpu
    insert_hash['cpu_count'] = host.hardware.numvcpus
    insert_hash['cpu_type'] = host.hardware.cpu_type
    insert_hash['vendor'] = host.vmm_vendor

    #                  <category></category>
    #                  <comments></comments>
    #                  <company></company>
    #                  <correlation_id></correlation_id>
    #                  <cpu_core_count></cpu_core_count>
    #                  <></cpu_count>
    #                  <></cpu_manufacturer>
    #                  <dns_domain></dns_domain>
    #                  <dr_backup></dr_backup>
    #                  <fault_count></fault_count>
    #                  <firewall_status></firewall_status>
    #                  <first_discovered></first_discovered>
    #                  <floppy></floppy>
    #                  <form_factor></form_factor>
    #                  <gl_account></gl_account>
    #                  <hardware_status></hardware_status>
    #                  <hardware_substatus></hardware_substatus>
    #                  <host_domain></host_domain>
    #                  <host_name></host_name>
    #                  <install_date></install_date>
    #                  <install_status></install_status>
    #                  <invoice_number></invoice_number>
    #                  <justification></justification>
    #                  <last_discovered></last_discovered>
    #                  <lease_id></lease_id>
    #                  <location></location>
    # insert_hash['mac_address'] =
    #                  <managed_by></managed_by>
    #                  <operational_status></operational_status>
    #                  <order_date></order_date>
    #                  <os_address_width></os_address_width>
    #                  <os_domain></os_domain>
    #                  <owned_by></owned_by>

    #                  <po_number></po_number>
    #<purchase_date>
    #<repair_contract_id></repair_contract_id>
    #<returned_from_repair></returned_from_repair>
    #<sent_for_repair></sent_for_repair>
    #<serial_number>
    #<short_description></short_description>
    #<start_date></start_date>
    #<subcategory></subcategory>
    #<support_group></support_group>
    #<supported_by></supported_by>
    #<url></url>
    #warranty_expiration>

    $evm.log("info","#{@log_prefix} - Inserting Service-Now cmdb_ci_esx_server record for ESX Host:<#{host.name}> with <#{insert_hash.inspect}>")
    insertCI = callServiceNow(username, password, wsdl_uri, :insert, insert_hash)
  end

  #
  # Exit method
  #
  $evm.log("info", "#{@log_prefix} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@log_prefix} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="ServiceNow_Eccq_SOAP_Insert" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: ServiceNow_Eccq_SOAP_Insert
#
# Notes: This method uses a SOAP/XML call to post data to 
#   Service-Now's Ecc Queue
#
###################################
begin
  @method = 'ServiceNow_Eccq_SOAP_Insert'
  @log_prefix = "[#{@method}] --"
  $evm.log("info", "#{@log_prefix} EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true
  
  
  ###########################
  #
  # Method: eccqInsert
  # Inputs: 
  #
  ###########################
  def eccqInsert()
    # Require Savon Ruby Gem
    require "savon"

    username = nil
    username ||= $evm.object['username']

    password = nil
    password ||= $evm.object.decrypt('password')

    wsdl_uri = nil
    wsdl_uri ||= $evm.object['wsdl_uri']
    
    
    # Set up SOAP Connection to WSDL
    client = Savon::Client.new do |wsdl,http|
      wsdl.document = wsdl_uri
      http.auth.basic username, password
    end

    $evm.log("info","Namespace: #{client.wsdl.namespace.inspect}") if @debug
    $evm.log("info","Endpoint: #{client.wsdl.endpoint.inspect}") if @debug
    $evm.log("info","Actions: #{client.wsdl.soap_actions.inspect}") if @debug

    # Build the Payload in hash format
    payload = {}
    payload[:pay1] = 1
    payload[:pay2] = 'two'

    # Call Remedy
    response = client.request :insert do |soap|
      # Build the body of the XML elements 
      soap.body = {
        :agent             => 'EVM Agent',
        :agent_correlator  => 'EVM agent_correlator',
        :from_host         => 'EVM Host',
        :name              => 'EVM Name',
        :payload           => payload,
        :queue             => 'input',
        :source            => 'EVM Source',
        :topic             => 'EVM Topic',
      }
    end
    
    # Convert xml response to a hash
    # Service-Now hash Response:<{:insert_response=>{:sys_id=>"e3569c7bff1f2c80a19538abb67efe54", :topic=>"EVM Topic"}}>
    hash_response = response.to_hash[:insert_response]
    $evm.log("info","Inspecting Service-Now Response:<#{hash_response.inspect}>")

    $evm.log("info","Eccq Insert sys_id=<#{hash_response[:sys_id]}>")
    $evm.log("info","Eccq Insert topic=<#{hash_response[:topic]}>")
    return hash_response
  end
  
  servicecnowResponse = eccqInsert()
    
  #
  # Exit method
  #
  $evm.log("info", "#{@log_prefix} EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@log_prefix} [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="Tag_By_Application" language="ruby" scope="instance" location="inline"><![CDATA[#
# EVM Automate Method: Create CMDB CI in Service-now
#
# Notes: This method is used to Create a CMDB in Service-now
#
###################################
begin
  @method = 'Service_now Create/Update CI'
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Started")

  # Turn off verbose logging
  @debug = true

  ##################################################################
  # Look in the current object for a VM
  #
  vm = $evm.object['vm']
  if vm.nil?
    vm_id = $evm.object['vm_id'].to_i
    vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
  end

  #
  # Look in the Root Object for a VM
  #
  if vm.nil?
    vm = $evm.root['vm']
    if vm.nil?
      vm_id = $evm.root['vm_id'].to_i
      vm = $evm.vmdb('vm', vm_id) unless vm_id == 0
    end
  end

  # No VM Found, exit
  raise "VM not found" if vm.nil?
  ##################################################################

  # Get variables from Server object
  server = $evm.root['miq_server']
  evm_ipaddr    = server.ipaddress
  evm_hostname  = server.hostname
  evm_region    = server.region_number

  vm = $evm.root['vm']
  $evm.log("info", "Got VM from root object")
  $evm.log("info","Inspecting vm: #{vm.inspect}") if @debug
  vm_ipaddr = vm.ipaddresses.first
  vm_name = vm.name
  vm_id = vm['id']

  ems       = vm.ext_management_system
  $evm.log("info", "Got EMS <#{ems.name}> from VM <#{vm_name}>")
  $evm.log("info","Inspecting ems: #{ems.inspect}") if @debug
  ems_name = ems.hostname
  ems_ip = ems.ipaddress


  user = $evm.root['user']
  $evm.log("info","Inspecting User object: <#{user.inspect}>")
  username = user.name
  userid = user.userid

  
  host      = vm.host
  #$evm.log("info","Inspecting host: #{host.inspect}") if @debug
  $evm.log("info", "Got Host <#{host.name}> from VM <#{vm_name}>")
  host_name = host.name
  host_id = host['id']


process  = $evm.object("process")
hardware = vm.hardware
$evm.log("info","Inspecting hardware: #{hardware.inspect}") if @debug
owner               = vm.owner

os = vm.operating_system
$evm.log("info","Inspecting os: #{os.inspect}") if @debug



config_version      = hardware.config_version      #  varchar 255
virtual_hw_version  = hardware.virtual_hw_version  #  varchar 255
guest_os            = hardware.guest_os            #  varchar 255
numvcpus            = hardware.numvcpus            #  int4
bios                = hardware.bios                #  varchar 255
bios_location       = hardware.bios_location       #  varchar 255
time_sync           = hardware.time_sync           #  varchar 255
annotation          = hardware.annotation          #  text
vm_id               = hardware.vm_id               #  int8
memory_cpu          = hardware.memory_cpu          #  int4
host_id             = hardware.host_id             #  int8
cpu_speed           = hardware.cpu_speed           #  int4
cpu_type            = hardware.cpu_type            #  varchar 255
size_on_disk        = hardware.size_on_disk        #  int8
manufacturer        = hardware.manufacturer        #  varchar 255
model               = hardware.model               #  varchar 255
number_of_nics      = hardware.number_of_nics      #  int4
cpu_usage           = hardware.cpu_usage           #  int4
memory_usage        = hardware.memory_usage        #  int4
cores_per_socket    = hardware.cores_per_socket    #  int4
logical_cpus        = hardware.logical_cpus        #  int4
vmotion_enabled     = hardware.vmotion_enabled     #  int4
disk_free_space     = hardware.disk_free_space     #  int8
disk_capacity       = hardware.disk_capacity       #  int8
guest_os_full_name  = hardware.guest_os_full_name  #  varchar 255
memory_console      = hardware.memory_console      #  int4
product_name        = os.product_name
service_pack        = os.service_pack
os_width            = os.bitness
os_version          = os.version
os_type             = os.system_type

  
  


  applications= vm.guest_applications
 $evm.log("info","Inspecting applications: #{applications.inspect}") if @debug
        
  mail     = applications.any? { |a| (a.name.include? "Exchange") || (a.name.include? "Mail")}
  database = applications.any? { |a| (a.name.include? "SQL")      || (a.name.include?"Oracle")   }
  adobe    = applications.any? { |a| (a.name.include? "Adobe")  }
  
   $evm.log("info", "mail <#{mail}>")
   $evm.log("info", "database <#{database}>")
   $evm.log("info", "adobe <#{adobe}>")




  ###################################
  #
  # Call Service-Now
  #
  ###################################



  agent      = "EVM Automate CMDB Server"
  topic      = "Create/Update CI for VM"
  name       = "VM:#{vm_name} | Host:#{host_name} | IP:#{vm_ipaddr}"
  source     = "EVM Region:#{evm_region} | Hostname:#{evm_hostname} | IP:#{evm_ipaddr}"

  $evm.log("info","Server IP: #{evm_ipaddr}")

  $evm.log("info","VM IP: #{vm_ipaddr}")

  comments   = "EVM Creating/Updating CI for VM: #{vm_name} Host:#{host_name} Host IP:#{evm_ipaddr}"
  vmurl      = "https://#{evm_ipaddr}/vm/show/#{vm_id}"
  hosturl    = "https://#{evm_ipaddr}/host/show/#{host_id}"
  description = "EVM Creating/Updating CI for VM: #{vm_name} Host:#{host_name} Host IP:#{evm_ipaddr}"

  require 'uri'
  args =  "agent=#{agent}&"
  args += "topic=#{topic}&"
  args += "source=#{source}&"
  args += "name=#{name}&"
  args += "comments=#{comments}&"
  args += "vmurl=#{vmurl}&"
  args += "hosturl=#{hosturl}&"
  args += "evm_vmname=#{vm_name}&"
  args += "hostname=#{host_name}&"
  args += "emsname=#{ems_name}&"
  args += "emsip=#{ems_ip}&"
  args += "username=#{username}&"
  args += "userid=#{userid}&"
  args += "config_version=#{config_version}&"
  args += "virtual_hw_version=#{virtual_hw_version}&"
  args += "guest_os=#{guest_os}&"
  args += "numvcpus=#{numvcpus}&"
  args += "bios=#{bios}&"
  args += "bios_location=#{bios_location}&"
  args += "time_sync=#{time_sync}&"
  args += "annotation=#{annotation}&"
  args += "vm_id=#{vm_id}&"
  args += "memory_cpu=#{memory_cpu}&"
  args += "host_id=#{host_id}&"
  args += "cpu_speed=#{cpu_speed}&"
  args += "cpu_type=#{cpu_type}&"
  args += "size_on_disk=#{size_on_disk}&"
  args += "manufacturer=#{manufacturer}&"
  args += "model=#{model}&"
  args += "number_of_nics=#{number_of_nics}&"
  args += "cpu_usage=#{cpu_usage}&"
  args += "memory_usage=#{memory_usage}&"
  args += "cores_per_socket=#{cores_per_socket}&"
  args += "logical_cpus=#{logical_cpus}&"
  args += "vmotion_enabled=#{vmotion_enabled}&"
  args += "disk_free_space=#{disk_free_space}&"
  args += "disk_capacity=#{disk_capacity}&"
  args += "guest_os_full_name=#{guest_os_full_name}&"
  args += "memory_console=#{memory_console}&"
  args += "product_name=#{product_name}&"
  args += "service_pack=#{service_pack}&"
  args += "os_width=#{os_width}&"
  args += "os_type=#{os_type}&"
  args += "os_version=#{os_version}"

  args = URI.escape(args)

  $evm.log("info","Calling Service-Now with arguments: #{args}")
  $evm.instantiate("/Factory/ServiceNow/create_ci_in_eccq?#{args}")




  #
  # Exit method
  #
  $evm.log("info", "===== EVM Automate Method: <#{@method}> Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_STOP
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="method1" substitute="true" aetype="method" datatype="string" priority="1" message="create">
      </MiqAeField>
    </MiqAeSchema>
  </MiqAeClass>
  <MiqAeClass name="About" namespace="System" display_name="About">
    <MiqAeSchema>
      <MiqAeField name="version" substitute="true" aetype="attribute" datatype="string" priority="1" message="create">
5.2      </MiqAeField>
    </MiqAeSchema>
  </MiqAeClass>
  <MiqAeClass name="Event" namespace="System" description="Event " display_name="Event">
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="logical_event" substitute="true" aetype="attribute" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" priority="20" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="21" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing" display_name="Default for Missing Events">
      <MiqAeField name="logical_event">
other      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Alert_Cluster_Workload_Management" display_name="Alert Cluster Workload Management">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Operations/Intelligent_Workload_Management/Cluster_Workload_Management      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Alert_Host_Evacuation" display_name="Alert Host Evacuation">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Operations/Intelligent_Workload_Management/Host_Evacuation      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CloneVM_Task_Complete" display_name="VM - Clone Complete">
      <MiqAeField name="logical_event">
NOT_vm_created      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/Vm/${#logical_event}?vm_id=${process#dest_vm_id}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="CreateVM_Task_Complete" display_name="VM - Create Complete">
      <MiqAeField name="logical_event">
NOT_vm_created      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/Vm/${#logical_event}?vm_id=${process#vm_id}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Email_Alerts" display_name="General Email Alerts" description="Emails for VM, Host, Cluster, Storage, EMS, MIQ Server">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
/Alert/Email_Alerts/Parse_Alerts      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/Alert/Email_Alerts/${/#object_type}_Alert      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="HPOM_Alert" display_name="HP Operations Manager Alert">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
/Integration/HPOM/Parse_HPOM_Alerts      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/Integration/HPOM/HPOM_${/#object_type}_Alert      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PowerOffVM_Task_Complete" display_name="VM - Powered Off">
      <MiqAeField name="logical_event">
NOT_vm_created      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/Vm/${#logical_event}?vm_id=${process#vm_id}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="PowerOnVM_Task_Complete" display_name="VM - Powered On">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
vm_start      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/vm/${#logical_event}?vm_id=${process#vm_id}      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VM_Alert_CPU_Ready" display_name="VM - Alert - CPU Ready">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Operations/Intelligent_Workload_Management/VM_Placement_Optimization      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_approved" display_name="Request Approved">
      <MiqAeField name="rel5">
/System/Policy/request_approved      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_created" display_name="Request Created">
      <MiqAeField name="rel5">
/System/Policy/request_created      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_denied" display_name="Request Denied">
      <MiqAeField name="rel5">
/System/Policy/request_denied      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_pending" display_name="Request Pending">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/System/Policy/request_pending      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_starting" display_name="Request Starting">
      <MiqAeField name="rel5">
/System/Policy/request_starting      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_updated" display_name="Request Updated">
      <MiqAeField name="rel5">
/System/Policy/request_updated      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="service_retired" display_name="Service - Retired">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
service_retired      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
/Automation/ServiceLifecycle/Retirement?service_id=${process#service_id}      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_create" display_name="VM - Creation">
      <MiqAeField name="logical_event">
vm_create      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/VMLifecycle/Discovery?vm_id=${process#vm_id}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_provisioned" display_name="VM - Provisioned">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Alert/EmailNotifications/MiqProvision_Complete      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_retire_warn" display_name="VM - Retirement Warning">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
vm_retire_warn      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Alert/EmailNotifications/vm_retirement_emails      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_retired" display_name="VM - Retired">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
vm_retired      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
/Automation/VMLifecycle/Retirement?vm_id=${process#vm_id}      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_scan_abort" display_name="VM - Analysis Aborted">
      <MiqAeField name="logical_event">
vm_scan      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/Vm/${#logical_event}?vm_id=${process#vm_id}&amp;status=error      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_scan_complete" display_name="VM - Analysis Complete">
      <MiqAeField name="logical_event">
vm_scan      </MiqAeField>
      <MiqAeField name="rel5">
/Automation/Vm/${#logical_event}?vm_id=${process#vm_id}&amp;status=ok      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_start" display_name="VM - Start">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Policy" namespace="System" description="Policy" display_name="Policy">
    <MiqAeMethod name="MiqHostProvision_Auto_Approve" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: MiqHostProvision_Auto_Approve
#
# Notes: This method auto-approves the host provisioning request
#
#
###################################
begin
  @method = 'MiqHostProvision_Auto_Approve'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Auto-Approve request
  $evm.log("info", "#{@method} - AUTO-APPROVING") if @debug
  $evm.root["miq_request"].approve("admin", "Auto-Approved")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="VmMigrateRequest_Auto_Approve" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: vm_migrate_auto_approve
#
# Notes: This method auto-approves the vm migration request
#
#
###################################
begin
  @method = 'vm_migrate_auto_approve'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  # Auto-Approve request
  $evm.log("info", "#{@method} - AUTO-APPROVING") if @debug
  $evm.root["miq_request"].approve("admin", "Auto-Approved")

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeMethod name="get_request_type" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: get_request_type
#
# Notes: This method is used get the incoming request type
#
###################################
begin
  @method = 'get_request_type'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  miq_request = $evm.root["miq_request"]
  raise "#{@method} - MiqRequest Not Found" if miq_request.nil?

  $evm.object['request_type'] = miq_request.resource_type
  $evm.root['user'] ||= $evm.root['miq_request'].requester

  $evm.log("info","#{@method} - Request Type:<#{$evm.object['request_type']}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "#{@method} - [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="logical_event" substitute="true" aetype="attribute" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" priority="20" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" priority="21" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" priority="22" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" priority="23" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" priority="24" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" priority="25" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="26" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing">
    </MiqAeInstance>
    <MiqAeInstance name="MiqHostProvisionRequest_created" display_name="Host Provision Request Created">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
MiqHostProvision_Auto_Approve      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqHostProvisionRequest_starting" display_name="Host Provision Request Starting">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqHostProvisionRequest_updated" display_name="Host Provision Request Updated">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvisionRequest_Updated" display_name="Provision Request Updated">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Provisioning/Profile/${/#miq_request.resource.ci_type}/${/#user.normalized_ldap_group}#get_auto_approval_state_machine      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
/Factory/StateMachines/${/#state_machine}/Default      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvisionRequest_created" display_name="Provision Request Created">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Provisioning/Profile/${/#miq_request.resource.ci_type}/${/#user.normalized_ldap_group}#get_auto_approval_state_machine      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
/Factory/StateMachines/${/#state_machine}/Default      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="MiqProvisionRequest_starting" display_name="Provision Request Starting">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Provisioning/Profile/${/#miq_request.resource.ci_type}/${/#user.normalized_ldap_group}#get_quota_state_machine      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
/Factory/StateMachines/${/#state_machine}/Default      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="ServiceTemplateProvisionRequest_created" display_name="Service Template Provision Request Created">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Provisioning/Profile/${/#miq_request.resource.ci_type}/${/#user.normalized_ldap_group}#get_auto_approval_state_machine      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
/Factory/StateMachines/${/#state_machine}/Default      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VmMigrateRequest_created" display_name="VM Migration Request Created">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
VmMigrateRequest_Auto_Approve      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VmMigrateRequest_starting" display_name="VM Migration Request Starting">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VmMigrateRequest_updated" display_name="VM Migration Request Updated">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request" display_name="Request">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_approved" display_name="Request Approved">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Alert/EmailNotifications/${/#miq_request.type}_Approved      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_created" display_name="Request Created">
      <MiqAeField name="on_entry">
get_request_type      </MiqAeField>
      <MiqAeField name="rel5">
/System/Policy/${#request_type}_created      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_denied" display_name="Request Denied">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Alert/EmailNotifications/${/#miq_request.type}_Denied      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_pending" display_name="Request Pending">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="logical_event">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Alert/EmailNotifications/${/#miq_request.type}_Pending      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_starting" display_name="Request Starting">
      <MiqAeField name="on_entry">
get_request_type      </MiqAeField>
      <MiqAeField name="rel5">
/System/Policy/${#request_type}_starting      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="request_updated" display_name="Request Updated">
      <MiqAeField name="on_entry">
get_request_type      </MiqAeField>
      <MiqAeField name="rel5">
/System/Policy/${#request_type}_updated      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Process" namespace="System" description="Automation Initialization" display_name="Automation Starting Point">
    <MiqAeMethod name="parse_automation_request" language="ruby" scope="instance" location="inline"><![CDATA[###################################
#
# EVM Automate Method: parse_automation_request
#
# Notes: This method is used to parse incoming automation requests
#
###################################
begin
  @method = 'parse_automation_request'
  $evm.log("info", "#{@method} - EVM Automate Method Started")

  # Turn of verbose logging
  @debug = true

  cur = $evm.object
  case cur['request']
  when 'vm_provision'
    cur['target_class']    = 'VMLifecycle'
    cur['target_instance'] = 'Provisioning'
  when 'vm_retired'
    cur['target_class']    = 'VMLifecycle'
    cur['target_instance'] = 'Retirement'
  when 'vm_migrate'
    cur['target_class']    = 'VMLifecycle'
    cur['target_instance'] = 'Migrate'
  when 'host_provision'
    cur['target_class']    = 'HostLifecycle'
    cur['target_instance'] = 'Provisioning'
  end

  $evm.log("info", "#{@method} - Request:<#{cur['request']}> Target Class:<#{cur['target_class']}> Target Instance:<#{cur['target_instance']}>") if @debug

  #
  # Exit method
  #
  $evm.log("info", "#{@method} - EVM Automate Method Ended")
  exit MIQ_OK

  #
  # Set Ruby rescue behavior
  #
rescue => err
  $evm.log("error", "<#{@method}>: [#{err}]\n#{err.backtrace.join("\n")}")
  exit MIQ_ABORT
end]]>    </MiqAeMethod>
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="20" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name="Automation" display_name="EVM Automation">
      <MiqAeField name="meth1">
parse_automation_request      </MiqAeField>
      <MiqAeField name="rel2">
/Automation/${#target_class}/${#target_instance}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Event" display_name="EVM Events">
      <MiqAeField name="rel5">
/System/Event/${#event_type}      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Request" display_name="EVM Requests">
      <MiqAeField name="rel5">
/System/Request/${#request}      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
  <MiqAeClass name="Request" namespace="System" description="Automation Requests" display_name="Automation Requests">
    <MiqAeSchema>
      <MiqAeField name="guard" substitute="true" aetype="assertion" priority="1" message="create">
      </MiqAeField>
      <MiqAeField name="on_entry" substitute="true" aetype="method" priority="2" message="create">
      </MiqAeField>
      <MiqAeField name="rel1" substitute="true" aetype="relationship" priority="3" message="create">
      </MiqAeField>
      <MiqAeField name="meth1" substitute="true" aetype="method" priority="4" message="create">
      </MiqAeField>
      <MiqAeField name="rel2" substitute="true" aetype="relationship" priority="5" message="create">
      </MiqAeField>
      <MiqAeField name="meth2" substitute="true" aetype="method" priority="6" message="create">
      </MiqAeField>
      <MiqAeField name="rel3" substitute="true" aetype="relationship" priority="7" message="create">
      </MiqAeField>
      <MiqAeField name="meth3" substitute="true" aetype="method" priority="8" message="create">
      </MiqAeField>
      <MiqAeField name="rel4" substitute="true" aetype="relationship" priority="9" message="create">
      </MiqAeField>
      <MiqAeField name="meth4" substitute="true" aetype="method" priority="10" message="create">
      </MiqAeField>
      <MiqAeField name="rel5" substitute="true" aetype="relationship" priority="11" message="create">
      </MiqAeField>
      <MiqAeField name="meth5" substitute="true" aetype="method" priority="12" message="create">
      </MiqAeField>
      <MiqAeField name="rel6" substitute="true" aetype="relationship" priority="13" message="create">
      </MiqAeField>
      <MiqAeField name="meth6" substitute="true" aetype="method" priority="14" message="create">
      </MiqAeField>
      <MiqAeField name="rel7" substitute="true" aetype="relationship" priority="15" message="create">
      </MiqAeField>
      <MiqAeField name="meth7" substitute="true" aetype="method" priority="16" message="create">
      </MiqAeField>
      <MiqAeField name="rel8" substitute="true" aetype="relationship" priority="17" message="create">
      </MiqAeField>
      <MiqAeField name="meth8" substitute="true" aetype="method" priority="18" message="create">
      </MiqAeField>
      <MiqAeField name="rel9" substitute="true" aetype="relationship" priority="19" message="create">
      </MiqAeField>
      <MiqAeField name="on_exit" substitute="true" aetype="method" priority="20" message="create">
      </MiqAeField>
    </MiqAeSchema>
    <MiqAeInstance name=".missing" display_name="Default for Undefined Requests">
    </MiqAeInstance>
    <MiqAeInstance name="Call_Instance">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/${/#namespace}/${/#class}/${/#instance}      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Cluster_Workload_Management">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/System/Event/Alert_Cluster_Workload_Management      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Host_Evacuation">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/System/Event/Alert_Host_Evacuation      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="IPAM_Import">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/Integration/MIQ_IPAM/IPAM_Methods/IPAM_Import      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="InspectME">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Sample/Methods/InspectME      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Reconfigure_CDROM">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/Integration/VCLI/Reconfigure_CDROM      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Reconfigure_CPU">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/Integration/VCLI/Reconfigure_CPU      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="Reconfigure_RAM">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
/Integration/VCLI/Reconfigure_RAM      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="UI_Host_Provision_Info" display_name="Host - EVM Provisioning Application">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Provisioning/Profile/Host/${/#user.normalized_ldap_group}#${process#message}      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="UI_Provision_Info" display_name="VM - EVM Provisioning Application">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Provisioning/Profile/VM/${/#user.normalized_ldap_group}#${process#message}      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="UI_Vm_Migrate_Info" display_name="Vm - Migrate Application">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/EVMApplications/Operations/Profile/VmMigrate/${/#user.normalized_ldap_group}#${process#message}      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="VM_Alert_CPU_Ready">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/System/Event/VM_Alert_CPU_Ready      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
    <MiqAeInstance name="vm_retire_extend">
      <MiqAeField name="guard">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_entry">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth1">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth2">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth3">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth4">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel5">
/Alert/EmailNotifications/vm_retire_extend      </MiqAeField>
      <MiqAeField name="meth5">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth6">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth7">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="meth8">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="rel9">
        <![CDATA[]]>
      </MiqAeField>
      <MiqAeField name="on_exit">
        <![CDATA[]]>
      </MiqAeField>
    </MiqAeInstance>
  </MiqAeClass>
</MiqAeDatastore>
