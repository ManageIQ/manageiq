class ContainerLabelTagMapping < ApplicationRecord
  # A mapping matches labels on `resource_type` (NULL means any), `name` (required),
  # and `value` (NULL means any).
  #
  # Different labels might map to one tag, and one label might map to multiple tags.
  #
  # There are 2 kinds of rows:
  # - When `label_value` is specified, we map only this value to a specific `tag`.
  # - When `label_value` is NULL, we map this name with any value to per-value tags.
  #   In this case, `tag` specifies the category under which to create
  #   the value-specific tag (and classification) on demand.
  #   We then also add a specific `label_value`->specific `tag` mapping here.

  belongs_to :tag

  # Unused but good documentation.  TODO: use in test?
  def applies_to_label?(label)
    ((labeled_resource_type.nil? || label.resource_type == labeled_resource_type) &&
     label.name == label_name &&
     (label_value.nil? || label.value == label_value))
  end

  def self.all_tags_for_entity(entity)
    # TODO: invert join so results are mapping instances instead of CustomAttributes instances?
    #   (attributes either way are what's listed in .select() below, but I'd like my methods)
    join = entity.labels.joins(
      'INNER JOIN container_label_tag_mappings
       ON (container_label_tag_mappings.labeled_resource_type = custom_attributes.resource_type OR
           container_label_tag_mappings.labeled_resource_type IS NULL)
          AND
          custom_attributes.name = container_label_tag_mappings.label_name
          AND
          (container_label_tag_mappings.label_value = custom_attributes.value OR
           container_label_tag_mappings.label_value IS NULL)'.squish
    ).select(
      'custom_attributes.resource_type, container_label_tag_mappings.labeled_resource_type,
       custom_attributes.name,          container_label_tag_mappings.label_name,
       custom_attributes.value,         container_label_tag_mappings.label_value,
       container_label_tag_mappings.tag_id'.squish)

    tags = []
    # Group by label, handle each separately.
    by_label = join.group_by { |j| [j.resource_type, j.name, j.value] }
    by_label.each do |(type, name, value), join_rows|
      # If we have both (type, name, maybe_value) and (nil, name, maybe_value) mappings,
      # apply both!
      # And handle the question of specific-value and/or any-value separately for each.
      by_specific_type = join_rows.partition { |r| r.labeled_resource_type.nil? }
      by_specific_type.each do |rows|
        (any_value, specific) = rows.partition { |r| r.label_value.nil? }
        if ! specific.empty?
          tags.concat(Tag.find(specific.map(&:tag_id)))
        else
          any_value.each do |r|
            category_tag = Tag.find(r.tag_id)
            tags << create_specific_value_mapping(r.labeled_resource_type, r.label_name, value, category_tag).tag
          end
        end
      end
    end

    tags
  end

  # Finds all existing specific-value tags we're pointing to.  TODO: better name?
  # TODO: cache?
  def self.all_mapped_tags
    Tag.joins(:container_label_tag_mappings).where('container_label_tag_mappings.label_value IS NOT NULL')
  end

  # TODO: before_remove a mapping, clean up tags generated by *that* mapping.

  private

  # If this is an open ended any-value mapping, finds or creates a
  # specific-value mapping to a specific tag.
  def self.create_specific_value_mapping(type, name, value, category_tag)
    create!(
      :labeled_resource_type => type,
      :label_name            => name,
      :label_value           => value,
      :tag                   => create_tag(category_tag, value)
    )
  end

  def self.create_tag(category_tag, value)
    entry_name = Classification.sanitize_name(value)
    # TODO: support /ns/category Tag that has no Classification?
    category = category_tag.classification
    entry = category.add_entry(:name => entry_name, :description => value)
    entry.save!
    entry.tag
  end
end
