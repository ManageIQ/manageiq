class ContainerLabelTagMapping < ApplicationRecord
  # A mapping matches labels on `resource_type` (NULL means any), `name` (required),
  # and `value` (NULL means any).
  #
  # Different labels might map to one tag, and one label might map to multiple tags.
  #
  # There are 2 kinds of rows:
  # - When `label_value` is specified, we map only this value to a specific `tag`.
  # - When `label_value` is NULL, we map this name with any value to per-value tags.
  #   In this case, `tag` specifies the category under which to create
  #   the value-specific tag (and classification) on demand.
  #   We then also add a specific `label_value`->specific `tag` mapping here.
  belongs_to :tag

  # An empty string value is legal for labels; only NULL represents any value.
  def any_value?
    label_value.nil?
  end

  def specific_value?
    !any_value?
  end

  def applies_to_label?(label)
    ((labeled_resource_type.nil? || label.resource_type == labeled_resource_type) &&
     label.name == label_name &&
     (any_value? || label.value == label_value))
  end

  # Returns a Tag or nil.
  def tag_for_label(label)
    specific_mapping_for_value(label.value).tag if applies_to_label?(label)
  end

  # If this is an open ended any-value mapping, finds or creates a
  # specific-value mapping to a specific tag.
  def specific_mapping_for_value(value)
    if specific_value?
      self
    else
      self.class.where(
        :labeled_resource_type => labeled_resource_type,
        :label_name            => label_name,
        :label_value           => value
      ).first_or_create do |mapping|
        mapping.tag = create_tag(value)
      end
    end
  end

  def create_tag(value)
    category = tag.classification
    entry_name = Classification.sanitize_name(value)
    entry = category.add_entry(:name => entry_name, :description => value)
    entry.save!
    entry.tag
  end

  # TODO: miserably inefficient N*M.
  #   Optimize after having tests; for now applies_to_label?()
  #   is source of truth.

  def self.all_tags_for_label(label)
    # TODO: .uniq compensates for potentially both any-value and specific-value mapping
    # returning same tag twice.
    all.collect { |mapping| mapping.tag_for_label(label) }.compact.uniq
  end

  def self.all_tags_for_entity(entity)
    tags = []
    entity.labels.each do |label|
      tags.concat(all_tags_for_label(label))
    end
    tags
  end

  # Finds all existing specific-value tags we're pointing to.  TODO: better name?
  # TODO: cache?
  def self.all_mapped_tags
    Tag.joins(:container_label_tag_mappings)
  end

  # TODO: before_remove a mapping, clean up tags generated by *that* mapping.
end
