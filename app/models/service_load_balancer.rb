class ServiceLoadBalancer < Service
  include ServiceLoadBalancerMixin
  include ServiceLoadBalancerOptionsMixin

  # read from DB or parse from dialog
  def load_balancer_name
    @load_balancer_name ||= get_option(:load_balancer_name) || OptionConverter.load_balancer_name(get_option(:dialog) || {})
  end

  # override existing load_balancer name (most likely from dialog)
  def load_balancer_name=(lbname)
    @load_balancer_name = lbname
    save_option(:load_balancer_name, lbname)
  end

  def load_balancer_status
    return "check_status_failed", "load_balancer has not been deployed" unless load_balancer

    'create_complete'
  rescue MiqException::MiqLoadBalancerNotExistError, MiqException::MiqLoadBalancerStatusError => err
    # naming convention requires status to end with "failed"
    ["check_status_failed", err.message]
  end

  def deploy_load_balancer
    @load_balancer = LoadBalancer.create_load_balancer(
      load_balancer_manager, load_balancer_name, load_balancer_options)
    add_resource(@load_balancer)
    @load_balancer
  ensure
    # create options may never be saved before unless they were overridden
    save_create_options
  end

  def update_load_balancer
    # use template from service_template, which may be different from existing template
    load_balancer.raw_update_load_balancer(update_options)
  end

  def load_balancer
    @load_balancer ||= service_resources.find { |sr| sr.resource.kind_of?(LoadBalancer) }.try(:resource)
  end

  def build_load_balancer_options_from_dialog(dialog_options)
    converter = OptionConverter.get_converter(dialog_options || {}, load_balancer_manager.class)
    converter.load_balancer_create_options
  end

  def indirect_vms
    load_balancer.try(:indirect_vms) || []
  end

  def direct_vms
    # Loading all VMs, to make listing of the VMs under Service work, when we deal with nested load_balancers. A proper fix
    # would be to use something like closure_tree, where we can build tree from the multiple classes. Then Service level
    # MiqPreloader.preload_and_map(subtree, :direct_vms) will work also for nested load_balancers. Because in that case, nested
    # load_balancers will be a part of the subtree.
    load_balancer.try(:vms) || []
  end

  def all_vms
    load_balancer.try(:vms) || []
  end

  def post_provision_configure
    # assign the owner to all vms generated by this service
    all_vms.each do |vm|
      vm.update_attributes(:evm_owner_id => evm_owner_id, :miq_group_id => miq_group_id)
    end
  end

  private

  def save_create_options
    options.merge!(:load_balancer_name => load_balancer_name,
                   :create_options     => load_balancer_options)
    save!
  end
end
